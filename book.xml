<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<book lang="en">
<bookinfo>
    <title>Mastering Lightning Network</title>
</bookinfo>
<preface id="preface">
<title>Preface</title>
<simpara>The Lightning Network (LN) is a second layer peer-to-peer network that allows us to make Bitcoin payments "off-chain," meaning without committing them as transactions to the Bitcoin blockchain.</simpara>
<simpara>The Lightning Network gives us Bitcoin payments that are secure, cheap, fast, and much more private, even for very small payments.</simpara>
<simpara>Building on the idea of payment channels, first proposed by Bitcoin&#8217;s inventor Satoshi Nakamoto, the Lightning Network is a routed network of payment channels where payments "hop" across a path of payment channels from the sender to the recipient.</simpara>
<simpara>The initial idea of the Lightning Network was proposed in 2015 in the groundbreaking paper "The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments," by Joseph Poon and Thaddeus Dryja. By 2017, there was a "test" Lightning Network running on the internet, as different groups built compatible implementations and coordinated to set some interoperability standards. In 2018, the Lightning Network went "live" and payments started flowing.</simpara>
<simpara>In 2019, Andreas M. Antonopoulos, Olaoluwa Osuntokun, and René Pickhardt agreed to collaborate to write this book. It appears we have been successful!</simpara>
<section id="intended_audience_sec">
<title>Intended Audience</title>
<simpara>This book is mostly intended for technical readers with an understanding of the fundamentals of Bitcoin and other open blockchains.</simpara>
</section>
<section id="conventinons_used_sec" role="pagebreak-before less_space">
<title>Conventions Used in This Book</title>
<simpara>The following typographical conventions are used in this book:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis>Italic</emphasis>
</term>
<listitem>
<simpara>
Indicates new terms, URLs, email addresses, filenames, and file extensions.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>Constant width</literal>
</term>
<listitem>
<simpara>
Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>Constant width bold</literal></emphasis>
</term>
<listitem>
<simpara>
Shows commands or other text that should be typed literally by the user.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis><literal>Constant width italic</literal></emphasis>
</term>
<listitem>
<simpara>
Shows text that should be replaced with user-supplied values or by values determined by context.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>This element signifies a tip or suggestion.</simpara>
</tip>
<note>
<simpara>This element signifies a general note.</simpara>
</note>
<warning>
<simpara>This element indicates a warning or caution.</simpara>
</warning>
</section>
<section id="code_examples_sec">
<title>Code Examples</title>
<simpara>The examples are illustrated in Go, C++, Python, and using the command line of a Unix-like operating system. All code snippets are available in the GitHub repository under the <emphasis>code</emphasis> subdirectory. Fork the book code, try the code examples, or submit corrections via <ulink url="https://github.com/lnbook/lnbook">GitHub</ulink>.</simpara>
<simpara>All the code snippets can be replicated on most operating systems with a minimal installation of compilers, interpreters, and libraries for the corresponding languages. Where necessary, we provide basic installation instructions and step-by-step examples of the output of those instructions.</simpara>
<simpara>Some of the code snippets and code output have been reformatted for print. In all such cases, the lines have been split by a backslash (<literal>\</literal>) character, followed by a newline character. When transcribing the examples, remove those two characters and join the lines again and you should see identical results to those shown in the example.</simpara>
<simpara>All the code snippets use real values and calculations where possible, so that you can build from example to example and see the same results in any code you write to calculate the same values. For example, the private keys and corresponding public keys and addresses are all real.</simpara>
</section>
<section id="using_code_examples_sec">
<title>Using Code Examples</title>
<simpara>If you have a technical question or a problem using the code examples, please send email to <a class="email" href="mailto:bookquestions@oreilly.com"><em>bookquestions@oreilly.com</em></a>.</simpara>
<simpara>This book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.</simpara>
<simpara>We appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, ISBN, and copyright. For example: &#x201c;<emphasis>Mastering the Lightning Network</emphasis> by Andreas M. Antonopoulos, Olaoluwa Osuntokun, and René Pickhardt (O&#8217;Reilly). Copyright 2022 aantonop Books LLC, René Pickhardt, and uuddlrlrbas LLC, ISBN 978-1-492-05486-3."</simpara>
<simpara><emphasis>Mastering the Lightning Network</emphasis> is offered under the Creative Commons Attribution-Noncommercial-No Derivative Works 4.0 International License (CC BY-NC-ND 4.0).</simpara>
<simpara>If you feel your use of code examples falls outside fair use or the permission given previously, feel free to contact us at <a href="mailto:permissions@oreilly.com">permissions@oreilly.com</a>.</simpara>
</section>
<section id="_references_to_companies_and_products">
<title>References to Companies and Products</title>
<simpara>All references to companies and products are intended for educational, demonstration, and reference purposes. The authors do not endorse any of the companies <span class="keep-together">or products</span> mentioned. We have not tested the operation or security of any of the products, projects, or code segments shown in this book. Use them at your own risk!</simpara>
</section>
<section id="addresses_and_transactions_sec">
<title>Addresses and Transactions in This Book</title>
<simpara>The Bitcoin addresses, transactions, keys, QR codes, and blockchain data used in this book are, for the most part, real. That means you can browse the blockchain, look at the transactions offered as examples, retrieve them with your own scripts or programs, etc.</simpara>
<simpara>However, note that the private keys used to construct the addresses printed in this book have been "burned." This means that if you send money to any of these addresses, the money will either be lost forever or (more likely) appropriated, since anyone who reads the book can take it using the private keys printed herein.</simpara>
<warning>
<simpara>DO NOT SEND MONEY TO ANY OF THE ADDRESSES IN THIS BOOK. Your money will be taken by another reader, or lost forever.</simpara>
</warning>
</section>
<section id="_o_8217_reilly_online_learning">
<title>O&#8217;Reilly Online Learning</title>
<note role="ormenabled">
<simpara>For more than 40 years, <a href="http://oreilly.com" class="orm:hideurl"><em class="hyperlink">O’Reilly Media</em></a> has provided technology and business training, knowledge, and insight to help companies succeed.</simpara>
</note>
<simpara>Our unique network of experts and innovators share their knowledge and expertise through books, articles, and our online learning platform. O’Reilly’s online learning platform gives you on-demand access to live training courses, in-depth learning paths, interactive coding environments, and a vast collection of text and video from O&#8217;Reilly and 200+ other publishers. For more information, visit <a href="http://oreilly.com" class="orm:hideurl"><em>http://oreilly.com</em></a>.</simpara>
</section>
<section id="how_to_contact_us_sec">
<title>How to Contact Us</title>
<simpara>Information about <emphasis>Mastering the Lightning Network</emphasis> as well as the Open Edition and translations are available at <ulink url="https://lnbook.info">https://lnbook.info</ulink>.</simpara>
<simpara>Please address comments and questions concerning this book to the publisher:</simpara>
<ul class="simplelist">
  <li>O’Reilly Media, Inc.</li>
  <li>1005 Gravenstein Highway North</li>
  <li>Sebastopol, CA 95472</li>
  <li>800-998-9938 (in the United States or Canada)</li>
  <li>707-829-0515 (international or local)</li>
  <li>707-829-0104 (fax)</li>
</ul>
<simpara>Email <a class="email" href="mailto:bookquestions@oreilly.com"><em>bookquestions@oreilly.com</em></a> to comment or ask technical questions about this book.</simpara>
<simpara>For news and information about our books and courses, visit <ulink url="http://oreilly.com">http://oreilly.com</ulink>.</simpara>
<simpara>Find us on Facebook: <ulink url="http://facebook.com/oreilly">http://facebook.com/oreilly</ulink></simpara>
<simpara>Follow us on Twitter: <ulink url="http://twitter.com/oreillymedia">http://twitter.com/oreillymedia</ulink></simpara>
<simpara>Watch us on YouTube: <ulink url="http://www.youtube.com/oreillymedia">http://www.youtube.com/oreillymedia</ulink></simpara>
<section id="_contacting_andreas">
<title>Contacting Andreas</title>
<simpara>You can contact Andreas M. Antonopoulos on his personal site:
<ulink url="https://aantonop.com">https://aantonop.com</ulink></simpara>
<simpara>Subscribe to Andreas&#8217;s channel on YouTube:
<ulink url="https://www.youtube.com/aantonop">https://www.youtube.com/aantonop</ulink></simpara>
<simpara>Like Andreas&#8217;s page on Facebook:
<ulink url="https://www.facebook.com/AndreasMAntonopoulos">https://www.facebook.com/AndreasMAntonopoulos</ulink></simpara>
<simpara>Follow Andreas on Twitter:
<ulink url="https://twitter.com/aantonop">https://twitter.com/aantonop</ulink></simpara>
<simpara>Connect with Andreas on LinkedIn:
<ulink url="https://linkedin.com/company/aantonop">https://linkedin.com/company/aantonop</ulink></simpara>
<simpara>Andreas would also like to thank the patrons who support his work through monthly donations. You can support Andreas on Patreon at <ulink url="https://patreon.com/aantonop">https://patreon.com/aantonop</ulink>.</simpara>
</section>
<section id="_contacting_rené">
<title>Contacting René</title>
<simpara>You can contact René Pickhardt on his personal site:
<ulink url="https://ln.rene-pickhardt.de">https://ln.rene-pickhardt.de</ulink></simpara>
<simpara>Subscribe to René&#8217;s channel on YouTube:
<ulink url="https://www.youtube.com/user/RenePickhardt">https://www.youtube.com/user/RenePickhardt</ulink></simpara>
<simpara>Follow René on Twitter:
<ulink url="https://twitter.com/renepickhardt">https://twitter.com/renepickhardt</ulink></simpara>
<simpara>Connect with René on LinkedIn:
<ulink url="https://www.linkedin.com/in/rene-pickhardt-80313744">https://www.linkedin.com/in/rene-pickhardt-80313744</ulink></simpara>
<simpara>René would also like to thank all of the patrons who support his work through monthly donations. You can support René on Patreon at <ulink url="https://patreon.com/renepickhardt">https://patreon.com/renepickhardt</ulink>.</simpara>
<simpara>Or you can support his work directly with Bitcoin (also via the Lightning Network) at <ulink url="https://donate.ln.rene-pickhardt.de">https://donate.ln.rene-pickhardt.de</ulink> for which René is equally thankful as for his patreons.</simpara>
</section>
<section id="_contacting_olaoluwa_osuntokun">
<title>Contacting Olaoluwa Osuntokun</title>
<simpara>You can contact Olaoluwa Osuntokun at his professional email address:
<emphasis>laolu@lightning.engineering</emphasis></simpara>
<simpara>Follow Olaoluwa on Twitter:
<ulink url="https://twitter.com/roasbeef">https://twitter.com/roasbeef</ulink></simpara>
</section>
</section>
<section id="acknowledgments_sec">
<title>Acknowledgments by Andreas</title>
<simpara>I owe my love of words and books to my mother, Theresa, who raised me in a house with books lining every wall. My mother also bought me my first computer in 1982, despite being a self-described technophobe. My father, Menelaos, a civil engineer who published his first book at 80 years old, was the one who taught me logical and analytical thinking and a love of science and engineering.</simpara>
<simpara>Thank you all for supporting me throughout this journey.</simpara>
</section>
<section id="_acknowledgments_by_rené">
<title>Acknowledgments by René</title>
<simpara>I want to thank the German education system through which I acquired the knowledge upon which my work builds. It is one of the greatest gifts I was given.
Similarly I want to thank the German public healthcare system and every person devoting their time into working within that industry. Your effort and endurance make you my personal heroes and I will never forget the help, patience, and support I received when I was in need.
Thanks goes to all the students I was allowed to teach and who engaged in interesting discussions and questions. From you I learned the most.
I am also grateful to the Bitcoin and Lightning Network community that warmly welcomed me and to the enthusiasts and private persons who financially supported and continue to support my work.
In particular I am grateful to all the open source developers (not only Bitcoin and Lightning Network) and to the people who fund them to make that technology possible.
A special thanks goes to my coauthors for riding with me through the storm.
Last but not least, I am thankful to my loved ones.</simpara>
</section>
<section id="_acknowledgments_by_olaoluwa_osuntokun">
<title>Acknowledgments by Olaoluwa Osuntokun</title>
<simpara>I&#8217;d like to thank the amazing team at Lightning Labs, as without you all, there
would be no LND. I&#8217;d also like to thank the original set of authors of the BOLT
specification: Rusty Russell, Fabrice Drouin, Conner Fromnkchet, Pierre-Marie
Padiou, Lisa Neigut, and Christian Decker. Last but not least, I&#8217;d like to
thank Joseph Poon and Tadge Dryja, the authors of the original Lightning
Network paper, as without them, there would be no Lightning Network to write a
book about.</simpara>
</section>
<section id="github_contrib">
<title>Contributions</title>
<simpara>Many contributors offered comments, corrections, and additions to the book as it was collaboratively written on GitHub.</simpara>
<simpara>Following is an alphabetically sorted list of all the GitHub contributors, including their GitHub IDs in parentheses:</simpara>
<itemizedlist>
<listitem>
<simpara>
8go (@8go)
</simpara>
</listitem>
<listitem>
<simpara>
Aaqil Aziz (@batmanscode)
</simpara>
</listitem>
<listitem>
<simpara>
Alexander Gnip (@quantumcthulhu)
</simpara>
</listitem>
<listitem>
<simpara>
Alpha Q. Smith (@alpha_github_id)
</simpara>
</listitem>
<listitem>
<simpara>
Ben Skee (@benskee)
</simpara>
</listitem>
<listitem>
<simpara>
Brian L. McMichael (@brianmcmichael)
</simpara>
</listitem>
<listitem>
<simpara>
CandleHater (@CandleHater)
</simpara>
</listitem>
<listitem>
<simpara>
Daniel Gockel (@dancodery)
</simpara>
</listitem>
<listitem>
<simpara>
Dapeng Li (@luislee818)
</simpara>
</listitem>
<listitem>
<simpara>
Darius E. Parvin (@DariusParvin)
</simpara>
</listitem>
<listitem>
<simpara>
Doru Muntean (@chriton)
</simpara>
</listitem>
<listitem>
<simpara>
Eduardo Lima III (@elima-iii)
</simpara>
</listitem>
<listitem>
<simpara>
Emilio Norrmann (@enorrmann)
</simpara>
</listitem>
<listitem>
<simpara>
Francisco Calderón (@grunch)
</simpara>
</listitem>
<listitem>
<simpara>
Francisco Requena (@FrankyFFV)
</simpara>
</listitem>
<listitem>
<simpara>
François Degros (@fdegros)
</simpara>
</listitem>
<listitem>
<simpara>
Giovanni Zotta (@GiovanniZotta)
</simpara>
</listitem>
<listitem>
<simpara>
Gustavo Silva (@GustavoRSSilva)
</simpara>
</listitem>
<listitem>
<simpara>
Guy Thayakorn (@saguywalker)
</simpara>
</listitem>
<listitem>
<simpara>
Haoyu Lin (@HAOYUatHZ)
</simpara>
</listitem>
<listitem>
<simpara>
Hatim Boufnichel (@boufni95)
</simpara>
</listitem>
<listitem>
<simpara>
Imran Lorgat (@ImranLorgat)
</simpara>
</listitem>
<listitem>
<simpara>
Jeffrey McLarty (@jnmclarty)
</simpara>
</listitem>
<listitem>
<simpara>
John Davies (@tigeryant)
</simpara>
</listitem>
<listitem>
<simpara>
Julien Wendling (@trigger67)
</simpara>
</listitem>
<listitem>
<simpara>
Jussi Tiira (@juhi24)
</simpara>
</listitem>
<listitem>
<simpara>
Kory Newton (@korynewton)
</simpara>
</listitem>
<listitem>
<simpara>
Lawrence Webber (@lwebbz)
</simpara>
</listitem>
<listitem>
<simpara>
Luigi (@gin)
</simpara>
</listitem>
<listitem>
<simpara>
Maximilian Karasz (@mknoszlig)
</simpara>
</listitem>
<listitem>
<simpara>
Omega X. Last (@omega_github_id)
</simpara>
</listitem>
<listitem>
<simpara>
Owen Gunden (@ogunden)
</simpara>
</listitem>
<listitem>
<simpara>
Patrick Lemke (@PatrickLemke)
</simpara>
</listitem>
<listitem>
<simpara>
Paul Wackerow (@wackerow)
</simpara>
</listitem>
<listitem>
<simpara>
Randy McMillan (@RandyMcMillan)
</simpara>
</listitem>
<listitem>
<simpara>
René Köhnke (@rene78)
</simpara>
</listitem>
<listitem>
<simpara>
Ricardo Marques (@RicardoM17)
</simpara>
</listitem>
<listitem>
<simpara>
Sebastian Falbesoner (@theStack)
</simpara>
</listitem>
<listitem>
<simpara>
Sergei Tikhomirov (@s-tikhomirov)
</simpara>
</listitem>
<listitem>
<simpara>
Severin Alexander Bühler (@SeverinAlexB)
</simpara>
</listitem>
<listitem>
<simpara>
Simone Bovi (@SimoneBovi)
</simpara>
</listitem>
<listitem>
<simpara>
Srijan Bhushan (@srijanb)
</simpara>
</listitem>
<listitem>
<simpara>
Taylor Masterson (@tjmasterson)
</simpara>
</listitem>
<listitem>
<simpara>
Umar Bolatov (@bolatovumar)
</simpara>
</listitem>
<listitem>
<simpara>
Warren Wan (@wlwanpan)
</simpara>
</listitem>
<listitem>
<simpara>
Yibin Zhang (@z4y1b2)
</simpara>
</listitem>
<listitem>
<simpara>
Zachary Haddenham (@senf42)
</simpara>
</listitem>
</itemizedlist>
<simpara>Without the help offered by everyone listed here, this book would not have been possible. Your contributions demonstrate the power of open source and open culture, and we are eternally grateful for your help.</simpara>
<simpara>Thank you.</simpara>
</section>
<section id="_sources">
<title>Sources</title>
<simpara>Some of the material in this book has been sourced from a variety of public domain sources, open license sources, or with permission. See <xref linkend="sources_licenses"/> for source, license, and attribution details.</simpara>
</section>
</preface>
<glossary id="glossary">
<title>Glossary</title>
<simpara>This quick glossary contains many of the terms used in relation to Bitcoin and the Lightning Network. These terms are used throughout the book, so bookmark this for a quick reference.</simpara>
<variablelist>
<varlistentry>
<term>
address
</term>
<listitem>
<simpara>
    Bitcoin addresses compactly encode the information necessary to pay a receiver. A modern address consists of a string of letters and numbers that starts with bc1 and looks like <literal>bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4</literal>. An address is shorthand for a receiver&#8217;s locking script, which can be used by a sender to sign over funds to the receiver. Most addresses either represent the receiver&#8217;s public key or some form of script that defines more complex spending conditions. The preceding example is a bech32 address encoding a witness program locking funds to the hash of a public key (See <emphasis>Pay-to-Witness-Public-Key-Hash</emphasis>). There are also older address formats that start with 1 or 3 that use the Base58Check address encoding to represent public key hashes or script hashes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
asymmetric cryptographic system
</term>
<listitem>
<simpara>
    Asymmetric cryptography, or public-key cryptography, is a cryptographic system that uses pairs of keys: public keys which may be disseminated widely, and private keys which are known only to the owner.
    The generation of such keys depends on cryptographic algorithms based on mathematical problems to produce functions that are easy to solve one way, but very difficult to solve in reverse.
    Effective security only requires keeping the private key private; the public key can be openly distributed without compromising security.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
autopilot
</term>
<listitem>
<simpara>
    An autopilot is a recommendation engine for Lightning nodes that uses statistics of the Lightning Network topology to suggest which nodes they should open channels with.
    Depending on the implementation of the autopilot, the channel capacity may also be recommended.
    An autopilot is not part of the LN Protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
balance
</term>
<listitem>
<simpara>
    The balance of a payment channel is the amount of bitcoin that belongs to each channel partner.
    For example, Alice could open a channel with Bob for the value of 1 BTC.
    The channel balance is then 1 BTC to Alice and 0 BTC to Bob.
    As the users transact, the channel balance will update.
    For example, if Alice sends 0.2 BTC to Bob, then the balance is now 0.8 BTC to Alice and 0.2 to Bob.
    When the channel is closed, the bitcoin in the channel will be divided between the two channel partners according to the latest balance encoded in the commitment transaction.
    In the Lightning Network, the ability to send and receive payments is limited by channel balances.
    See <emphasis>capacity</emphasis>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bech32
</term>
<listitem>
<simpara>
    bech32 refers to a generic check-summed base32-encoded format featuring strong error-detection guarantees. While bech32 was originally developed to be used as the address format for native SegWit outputs (BIP-173), it is also used to encode lightning invoices (BOLT #11). While native SegWit version 0 outputs (P2WPKH and P2WSH) use bech32, higher native SegWit output versions (e.g., Pay-to-Taproot or P2TR) use the improved variant bech32m (BIP-350). bech32m addresses are sometimes referred to as "bc1" addresses,  reflecting the prefix of such addresses. Native SegWit outputs are more blockspace-efficient than older addresses and therefore may reduce transaction fees for the owner of such an address.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Bitcoin Improvement Proposal (BIP)
</term>
<listitem>
<simpara>
    A proposal that members of the Bitcoin community have submitted to improve Bitcoin. For example, BIP-21 is a proposal to improve the Bitcoin uniform resource identifier (URI) scheme. BIPs can be found at <ulink url="https://github.com/bitcoin/bips">GitHub</ulink>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bitcoin, Bitcoin
</term>
<listitem>
<simpara>
    Depending on the context, could refer to the name of the currency unit (the coin), the network, or the underlying enabling protocol. Written as bitcoin with a lowercase "b" usually refers to the currency unit. Bitcoin with an uppercase "B" usually refers to the protocol or system.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Bitcoin mining
</term>
<listitem>
<simpara>
    Bitcoin mining is the process of constructing a block from recent Bitcoin transactions and then solving a computational problem required as proof of work.
    It is the process by which the shared bitcoin ledger (i.e., the Bitcoin blockchain) is updated and by which new transactions are included in the ledger.
    It is also the process by which new bitcoin is issued.
    Every time a new block is created, the mining node will receive new bitcoin created within the coinbase transaction of that block.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
block
</term>
<listitem>
<simpara>
    A block is a data structure in the Bitcoin blockchain that consists of a header and a body of Bitcoin transactions.
    The block is marked with a timestamp and commits to a specific predecessor (parent) block.
    When hashed, the block header provides the proof of work that makes the blockchain probabilistically immutable.
    Blocks must adhere to the rules enforced by network consensus to extend the blockchain.
    When a block is appended to the blockchain, the included transactions are considered to have their first confirmation.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
blockchain
</term>
<listitem>
<simpara>
    The blockchain is a distributed log, or database, of all Bitcoin transactions.
    Transactions are grouped in discrete updates called blocks, limited up to 4 million weight units.
    Blocks are produced approximately every 10 minutes via a stochastic process called mining.
    Each block includes a computationally intensive "proof of work."
    The proof of work requirement is used to regulate the block intervals and protect the blockchain against attacks to rewrite history:
    an attacker would need to outdo existing proof of work to replace already published blocks, making each block probabilistically immutable as it is buried under subsequent blocks.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
BOLT
</term>
<listitem>
<simpara>
    BOLT, or Basis of Lightning Technology, is the formal specification of the Lightning Network. Unlike Bitcoin, which has a reference implementation that also serves as the protocol&#8217;s specification, the various LN implementations follow BOLT so they can work with one another to form the same network. It is available at <ulink url="https://github.com/lightningnetwork/lightning-rfc">GitHub</ulink>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
capacity
</term>
<listitem>
<simpara>
    The capacity of a payment channel is equivalent to the amount of bitcoin provided by the funding transaction.
    Because the funding transaction is publicly visible on the blockchain, and the channel is announced via the gossip protocol, the capacity is public information.
    It does not reveal any information about how much bitcoin each of the channel partners owns in the channel, i.e., the balance.
    A high capacity does not guarantee that the channel can be used for routing in both <span class="keep-together">directions</span>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
c-lightning
</term>
<listitem>
<simpara>
    Implementation of the LN Protocol by the Victoria-based company <ulink url="https://blockstream.com">Blockstream</ulink>. It is written in C. Source code is at <ulink url="https://github.com/ElementsProject/lightning">GitHub</ulink>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
closing transaction
</term>
<listitem>
<simpara>
    If both channel partners agree to close a channel, they will create a settlement transaction that reflects the most recent commitment transaction.
    After exchanging signatures for a closing transaction, no further channel updates should be made.
    Mutually closing a channel with the help of a closing transaction has the advantage that fewer blockchain transactions are required to claim all funds, in comparison to unilaterally forcing a channel close by publishing a commitment transaction. Additionally, funds for both parties are immediately spendable from a closing transaction.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
CLTV
</term>
<listitem>
<simpara>
    CLTV is an acronym/abbreviation for the Bitcoin Script operator OP_CHECKLOCKTIMEVERIFY. This defines an absolute blockheight before an output can be spent. The atomicity of the routing process heavily depends on CLTV values in HTLCs. Routing nodes announce, via the gossip protocol, their expected CLTV expiry deltas that they wish for any incoming and outgoing HTLCs.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
coinbase
</term>
<listitem>
<simpara>
    The coinbase is a special field only permitted in the sole input of coinbase transactions.
    The coinbase allows up 100 bytes of arbitrary data, but since BIP-34, it must first feature the current block height to ensure that coinbase transactions are unique.
    Not to be confused with coinbase transaction.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
coinbase transaction
</term>
<listitem>
<simpara>
    The first transaction in a block which is always created by a miner and which includes a single coinbase.
    The coinbase transaction may claim the block reward and assign it to one or more outputs.
    The block reward consists of the block subsidy (newly created bitcoin) and the sum of all transaction fees from transactions included in the block.
    Coinbase outputs can only be spent after maturing for 100 blocks.
    If the block includes any SegWit transactions, the coinbase transaction must include a commitment to the witness transaction identifiers in an additional output.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
cold storage
</term>
<listitem>
<simpara>
    Refers to keeping an amount of bitcoin offline. Cold storage is achieved when Bitcoin private keys are created and stored in a secure offline environment. Cold storage is important to protect bitcoin holdings. Online computers are vulnerable to hackers and should not be used to store a significant amount of bitcoin.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
commitment transaction
</term>
<listitem>
<simpara>
     A commitment transaction is a Bitcoin transaction, signed by both channel partners, that encodes the latest balance of a channel.
     Every time a new payment is made or forwarded using the channel, the channel balance will update, and a new commitment transaction will be signed by both parties.
     Importantly, in a channel between Alice and Bob, both Alice and Bob keep their own version of the commitment transaction, which is also signed by the other party.
     At any point, the <span class="keep-together">channel</span> can be closed by either Alice or Bob if they submit their commitment transaction to the Bitcoin blockchain.
     Submitting an older (outdated) commitment transaction is considered <emphasis>cheating</emphasis> (i.e., a protocol breach) in the Lightning Network and can be penalized by the other party, claiming all the funds in the channel for themselves, via a penalty transaction.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
confirmations
</term>
<listitem>
<simpara>
    Once a transaction is included in a block, it has one confirmation. As soon as <emphasis>another</emphasis> block is mined on the blockchain, the transaction has two confirmations, and so on. Six or more confirmations are considered sufficient proof that a transaction cannot be reversed.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
contract
</term>
<listitem>
<simpara>
    A contract is a set of Bitcoin transactions that together result in a certain desired behavior.
    Examples are RSMCs to create a trustless, bidirectional payment channel, or HTLCs to create a mechanism that allows trustless forwarding of payments through third parties.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Diffie–Hellman Key Exchange (DHKE)
</term>
<listitem>
<simpara>
    On the Lightning Network, the Elliptic Curve Diffie–Hellman (ECDH) method is used.
    It is an anonymous key agreement protocol that allows two parties, each having an elliptic curve public-private key pair, to establish a shared secret over an insecure communication channel.
    This shared secret may be directly used as a key, or to derive another key.
    The key, or the derived key, can then be used to encrypt subsequent communications using a symmetric-key cipher.
    An example of the derived key would be the shared secret between the ephemeral session key of a sender of an onion with the node&#8217;s public key of a hop of the onion, as described and used by the SPHINX Mix Format.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
digital signature
</term>
<listitem>
<simpara>
    A digital signature is a mathematical scheme for verifying the authenticity and integrity of digital messages or documents.
    It can be seen as a cryptographic commitment in which the message is not hidden.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
double-spending
</term>
<listitem>
<simpara>
    Double-spending is the result of successfully spending some money more than once.
    Bitcoin protects against double-spending by verifying that each transaction added to the blockchain adheres to the rules of consensus; this means checking that the inputs for the transaction have not been previously spent.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Elliptic Curve Digital Signature Algorithm (ECDSA)
</term>
<listitem>
<simpara>
    Elliptic Curve Digital Signature Algorithm or ECDSA is a cryptographic algorithm used by Bitcoin to ensure that funds can only be spent by the holder of the correct private key.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Eclair
</term>
<listitem>
<simpara>
    Implementation of the LN Protocol by the Paris-based company <ulink url="https://acinq.co">ACINQ</ulink>. It is written in Scala. Source code is at <ulink url="https://github.com/ACINQ/eclair">GitHub</ulink>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
encoding
</term>
<listitem>
<simpara>
    Encoding is the process of converting a message into a different form. For example, converting a number from decimal to a hexadecimal.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Electrum server
</term>
<listitem>
<simpara>
    An Electrum server is a Bitcoin node with an additional interface (API). It is often required by bitcoin wallets that do not run a full node. For example, these wallets check the status of specific transactions or broadcast transactions to the mempool using Electrum server APIs. Some Lightning wallets also use Electrum servers.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
ephemeral key
</term>
<listitem>
<simpara>
    Ephemeral keys are keys that are only used for a short time and not retained after use. They are often derived for use in one session from another key that is held long-term. Ephemeral keys are mainly used within the SPHINX Mix Format and onion routing on the Lightning Network.
    This increases the security of transported messages or payments.
    Even if an ephemeral key leaks, only information about a single session becomes public.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
feature bits
</term>
<listitem>
<simpara>
    A binary string that Lightning nodes use to communicate to each other which features they support.
    Feature bits are included in many Lightning messages as well as BOLT #11.
    They can be decoded using BOLT #9, and will tell nodes which features the node has enabled, and whether these are backward compatible.
    Also known as feature flags.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
fees
</term>
<listitem>
<simpara>
    In the context of the Lightning Network, nodes will charge routing fees for forwarding other users' payments.
    Individual nodes can set their own fee policies which will be calculated as the sum of a fixed <literal>base_fee</literal> and a <literal>fee_rate</literal> that depends on the payment amount.
    In the context of Bitcoin, the sender of a transaction pays a transaction fee to miners for including the transaction in a block.
    Bitcoin transaction fees do not include a base fee and depend linearly on the weight of the transaction, but not on the amount.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
funding transaction
</term>
<listitem>
<simpara>
    The funding transaction is used to open a payment channel. The value (in bitcoin) of the funding transaction is exactly the capacity of the payment channel.
    The output of the funding transaction is a 2-of-2 multisignature script (multisig) where each channel partner controls one key. Due to its multisig nature, it can only be spent by mutual agreement between the channel partners.
    It will eventually be spent by one of the commitment transactions or by the closing transaction.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
global features (<literal>globalfeatures</literal> field)
</term>
<listitem>
<simpara>
    Global features of a Lightning node are the features of interest for all other nodes.
    Most commonly they are related to supported routing formats.
    They are announced in the <literal>init</literal> message of the peer protocol as well as the <literal>channel_announcement</literal> and <literal>node_announcement</literal> messages of the gossip protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
gossip protocol
</term>
<listitem>
<simpara>
    LN nodes send and receive information about the topology of the Lightning Network through gossip messages which are exchanged with their peers.
    The gossip protocol is mainly defined in BOLT #7 and defines the format of the <literal>node_announcement</literal>, <literal>channel_announcement</literal>, and <literal>channel_update</literal> messages.
    To prevent spam, node announcement messages will only be forwarded if the node already has a channel, and channel announcement messages will only be forwarded if the funding transaction of the channel has been confirmed by the Bitcoin network.
    Usually, Lightning nodes connect with their channel partners, but it is fine to connect with any other Lightning node to process gossip messages.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
hardware wallet
</term>
<listitem>
<simpara>
    A hardware wallet is a special type of Bitcoin wallet which stores the user&#8217;s private keys in a secure hardware device.
    As of writing the book, hardware wallets are not available for LN nodes because the keys used by Lightning need to be online to participate in the protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
hash
</term>
<listitem>
<simpara>
    A fixed-size digital fingerprint of some arbitrary-length binary input. Also known as a <emphasis>digest</emphasis>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
hash-based message authentication code (HMAC)
</term>
<listitem>
<simpara>
    HMAC is an algorithm for verifying the integrity and authenticity of a message based on a hash function and a cryptographic key.
    It is used in onion routing to ensure the integrity of a packet at each hop, as well as within the Noise Protocol variant used for message encryption.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
hash function
</term>
<listitem>
<simpara>
    A cryptographic hash function is a mathematical algorithm that maps data of arbitrary size to a bit string of a fixed size (a hash) and is designed to be a one-way function, that is, a function that is infeasible to invert.
    The only way to recreate the input data from an ideal cryptographic hash function&#8217;s output is to attempt a brute-force search of possible inputs to see if they produce a match.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
hashlock
</term>
<listitem>
<simpara>
    A hashlock is a Bitcoin Script spending condition that restricts the spending of an output until a specified piece of data is revealed. Hashlocks have the useful property that once any hashlock is revealed through spending, any other hashlocks secured using the same key can also be spent. This makes it possible to create multiple outputs that are all encumbered by the same hashlock and which all become spendable at the same time.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
hash time-locked contract (HTLC)
</term>
<listitem>
<simpara>
    A hash time-locked contract (HTLC) is a Bitcoin Script that consists of hashlocks and timelocks to require that the recipient of a payment either spends the payment prior to a deadline by presenting the hash preimage or the sender can claim a refund after the timelock expires.
    On the Lightning Network, HTLCs are outputs in the commitment transaction of a payment channel and are used to enable the trustless routing of payments.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
invoice
</term>
<listitem>
<simpara>
    The payment process on the Lightning Network is initiated by the recipient (payee) who issues an invoice, also known as a <emphasis>payment request</emphasis>.
    Invoices include the payment hash, the amount, a description, and the expiry time. Lightning invoices are defined in BOLT #11.
    Invoices can also include a fallback Bitcoin address to which the payment can be made in case no route can be found, as well as hints for routing a payment through a private channel.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
just-in-time (JIT) routing
</term>
<listitem>
<simpara>
   Just-in-time (JIT) routing is an alternative to source-based routing that was first <span class="keep-together">proposed</span> by coauthor René Pickhardt.
   With JIT routing, intermediary nodes along a path can pause an in-flight payment to rebalance their channels before proceeding with the payment.
   This might allow them to successfully forward payments that might otherwise have failed due to a lack of outgoing capacity.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Lightning message
</term>
<listitem>
<simpara>
   A Lightning message is an encrypted data string that can be sent between two peers on the Lightning Network. Similar to other communication protocols, Lightning messages consist of a header and a body. The header and the body have their own HMAC. Lightning messages are the main building block of the messaging layer.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Lightning Network, Lightning Network Protocol, <span class="keep-together">Lightning Protocol</span>
</term>
<listitem>
<simpara>
   The Lightning Network is a protocol on top of Bitcoin (or other cryptocurrencies).
   It creates a network of payment channels which enables the trustless forwarding of payments through the network with the help of HTLCs and onion routing.
   Other components of the Lightning Network are the gossip protocol, the transport layer, and payment requests.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Lightning Network protocol suite
</term>
<listitem>
<simpara>
   The Lightning Network protocol suite consists of five layers that are responsible for various parts of the protocol.
   From bottom (the first layer) to the top (the fifth layer), these layers are called the network communication layer, the messaging layer, the peer-to-peer layer, the routing layer, and the payment layer.
   Various BOLTs define parts of one or several layers.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Lightning Network node, Lightning node
</term>
<listitem>
<simpara>
    A computer participating in the Lightning Network, via the Lightning peer-to-peer protocol.
    Lightning nodes have the ability to open channels with other nodes, send and receive payments, and route payments from other users.
    Typically, a Lightning node user will also run a Bitcoin node.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
lnd
</term>
<listitem>
<simpara>
    Implementation of the LN Protocol by the San Francisco-based company <ulink url="https://lightning.engineering">Lightning Labs</ulink>.
    It is written in Go. Source code is at <ulink url="https://github.com/lightningnetwork/lnd">GitHub</ulink>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
local features (field: <literal>localfeatures</literal>)
</term>
<listitem>
<simpara>
    Local features of an LN node are the configurable features of direct interest to its peers.
    They are announced in the <literal>init</literal> message of the peer protocol as well as in the <literal>channel_announcement</literal> and <literal>node_announcement</literal> messages of the gossip protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
locktime
</term>
<listitem>
<simpara>
    Locktime, or more technically nLockTime, is the part of a Bitcoin transaction that indicates the earliest time or earliest block when that transaction may be added to the blockchain.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
messaging layer
</term>
<listitem>
<simpara>
    The messaging layer builds on top of the network connection layer of the Lightning Network protocol suite.
    It is responsible for ensuring an encrypted and secure communication and exchange of information via the chosen network connection layer protocol.
    The messaging layer defines the framing and format of Lightning Messages as defined in BOLT #1.
    The feature bits defined in BOLT #9 are also part of this layer.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
millisatoshi
</term>
<listitem>
<simpara>
    The smallest unit of account on the Lightning Network. A millisatoshi is one hundred billionth of a single bitcoin. A millisatoshi is one thousandth of one satoshi. Millisatoshis do not exist on, nor can they be settled on, the Bitcoin network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
multipart payments (MPP)
</term>
<listitem>
<simpara>
        Multipart payments (MPP), often also referred to as multipath payments, are a method for splitting the payment amount into multiple smaller parts and delivering them along one or more paths. Since MPP can send many or all parts over a single path, the term multipart payment is more accurate than multipath payment. In computer science, multipart payments are modeled as network flows.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
multisignature
</term>
<listitem>
<simpara>
    Multisignature (multisig) refers to a script that requires more than one signature to authorize spending.
    Payment channels are always encoded as multisig addresses requiring one signature from each partner of the payment channel.
    In the standard case of a two-party payment channel, a 2-of-2 multisig address is used.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
node
</term>
<listitem>
<simpara>
    See <emphasis>Lightning Network node</emphasis>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
network capacity
</term>
<listitem>
<simpara>
    LN capacity is the total amount of bitcoin locked and circulated inside the Lightning Network.
    It is the sum of capacities of each public channel.
    It reflects the usage of the Lightning Network to some extent because we expect that people put bitcoin into Lightning channels to spend it or forward other users' payments.
    Hence the higher the amount of bitcoin in Lightning channels, the higher the expected usage of the Lightning Network.
    Note that since only public channel capacity can be observed, the true network capacity is unknown. Also, since a channel&#8217;s capacity can enable an unlimited number of payments back and forth, network capacity does not imply a limit of value transferred on the Lightning Network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
network connection layer
</term>
<listitem>
<simpara>
    The lowest layer of the Lightning Network protocol suite.
    Its responsibility is to support internet protocols like IPv4, IPv6, TOR2, and TOR3, and use them to establish a secure cryptographic communication channel as defined in BOLT #8, or to speak DNS for the bootstrapping of the network as defined in BOLT #10.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Noise_XK
</term>
<listitem>
<simpara>
    The template of the Noise Protocol Framework to establish an authenticated and encrypted communication channel between two peers of the Lightning Network.
    X means that no public key needs to be known from the initiator of the connection.
    K means that the public key of the receiver needs to be known.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
onion routing
</term>
<listitem>
<simpara>
    Onion routing is a technique for anonymous communication over a computer network.
    In an onion network, messages are encapsulated in layers of encryption, analogous to layers of an onion.
    The encrypted data is transmitted through a series of network nodes called onion routers, each of which peels away a single layer, uncovering the data&#8217;s next destination.
    When the final layer is decrypted, the message arrives at its destination.
    The sender remains anonymous because each intermediary knows only the location of the immediately preceding and following nodes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
output
</term>
<listitem>
<simpara>
    The output of a Bitcoin transaction, also called an unspent transaction output (UTXO).
    An output is an indivisible amount of bitcoin that can be spent, as well as a script that defines what conditions need to be fulfilled for that bitcoin to be spent.
    Every bitcoin transaction consumes some outputs of previously recorded transactions and creates new outputs that can be spent later by subsequent transactions.
    A typical bitcoin output will require a signature to be spent, but outputs can require the fulfillment of more complex scripts.
    For example, a multisignature script requires two or more key holders sign before the output can be spent, which is a fundamental building block of the Lightning Network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Pay-to-Public-Key-Hash (P2PKH)
</term>
<listitem>
<simpara>
    P2PKH is a type of output that locks bitcoin to the hash of a public key. An output locked by a P2PKH script can be unlocked (spent) by presenting the public key matching the hash and a digital signature created by the corresponding private key.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Pay-to-Script-Hash (P2SH)
</term>
<listitem>
<simpara>
    P2SH is a versatile type of output that  allows the use of complex Bitcoin Scripts. With P2SH, the complex script that details the conditions for spending the output (redeem script) is not presented in the locking script. Instead, value is locked to the hash of a script, which must be presented and fulfilled to spend the output.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
P2SH address
</term>
<listitem>
<simpara>
    P2SH addresses are Base58Check encodings of the 20-byte hash of a script. P2SH addresses start with a "3." P2SH addresses hide all of the complexity, so that the sender of a payment does not see the script.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Pay-to-Witness-Public-Key-Hash (P2WPKH)
</term>
<listitem>
<simpara>
        P2WPKH is the SegWit equivalent of P2PKH, using a segregated witness. The signature to spend a P2WPKH output is put in the witness tree instead of the ScriptSig field. See <emphasis>SegWit</emphasis>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
P2WPKH address
</term>
<listitem>
<simpara>
        The "native SegWit v0" address format, P2WPKH addresses are bech32-encoded and start with "bc1q".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Pay-to-Witness-Script-Hash (P2WSH)
</term>
<listitem>
<simpara>
    P2WSH is the SegWit equivalent of P2SH, using a segregated witness. The signature and script to spend a P2WSH output is put in the witness tree instead of the ScriptSig field. See <emphasis>SegWit</emphasis>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
P2WSH address
</term>
<listitem>
<simpara>
        The "native Segwi v0" script address format, P2WSH addresses are bech32-encoded and start with "bc1q".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Pay-to-Taproot (P2TR)
</term>
<listitem>
<simpara>
        Activating in November 2021, Taproot is a new output type that locks bitcoin to a tree of spending conditions, or a single root condition.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
P2TR address
</term>
<listitem>
<simpara>
        The Taproot address format, representing SegWit v1, is a bech32m-encoded address and starts with "bc1p".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
payment
</term>
<listitem>
<simpara>
    A Lightning payment occurs when bitcoin is transferred within the Lightning Network. Payments are generally not seen on the Bitcoin blockchain.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
payment channel
</term>
<listitem>
<simpara>
    A payment channel is a financial relationship between two nodes on the Lightning Network, created using a bitcoin transaction paying a multisignature address.
    The channel partners can use the channel to send bitcoin back and forth between each other without committing all of the transactions to the Bitcoin blockchain.
    In a typical payment channel only two transactions, the funding transaction and the commitment transaction, are added to the blockchain.
    Payments sent across the channel are not recorded in the blockchain and are said to occur "off-chain."
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
payment layer
</term>
<listitem>
<simpara>
    The top and fifth layer of the Lightning Network protocol suite operates on top of the routing layer.
    Its responsibility is to enable the payment process via BOLT #11 invoices.
    While it heavily uses the channel graph from the gossip protocol as defined in BOLT #7, the actual strategies to deliver a payment are not part of the specification of the protocol and are left to the implementations.
    As this topic is very important to ensure reliability of the payment delivery process, we included it in this book.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
peer
</term>
<listitem>
<simpara>
    The participants in a peer-to-peer network. In the Lightning Network, peers connect to each other via encrypted, authenticated communication through a TCP socket, over IP or Tor.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
peer-to-peer layer
</term>
<listitem>
<simpara>
    The peer-to-peer layer is the third layer of the Lightning Network protocol suite and works on top of the messaging layer.
    It is responsible for defining the syntax and semantics of information exchanged between peers via Lightning messages.
    This consists of control messages as defined in BOLT #9; channel establishment, operation, and closing messages as defined in BOLT #2; as well as gossip and routing messages as defined in BOLT #7.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
private channel
</term>
<listitem>
<simpara>
    A channel not announced to the rest of the network.
    Technically, "private" is a misnomer because these channels can still be identified through routing hints and commitment transactions.
    They are better described as "unannounced" channels.
        With an unannounced channel, the channel partners can send and receive payments between each other as normal.
    However, the rest of the network will not be aware of the channel and so cannot typically use it to route payments.
    Because the number and capacity of unannounced channels is unknown, the total public channel count and capacity only accounts for a portion of the total Lightning Network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
preimage
</term>
<listitem>
<simpara>
        In the context of cryptography and specifically in the Lightning Network, the preimage refers to the input of a hash function that produces a specific hash. It is not feasible to compute the preimage from the hash (hash functions only go one way). By selecting a secret random value as a preimage and calculating its hash, we can commit to that preimage and later reveal it. Anyone can confirm that the revealed preimage correctly produces the hash.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Proof of Work (PoW)
</term>
<listitem>
<simpara>
    Data that requires significant computation to find, and can be easily verified by anyone to prove the amount of work that was required to produce it.
    In Bitcoin, miners must find a numeric solution to the SHA-256 algorithm that meets a network-wide target, called the difficulty target.
    See <emphasis>Bitcoin mining</emphasis> for more information.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Point Time-Locked Contract (PTLC)
</term>
<listitem>
<simpara>
    A Point Time-Locked Contract (PTLC) is a Bitcoin script that allows a conditional spend either on the presentation of a secret or after a certain blockheight has passed, similar to an HTLC. Unlike HTLCs, PTLCs do not depend on a preimage of a hash function but rather on the private key from an elliptic curve point. The security assumption is thus based on the discrete logarithm. PTLCs are not yet implemented on the Lightning Network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
relative timelock
</term>
<listitem>
<simpara>
    A relative timelock is a type of timelock that allows an input to specify the earliest time the input can be added to a block. The time is relative and is based on when the output referenced by that input was recorded in a block. Relative timelocks are set by the <literal>nSequence</literal> transaction field and <literal>CHECKSEQUENCEVERIFY</literal> (CSV) Bitcoin Script opcode, which was introduced by BIP-68/112/113.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Revocable Sequence Maturity Contract (RSMC)
</term>
<listitem>
<simpara>
    This contract is used to construct a payment channel between two Bitcoin or LN users who do not need to trust each other.
    The name comes from a sequence of states that are encoded as commitment transactions and can be revoked if wrongfully published and mined by the Bitcoin network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
revocation key
</term>
<listitem>
<simpara>
    Every RSMC contains two revocation keys. Each channel partner knows one revocation key. Knowing both revocation keys, the output of the RSMC can be spent within the predefined timelock.  While negotiating a new channel state, the old revocation keys are shared, thereby "revoking" the old state.  Revocation keys are used to discourage channel partners from broadcasting an old channel state.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
RIPEMD-160
</term>
<listitem>
<simpara>
    RIPEMD-160 is a cryptographic hash function that produces a 160-bit (20-byte) hash.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
routing layer
</term>
<listitem>
<simpara>
    The fourth layer of the Lightning Network protocol suite operates on top of the peer-to-peer layer.
    Its responsibility is to define the cryptographic primitives and necessary communication protocol to allow the secure and atomic transport of bitcoin from a sending node to a recipient node.
    While BOLT #4 defines the onion format that is used to communicate transport information to remote peers with whom no direct connections exist, the actual transport of the onions and cryptographic primitives are defined in BOLT #2.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
topology
</term>
<listitem>
<simpara>
    The topology of the Lightning Network describes the shape of the Lightning Network as a mathematical graph. Nodes of the graph are the Lightning nodes (network participants/peers). The edges of the graph are the payment channels.
    The topology of the Lightning Network is publicly broadcast with the help of the gossip protocol, with the exception of unannounced channels.
    This means that the Lightning Network may be significantly larger than the announced number of channels and nodes.
    Knowing the topology is of particular interest in the source-based routing process of payments in which the sender discovers a route.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
satoshi
</term>
<listitem>
<simpara>
    A satoshi is the smallest unit (denomination) of bitcoin that can be recorded on the blockchain. One satoshi is 1/100 millionth (0.00000001) of a bitcoin and is named after the creator of Bitcoin, Satoshi Nakamoto.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Satoshi Nakamoto
</term>
<listitem>
<simpara>
    Satoshi Nakamoto is the name used by the person or group of people who designed Bitcoin and created its original reference implementation. As part of the implementation, they also devised the first blockchain database. In the process, they were the first to solve the double-spending problem for digital currency. Their real identity remains unknown.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Schnorr signature
</term>
<listitem>
<simpara>
    A new digital signature scheme that will be activated in Bitcoin in November 2021. It enables innovations on the Lightning Network, such as efficient PTLCs (an improvement on HTLCs).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
script, Bitcoin Script
</term>
<listitem>
<simpara>
    Bitcoin uses a scripting system for transactions called Bitcoin Script. Resembling the Forth programming language, it is simple, stack-based, and processed from left to right. It is purposefully Turing-incomplete, without loops or recursion.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
ScriptPubKey (aka pubkey script)
</term>
<listitem>
<simpara>
    ScriptPubKey or pubkey script, is a script included in outputs which sets the conditions that must be fulfilled for those outputs to be spent. Data for fulfilling the conditions can be provided in a signature script. See also <emphasis>ScriptSig</emphasis>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
ScriptSig (aka signature script)
</term>
<listitem>
<simpara>
    ScriptSig or signature script is the data generated by a spender, which are almost always used as variables to satisfy a pubkey script.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
secret key (aka private key)
</term>
<listitem>
<simpara>
    The secret number that unlocks bitcoin sent to the corresponding address. <span class="keep-together">A secret</span> key looks like this: <literal>5J76sF8L5j&#x200b;TtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3i&#x200b;bVPxh</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Segregated Witness (SegWit)
</term>
<listitem>
<simpara>
    Segregated Witness (SegWit) is an upgrade to the Bitcoin protocol introduced in 2017 that adds a new witness for signatures and other transaction authorization proofs. This new witness field is exempt from the calculation of the transaction ID, which solves most classes of third-party transaction malleability. Segregated Witness was deployed as a soft fork and is a change that technically makes Bitcoin’s protocol rules more restrictive.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Secure Hash Algorithm (SHA)
</term>
<listitem>
<simpara>
    The Secure Hash Algorithm or SHA is a family of cryptographic hash functions published by the National Institute of Standards and Technology (NIST). The Bitcoin protocol currently uses SHA-256, which produces a 256-bit hash.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
short channel ID (scid)
</term>
<listitem>
<simpara>
    Once a channel is established, the index of the funding transaction on the blockchain is used as the short channel ID to uniquely identify the channel.
    The short channel ID consists of eight bytes referring to three numbers.
    In its serialized form, it depicts these three numbers as decimal values separated by the letter "x" (e.g., <literal>600123x01x00</literal>)
    The first number (4 bytes) is the block height.
    The second number (2 bytes) is the index of the funding transaction with the blocks.
    The last number (2 bytes) is the transaction output.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
simplified payment verification (SPV)
</term>
<listitem>
<simpara>
    SPV or simplified payment verification is a method for verifying that particular transactions were included in a block without downloading the entire block. The method is used by some lightweight Bitcoin and Lightning wallets.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
source-based routing
</term>
<listitem>
<simpara>
    On the Lightning Network, the sender of a payment decides the route of the payment.
    While this decreases the success rate of the routing process, it increases the privacy of payments.
    Due to the SPHINX Mix Format used by onion routing, all routing nodes do not know the originator of a payment or the final recipient.
    Source-based routing is fundamentally different from how routing works on the Internet Protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
soft fork
</term>
<listitem>
<simpara>
    Soft fork, or soft-forking change, is a protocol upgrade that&#8217;s forward and backward compatible, so it allows both old nodes and new nodes to continue using the same chain.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
SPHINX Mix Format
</term>
<listitem>
<simpara>
    A particular technique for onion routing used in the Lightning Network and invented by <ulink url="https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf">George Danezis and Ian Goldberg in 2009</ulink>.
    With the SPHINX Mix Format, each message of the onion package is padded with some random data so that no single hop can estimate how far along the route it has traveled.
    While the privacy of the sender and receiver of the payment is protected, each node is still able to return an error message along the path to the originator of the message.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
submarine swap
</term>
<listitem>
<simpara>
    A submarine swap is a trustless atomic swap between on-chain Bitcoin addresses and off-chain Lightning Network payments. Just as LN payments use HTLCs that make the final claim on funds conditional on the recipient revealing a secret (hash preimage), submarine swaps use the same mechanism to transfer funds across the on-chain/off-chain barrier with minimal trust. Reverse submarine swaps allow swaps in the opposite direction, from an off-chain LN payment to an on-chain Bitcoin address.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
timelock
</term>
<listitem>
<simpara>
    A timelock is a type of encumbrance that restricts the spending of some bitcoin until a specified future time or block height. Timelocks feature prominently in many Bitcoin contracts, including payment channels and HTLCs.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
transaction
</term>
<listitem>
<simpara>
    Transactions are data structures used by Bitcoin to transfer bitcoin from one address to another.
    Several thousand transactions are aggregated in a block, which is then recorded (mined) on the blockchain.
    The first transaction in each block, called the coinbase transaction, generates new bitcoin.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
transaction malleability
</term>
<listitem>
<simpara>
    Transaction malleability is a property that the hash of a transaction can change without changing the semantics of the transaction.
    For example, altering the signature can change the hash of a transaction.
    A commitment transaction needs the hash of a funding transaction, and if the hash of the funding transaction changes, transactions depending on it will become invalid. This will make users unable to claim the refunds if there are any.
    The Segregated Witness soft fork addresses this issue and was therefore an important upgrade to support the Lightning Network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
transport layer
</term>
<listitem>
<simpara>
    In computer networking, the transport layer is a conceptual division of the methods used by computers (and ultimately applications) to talk to each other.
    The transport layer provides communication services between computers, such as flow control, verification, and multiplexing (to allow multiple applications to work on a computer at the same time).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
unspent transaction output (UTXO)
</term>
<listitem>
<simpara>
    See <emphasis>output</emphasis>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
wallet
</term>
<listitem>
<simpara>
    A wallet is a piece of software that holds Bitcoin private keys. It is used to create and sign Bitcoin transactions. In the context of the Lightning Network, it also holds revocation secrets of old channel state and the latest presigned commitment transactions.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
watchtower
</term>
<listitem>
<simpara>
    Watchtowers are a security service on the Lightning Network that monitor payment channels for potential protocol breaches.
    If one of the channel partners goes offline or loses their backup, a watchtower keeps backups and can restore their channel information.
</simpara>
<simpara>Watchtowers also monitor the Bitcoin blockchain and can submit a penalty transaction if one of the partners tries to "cheat" by broadcasting an outdated state. Watchtowers can be run by the channel partners themselves, or as a paid service offered by a third party. Watchtowers have no control over the funds in the channels themselves.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Some contributed definitions have been sourced under a CC-BY license from the <ulink url="https://en.bitcoin.it/wiki/Main_Page">Bitcoin Wiki</ulink>, <ulink url="https://en.wikipedia.org">Wikipedia</ulink>, <ulink url="https://github.com/bitcoinbook/bitcoinbook"><emphasis>Mastering Bitcoin</emphasis></ulink>, or from other open source publications.</simpara>
</glossary>
<chapter id="intro_what_is_the_lightning_network" role="pagenumrestart">
<title>Introduction</title>
<simpara>Welcome to <emphasis>Mastering the Lightning Network</emphasis>!</simpara>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary>
</indexterm>The Lightning Network (often abbreviated as LN), is changing the way people exchange value online, and it&#8217;s one of the most exciting advancements to happen in Bitcoin&#8217;s history.
Today, in 2021, the Lightning Network is still in its infancy. The Lightning Network is a protocol for using Bitcoin in a smart and nonobvious way. It is a second layer technology on top of Bitcoin.</simpara>
<simpara>The concept of the Lightning Network was proposed in 2015, and the first implementation was launched in 2018. As of 2021, we&#8217;re only beginning to see the opportunities the Lightning Network provides to Bitcoin, including improved privacy, speed, and scale.
With core knowledge of the Lightning Network, you can help shape the future of the network while also building opportunities for yourself.</simpara>
<simpara>We assume you already have some basic knowledge about Bitcoin, but if not, don&#8217;t worry—we will explain the most important Bitcoin concepts, those you must know to understand the Lightning Network, in <xref linkend="bitcoin_fundamentals_review"/>. If you want to learn more about Bitcoin, you can read <emphasis>Mastering Bitcoin</emphasis>, 2nd edition, by Andreas M. Antonopoulos (O&#8217;Reilly), available <ulink url="https://github.com/bitcoinbook/bitcoinbook">for free online</ulink>.</simpara>
<simpara>While the bulk of this book is written for programmers, the first few chapters are written to be approachable by anyone regardless of technical experience. In this chapter, we&#8217;ll start with some terminology, then move to look at trust and its application in these systems, and finally we&#8217;ll discuss the history and future of the Lightning Network. Let&#8217;s get started.</simpara>
<section id="_lightning_network_basic_concepts">
<title>Lightning Network Basic Concepts</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>basic concepts</secondary>
</indexterm>
<indexterm>
  <primary>basic concepts</primary>
</indexterm>As we explore how the Lightning Network actually works, we will encounter some technical terminology that might, at first, be a bit confusing. While all of these concepts and terms will be explained in detail as we progress through the book and are defined in the glossary, some basic definitions now will make it easier to understand the concepts in the next two chapters. If you don&#8217;t understand all of the words in these definitions yet, that&#8217;s OK. You&#8217;ll understand more as you move through the text.</simpara>
<variablelist>
<varlistentry>
<term>
Blockchain
</term>
<listitem>
<simpara>
<indexterm>
  <primary>blockchain</primary><secondary>defined</secondary>
</indexterm>
<indexterm>
  <primary>defined</primary>
</indexterm>A distributed transaction ledger, produced by a network of computers. Bitcoin, for example, is a system that produces a blockchain. The Lightning Network is not itself a blockchain, nor does it produce a blockchain. It is a network that relies on an existing external blockchain for its security.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Digital signature
</term>
<listitem>
<simpara>
<indexterm>
  <primary>digital signatures</primary>
</indexterm>A digital signature is a mathematical scheme for verifying the authenticity of digital messages or documents. A valid digital signature gives a recipient reason to believe that the message was created by a known sender, that the sender cannot deny having sent the message, and that the message was not altered in transit.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Hash function
</term>
<listitem>
<simpara>
<indexterm>
  <primary>hash function, defined</primary>
</indexterm>A cryptographic hash function is a mathematical algorithm that maps data of arbitrary size to a bit string of a fixed size (a hash) and is designed to be a one-way function, that is, a function which is infeasible to invert.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Node
</term>
<listitem>
<simpara>
<indexterm>
  <primary>node, defined</primary>
</indexterm>A computer that participates in a network. A Lightning node is a computer that participates in the Lightning Network. A Bitcoin node is a computer that participates in the Bitcoin network. Typically an LN user will run a Lightning node <emphasis>and</emphasis> a Bitcoin node.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
On-chain versus off-chain
</term>
<listitem>
<simpara>
<indexterm>
  <primary>on-chain payment</primary><secondary>defined</secondary>
</indexterm>
<indexterm>
  <primary>defined</primary>
</indexterm>A payment is <emphasis>on-chain</emphasis> if it is recorded as a transaction on the Bitcoin (or other underlying) blockchain. <indexterm>
  <primary>off-chain payment</primary>
</indexterm>Payments sent via payment channels between Lightning nodes, and which are not visible in the underlying blockchain, are called <emphasis>off-chain</emphasis> payments. Usually in the Lightning Network, the only on-chain transactions are those used to open and close a Lightning payment channel. A third type of channel modifying transaction exists, called splicing, which can be used to add/remove the amount of funds committed in a channel.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Payment
</term>
<listitem>
<simpara>
<indexterm>
  <primary>payment</primary><secondary>defined</secondary>
</indexterm>
<indexterm>
  <primary>defined</primary>
</indexterm>When value is exchanged on the Lightning Network, we call this a "payment" as compared to a "transaction" on the Bitcoin blockchain.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Payment channel
</term>
<listitem>
<simpara>
<indexterm>
  <primary>payment channel</primary>
</indexterm>A <emphasis>financial relationship</emphasis> between two nodes on the Lightning Network, typically implemented by multisignature Bitcoin transactions that share control over bitcoin between the two Lightning nodes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Routing versus sending
</term>
<listitem>
<simpara>
<indexterm>
  <primary>routing</primary><secondary>sending versus</secondary>
</indexterm>
<indexterm>
  <primary>sending versus</primary>
</indexterm><indexterm>
  <primary>sending, routing versus</primary>
</indexterm>Unlike Bitcoin where transactions are "sent" by broadcasting them to everyone, Lightning is a routed network where payments are "routed" across one or more payment channels following a <emphasis>path</emphasis> from sender to recipient.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Transaction
</term>
<listitem>
<simpara>
<indexterm>
  <primary>transaction, defined</primary>
</indexterm>A data structure that records the transfer of control over some funds (e.g., some bitcoin). The Lightning Network relies on Bitcoin transactions (or those of another blockchain) to track control of funds.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>More detailed definitions of these and many other terms can be found in the <xref linkend="glossary"/>. Throughout this book, we will explain what these concepts mean and how these technologies actually work.</simpara>
<tip>
<simpara>Throughout this book, you will see "Bitcoin" with the first letter capitalized, which refers to the <emphasis>Bitcoin system</emphasis> and is a proper noun. You will also see "bitcoin," with a lowercase <emphasis>b</emphasis>, which refers to the currency unit. Each bitcoin is further subdivided into 100 million units each called a "satoshi" (singular) or "satoshis" (plural).<indexterm>
</indexterm></simpara>
</tip>
<simpara>Now that you&#8217;re familiar with these basic terms, let&#8217;s move to a concept you are already comfortable with: trust.</simpara>
</section>
<section id="_trust_in_decentralized_networks">
<title>Trust in Decentralized Networks</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>trust in decentralized networks</secondary>
</indexterm>
<indexterm>
  <primary>trust in decentralized networks</primary>
</indexterm><indexterm>
  <primary>trustless systems</primary><secondary>trust in decentralized networks</secondary>
</indexterm>
<indexterm>
  <primary>trust in decentralized networks</primary>
</indexterm>You will often hear people calling Bitcoin and the Lightning Network "trustless." At first glance this is confusing. After all, isn&#8217;t trust a good thing? Banks even use it in their names! Isn&#8217;t a "trustless" system, a system devoid of trust, a bad thing?</simpara>
<simpara>The use of the word "trustless" is intended to convey the ability to operate without <emphasis>needing</emphasis> trust in the other participants in the system. In a decentralized system like Bitcoin, you can always choose to transact with someone you trust. However, the system ensures you can&#8217;t be cheated even if you can&#8217;t trust the other party in a transaction. Trust is a nice-to-have instead of a must-have property of the system.</simpara>
<simpara>Contrast that to traditional systems like banking where you must place your trust in a third party, since it controls your money. If the bank violates your trust, you may be able to find some recourse from a regulator or court, but at an enormous cost of time, money, and effort.</simpara>
<simpara>Trustless does not mean devoid of trust. It means that trust is not a necessary prerequisite to all transactions and that you can transact even with people you don&#8217;t trust because the system prevents cheating.</simpara>
<simpara>Before we get into how the Lightning Network works, it&#8217;s important to understand one basic concept that underlies Bitcoin, the Lightning Network, and many other such systems: something we call a <emphasis>fairness protocol</emphasis>. A fairness protocol is a way to achieve fair outcomes between participants, who do not need to trust each other, without the need for a central authority, and it is the backbone of decentralized systems like Bitcoin.</simpara>
</section>
<section id="_fairness_without_central_authority">
<title>Fairness Without Central Authority</title>
<simpara><indexterm>
  <primary>fairness, ensuring</primary>
</indexterm><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>fairness without central authority</secondary>
</indexterm>
<indexterm>
  <primary>fairness without central authority</primary>
</indexterm>When people have competing interests, how can they establish enough trust to engage in some cooperative or transactional behavior? The answer to this question lies at the core of several scientific and humanistic disciplines, such as economics, sociology, behavioral psychology, and mathematics. Some of those disciplines give us "soft" answers that depend on concepts such as reputation, fairness, morality, and even religion. Other disciplines give us concrete answers that depend only on the assumption that the participants in these interactions will act rationally, with their self-interest as the main objective.</simpara>
<simpara>In broad terms, there are a handful of ways to ensure fair outcomes in interactions between individuals who may have competing interests:</simpara>
<variablelist>
<varlistentry>
<term>
Require trust
</term>
<listitem>
<simpara>
You only interact with people whom you already trust, due to prior interactions, reputation, or familial relationships. This works well enough at small scale, especially within families and small groups, that it is the most common basis for cooperative behavior. Unfortunately, it doesn&#8217;t scale and it suffers from tribalist (in-group) bias.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Rule of law
</term>
<listitem>
<simpara>
Establish rules for interactions that are enforced by an institution. This scales better, but it cannot scale globally due to differences in customs and traditions, as well as the inability to scale the institutions of enforcement. One nasty side effect of this solution is that the institutions become more and more powerful as they get bigger and that may lead to corruption.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Trusted third parties
</term>
<listitem>
<simpara>
Put an intermediary in every interaction to enforce fairness. Combined with the "rule of law" to provide oversight of intermediaries, this scales better, but suffers from the same imbalance of power: the intermediaries get very powerful and may attract corruption. Concentration of power leads to systemic risk and systemic failure ("too big to fail").
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Game theoretical fairness protocols
</term>
<listitem>
<simpara>
This last category emerges from the combination of the internet and cryptography and is the subject of this section. Let&#8217;s see how it works and what its advantages and disadvantages are.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<section id="_trusted_protocols_without_intermediaries">
<title>Trusted Protocols Without Intermediaries</title>
<simpara><indexterm>
  <primary>fairness protocol</primary><secondary>trusted protocols without intermediaries</secondary>
</indexterm>
<indexterm>
  <primary>trusted protocols without intermediaries</primary>
</indexterm>Cryptographic systems like Bitcoin and the Lightning Network are systems that allow you to transact with people (and computers) that you don&#8217;t trust. This is often referred to as "trustless" operation, even though it is not actually trustless. You have to trust in the software that you run, and you have to trust that the protocol implemented by that software will result in fair outcomes.</simpara>
<simpara>The big distinction between a cryptographic system like this and a traditional financial system is that in traditional finance you have a <emphasis>trusted third party</emphasis>, for example a bank, to ensure that outcomes are fair. A significant problem with such systems is that they give too much power to the third party, and they are also vulnerable to a <emphasis>single point of failure</emphasis>. If the trusted third party itself violates trust or attempts to cheat, the basis of trust breaks.</simpara>
<simpara>As you study cryptographic systems, you will notice a certain pattern: instead of relying on a trusted third party, these systems attempt to prevent unfair outcomes by using a system of incentives and disincentives. In cryptographic systems you place trust in the <indexterm>
  <primary>protocol, defined</primary>
</indexterm><emphasis>protocol</emphasis>, which is effectively a system with a set of rules that, if properly designed, will correctly apply the desired incentives and disincentives. The advantage of this approach is twofold: not only do you avoid trusting a third party, you also reduce the need to enforce fair outcomes. So long as the participants follow the agreed protocol and stay within the system, the incentive mechanism in that protocol achieves fair outcomes without enforcement.</simpara>
<simpara><indexterm>
  <primary>game theory</primary>
</indexterm>The use of incentives and disincentives to achieve fair outcomes is one aspect of a branch of mathematics called <emphasis>game theory</emphasis>, which studies "models of strategic interaction among rational decision makers."<footnote><simpara>The Wikipedia <ulink url="https://en.wikipedia.org/wiki/Game_theory">entry on game theory</ulink> provides more information.</simpara></footnote> Cryptographic systems that control financial interactions between participants, such as Bitcoin and the Lightning Network, rely heavily on game theory to prevent participants from cheating and allow participants who don&#8217;t trust each other to achieve fair outcomes.</simpara>
<simpara>While game theory and its use in cryptographic systems may appear confounding and unfamiliar at first, chances are you&#8217;re already familiar with these systems in your everyday life; you just don&#8217;t recognize them yet. In the following section we&#8217;ll use a simple example from childhood to help us identify the basic pattern. Once you understand the basic pattern, you will see it everywhere in the blockchain space and you will come to recognize it quickly and intuitively.</simpara>
<simpara><indexterm>
  <primary>fairness protocol</primary>
</indexterm>In this book, we call this pattern a <indexterm>
  <primary>fairness protocol</primary><secondary>defined</secondary>
</indexterm>
<indexterm>
  <primary>defined</primary>
</indexterm><emphasis>fairness protocol</emphasis>, defined as a process that uses a system of incentives and/or disincentives to ensure fair outcomes for participants who don&#8217;t trust each other. Enforcement of a fairness protocol is only necessary to ensure that the participants can&#8217;t escape the incentives or disincentives.</simpara>
</section>
<section id="_a_fairness_protocol_in_action">
<title>A Fairness Protocol in Action</title>
<simpara><indexterm>
  <primary>fairness protocol</primary><secondary>real-world example</secondary>
</indexterm>
<indexterm>
  <primary>real-world example</primary>
</indexterm>Let&#8217;s look at an example of a fairness protocol that you may already be familiar with.</simpara>
<simpara>Imagine a family lunch, with a parent and two children. The children are fussy eaters and the only thing they will agree to eat is fried potatoes. The parent has prepared a bowl of fried potatoes ("french fries" or "chips" depending on which English dialect you use). The two siblings must share the plate of chips. The parent must ensure a fair distribution of chips to each child; otherwise, the parent will have to hear constant complaining (maybe all day), and there&#8217;s always a possibility of an unfair situation escalating to violence. What is a parent to do?</simpara>
<simpara>There are a few different ways that fairness can be achieved in this strategic interaction between two siblings that do not trust each other and have competing interests. The naive but commonly used method is for the parent to use their authority as a trusted third party: they split the bowl of chips into two servings. This is similar to traditional finance, where a bank, accountant, or lawyer acts as a trusted third party to prevent any cheating between two parties who want to transact.</simpara>
<simpara>The problem with this scenario is that it vests a lot of power and responsibility in the hands of the trusted third party. In this example, the parent is fully responsible for the equal allocation of chips, and the parties merely wait, watch, and complain.  The children accuse the parent of playing favorites and not allocating the chips fairly. The siblings fight over the chips, yelling "that chip is bigger!" and dragging the parent into their fight. It sounds awful, doesn&#8217;t it? Should the parent yell louder? Take all of the chips away? Threaten to never make chips again and let those ungrateful children go hungry?</simpara>
<simpara>A much better solution exists: the siblings are taught to play a game called "split and choose." At each lunch one sibling splits the bowl of chips into two servings and the <emphasis>other</emphasis> sibling gets to choose which serving they want. Almost immediately, the siblings figure out the dynamic of this game. If the one splitting makes a mistake or tries to cheat, the other sibling can "punish" them by choosing the bigger bowl. It is in the best interest of both siblings, but especially the one splitting the bowl, to play fair. Only the cheater loses in this scenario. The parent doesn&#8217;t even have to use their authority or enforce fairness. All the parent has to do is <emphasis>enforce the protocol</emphasis>; as long as the siblings cannot escape their assigned roles of "splitter" and "chooser," the protocol itself ensures a fair outcome without the need for any intervention. The parent can&#8217;t play favorites or distort the outcome.</simpara>
<warning>
<simpara>While the infamous chip battles of the 1980s neatly illustrate the point, any similarity between the preceding scenario and any of the authors' actual childhood experiences with their cousins is entirely coincidental&#8230;or is it?</simpara>
</warning>
</section>
<section id="_security_primitives_as_building_blocks">
<title>Security Primitives as Building Blocks</title>
<simpara><indexterm>
  <primary>fairness protocol</primary><secondary>security primitives as building blocks</secondary>
</indexterm>
<indexterm>
  <primary>security primitives as building blocks</primary>
</indexterm><indexterm>
  <primary>security primitives</primary>
</indexterm>In order for a fairness protocol like this to work, there need to be certain guarantees, or <emphasis>security primitives</emphasis>, that can be combined to ensure enforcement. The first security primitive is <emphasis>strict time ordering/sequencing</emphasis>: the "splitting" action must happen before the "choosing" action. It&#8217;s not immediately obvious, but unless you can guarantee that action A happens before action B, then the protocol falls apart. The second security primitive is <emphasis>commitment with nonrepudiation</emphasis>. Each sibling must commit to their choice of role: either splitter or chooser. Also, once the splitting has been completed, the splitter is committed to the split they created—they cannot repudiate that choice and go try again.</simpara>
<simpara>Cryptographic systems offer a number of security primitives that can be combined in different ways to construct a fairness protocol. In addition to sequencing and commitment, we can also use many other tools:</simpara>
<itemizedlist>
<listitem>
<simpara>
Hash functions to fingerprint data, as a form of commitment, or as the basis for a digital signature
</simpara>
</listitem>
<listitem>
<simpara>
Digital signatures for authentication, nonrepudiation, and proof of ownership of a secret
</simpara>
</listitem>
<listitem>
<simpara>
Encryption/decryption to restrict access to information to authorized participants only
</simpara>
</listitem>
</itemizedlist>
<simpara>This is only a small list of a whole "menagerie" of security and cryptographic primitives that are in use. More basic primitives and combinations are invented all the time.</simpara>
<simpara>In our real-life example, we saw one form of fairness protocol called "split and choose." This is just one of a myriad different fairness protocols that can be built by combining the building blocks of security primitives in different ways. But the basic pattern is always the same: two or more participants interact without trusting each other by engaging in a series of steps that are part of an agreed protocol. The protocol&#8217;s steps arrange incentives and disincentives to ensure that if the participants are rational, cheating is counterproductive and fairness is the automatic outcome. Enforcement is not necessary to get fair outcomes—it is only necessary to keep the participants from breaking out of the agreed protocol.</simpara>
<simpara>Now that you understand this basic pattern, you will start seeing it everywhere in Bitcoin, the Lightning Network, and many other systems. Let&#8217;s look at some specific examples next.</simpara>
</section>
<section id="_example_of_the_fairness_protocol">
<title>Example of the Fairness Protocol</title>
<simpara><indexterm>
  <primary>fairness protocol</primary><secondary>Proof of Work example</secondary>
</indexterm>
<indexterm>
  <primary>Proof of Work example</primary>
</indexterm><indexterm>
  <primary>PoW (Proof of Work) algorithm</primary>
</indexterm><indexterm>
  <primary>Proof of Work (PoW) algorithm</primary>
</indexterm>The most prominent example of a fairness protocol is Bitcoin&#8217;s consensus algorithm, Proof of Work (PoW). In Bitcoin, miners compete to verify transactions and aggregate them in blocks. To ensure that the miners do not cheat, without entrusting them with authority, Bitcoin uses a system of incentives and disincentives. Miners have to use electricity and dedicate hardware doing "work" that is embedded as a "proof" inside every block. This is achieved because of a property of hash functions where the output value is randomly distributed across the entire range of possible outputs. If miners succeed in producing a valid block fast enough, they are rewarded by earning the block reward for that block. Forcing miners to use a lot of electricity before the network considers their block means that they have an incentive to correctly validate the transactions in the block. If they cheat or make any kind of mistake, their block is rejected and the electricity they used to "prove" it is wasted. No one needs to force miners to produce valid blocks; the reward and punishment incentivize them to do so. All the protocol needs to do is ensure that only valid blocks with Proof of Work are accepted.</simpara>
<simpara>The fairness protocol pattern can also be found in many different aspects of the Lightning Network:</simpara>
<itemizedlist>
<listitem>
<simpara>
Those who fund channels make sure that they have a refund transaction signed before they publish the funding transaction.
</simpara>
</listitem>
<listitem>
<simpara>
Whenever a channel is moved to a new state, the old state is "revoked" by ensuring that if anyone tries to broadcast it, they lose the entire balance and get punished.
</simpara>
</listitem>
<listitem>
<simpara>
Those who forward payments know that if they commit funds forward, they can either get a refund or get paid by the node preceding them.
</simpara>
</listitem>
</itemizedlist>
<simpara>Again and again, we see this pattern. Fair outcomes are not enforced by any authority. They emerge as the natural consequence of a protocol that rewards fairness and punishes cheating, a fairness protocol that harnesses self-interest by directing it toward fair outcomes.</simpara>
<simpara>Bitcoin and the Lightning Network are both implementations of fairness protocols. So why do we need the Lightning Network? Isn&#8217;t Bitcoin enough?<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_motivation_for_the_lightning_network">
<title>Motivation for the Lightning Network</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>motivation for</secondary>
</indexterm>
<indexterm>
  <primary>motivation for</primary>
</indexterm>Bitcoin is a system that records transactions on a globally replicated public ledger. Every transaction is seen, validated, and stored by every participating computer. As you can imagine, this generates a lot of data and is difficult to scale.</simpara>
<simpara>As Bitcoin and the demand for transactions grew, the number of transactions in each block increased until it eventually reached the block size limit.
Once blocks are "full," excess transactions are left to wait in a queue. Many users will increase the fees they&#8217;re willing to pay to buy space for their transactions in the next block.</simpara>
<simpara>If demand continues to outpace the capacity of the network, an increasing number of users' transactions are left waiting unconfirmed. Competition for fees also increases the cost of each transaction, making many smaller-value transactions (e.g., microtransactions) completely uneconomical during periods of particularly high demand.</simpara>
<simpara>To solve this problem, we could increase the block size limit to create space for more transactions. An increase in the "supply" of block space will lead to a lower price equilibrium for transaction fees.</simpara>
<simpara>However, increasing block size shifts the cost to node operators and requires them to expend more resources to validate and store the blockchain. Because blockchains are gossip protocols, each node is required to know and validate every single transaction that occurs on the network. Furthermore, once validated, each transaction and block must be propagated to the node&#8217;s "neighbors," multiplying the bandwidth requirements. As such, the greater the block size, the greater the bandwidth, processing, and storage requirements for each individual node. Increasing transaction capacity in this way has the undesirable effect of centralizing the system by reducing the number of nodes and node operators. Since node operators are not compensated for running nodes, if nodes are very expensive to run, only a few well-funded node operators will continue to run nodes.</simpara>
<section id="_scaling_blockchains">
<title>Scaling Blockchains</title>
<simpara><indexterm>
  <primary>blockchain</primary><secondary>scaling</secondary>
</indexterm>
<indexterm>
  <primary>scaling</primary>
</indexterm><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>scaling blockchains</secondary>
</indexterm>
<indexterm>
  <primary>scaling blockchains</primary>
</indexterm>The side effects of increasing the block size or decreasing the block time with respect to centralization of the network are severe, as a few calculations with the numbers show.</simpara>
<simpara>Let us assume the usage of Bitcoin grows so that the network has to process 40,000 transactions per second, which is the approximate transaction processing level of the Visa network during peak usage.</simpara>
<simpara>Assuming 250 bytes on average per transaction, this would result in a data stream of 10 megabytes per second (MBps) or 80 megabits per second (Mbps) just to be able to receive all the transactions.
This does not include the traffic overhead of forwarding the transaction information to other peers.
While 10 MBps does not seem extreme in the context of high-speed fiber optic and 5G mobile speeds, it would effectively exclude anyone who cannot meet this requirement from running a node, especially in countries where high-performance internet is not affordable or widely available.</simpara>
<simpara>Users also have many other demands on their bandwidth and cannot be expected to expend this much only to receive transactions.</simpara>
<simpara>Furthermore, storing this information locally would result in 864 gigabytes per day. This is roughly one terabyte of data, or the size of a hard drive.</simpara>
<simpara>Verifying 40,000 Elliptic Curve Digital Signature Algorithm (ECDSA) signatures per second is also barely feasible (see <ulink url="https://bitcoin.stackexchange.com/questions/95339/how-many-bitcoin-transactions-can-be-verified-per-second">this article on StackExchange</ulink>), making the <emphasis>initial block download (IBD)</emphasis> of the Bitcoin blockchain  (synchronizing and verifying everything starting from the genesis block) almost impossible without very expensive hardware.</simpara>
<simpara>While 40,000 transactions per second seems like a lot, it only achieves parity with traditional financial payment networks at peak times. Innovations in machine-to-machine payments, microtransactions, and other applications are likely to push demand to many orders higher than that.</simpara>
<simpara>Simply put: you can&#8217;t scale a blockchain to validate the entire world&#8217;s transactions in a decentralized way.</simpara>
<simpara><emphasis>But what if each node wasn&#8217;t required to know and validate every single transaction? What if there was a way to have scalable off-chain transactions, without losing the security of the Bitcoin network?</emphasis></simpara>
<simpara>In February 2015, Joseph Poon and Thaddeus Dryja proposed a possible solution to the Bitcoin scalability problem, with the publication of "The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments."<footnote><simpara>Joseph Poon and Thaddeus Dryja. "The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments." DRAFT Version 0.5.9.2. January 14, 2016. <ulink url="https://lightning.network/lightning-network-paper.pdf">https://lightning.network/lightning-network-paper.pdf</ulink>.</simpara></footnote></simpara>
<simpara>In the (now outdated) whitepaper, Poon and Dryja estimate that in order for Bitcoin to reach the 47,000 transactions per second processed at peak by Visa, it would require 8 GB blocks.
This would make running a node completely untenable for anyone but large-scale enterprises and industrial-grade operations.
The result would be a network in which only a few users could actually validate the state of the ledger.
Bitcoin relies on users validating the ledger for themselves, without explicitly trusting third parties, in order to stay decentralized.
Pricing users out of running nodes would force the average user to trust third parties to discover the state of the ledger, ultimately breaking the trust model of Bitcoin.</simpara>
<simpara>The Lightning Network proposes a new network, a second layer, where users can make payments to each other peer-to-peer, without the necessity of publishing a transaction to the Bitcoin blockchain for each payment.
Users may pay each other on the Lightning Network as many times as they want, without creating additional Bitcoin transactions or incurring on-chain fees.
They only make use of the Bitcoin blockchain to load bitcoin onto the Lightning Network initially and to <emphasis>settle</emphasis>, that is, to remove bitcoin from the Lightning Network.
The result is that many more Bitcoin payments can take place off-chain, with only the initial loading and final settlement transactions needing to be validated and stored by Bitcoin nodes.
Aside from reducing the burden on nodes, payments on the Lightning Network are cheaper for users because they do not need to pay blockchain fees, and more private for users because they are not published to all participants of the network and furthermore are not stored permanently.</simpara>
<simpara>While the Lightning Network was initially conceived for Bitcoin, it can be implemented on any blockchain that meets some basic technical requirements. Other blockchains, such as Litecoin, already support the Lightning Network. Additionally, several other blockchains are developing similar second layer or "layer 2" solutions to help them scale<indexterm>
</indexterm><indexterm>
</indexterm>.<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_the_lightning_network_8217_s_defining_features">
<title>The Lightning Network&#8217;s Defining Features</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>defining features</secondary>
</indexterm>
<indexterm>
  <primary>defining features</primary>
</indexterm>The Lightning Network is a network that operates as a second layer protocol on top of Bitcoin and other blockchains. The Lightning Network enables fast, secure, private, trustless, and permissionless payments. Here are some of the features of the Lightning Network:</simpara>
<itemizedlist>
<listitem>
<simpara>
Users of the Lightning Network can route payments to each other for low cost and in real time.
</simpara>
</listitem>
<listitem>
<simpara>
Users who exchange value over the Lightning Network do not need to wait for block confirmations for payments.
</simpara>
</listitem>
<listitem>
<simpara>
Once a payment on the Lightning Network has completed, usually within a few seconds, it is final and cannot be reversed. Like a Bitcoin transaction, a payment on the Lightning Network can only be refunded by the recipient.
</simpara>
</listitem>
<listitem>
<simpara>
Whereas on-chain Bitcoin transactions are broadcast and verified by all nodes in the network, payments routed on the Lightning Network are transmitted between pairs of nodes and are not visible to everyone, resulting in much greater privacy.
</simpara>
</listitem>
<listitem>
<simpara>
Unlike transactions on the Bitcoin network, payments routed on the Lightning Network do not need to be stored permanently. Lightning thus uses fewer resources and hence is cheaper. This property also has benefits for privacy.
</simpara>
</listitem>
<listitem>
<simpara>
The Lightning Network uses onion routing, similar to the protocol used by The Onion Router (Tor) privacy network, so that even the nodes involved in routing a payment are only directly aware of their predecessor and successor in the payment route.
</simpara>
</listitem>
<listitem>
<simpara>
When used on top of Bitcoin, the Lightning Network uses real bitcoin, which is always in the possession (custody) and full control of the user. Lightning is not a separate token or coin, it <emphasis>is</emphasis> Bitcoin.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="user-stories">
<title>Lightning Network Use Cases, Users, and Their Stories</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>use cases and users</secondary>
</indexterm>
<indexterm>
  <primary>use cases and users</primary>
</indexterm>To better understand how the Lightning Network actually works, and why people use it, we&#8217;ll be following a number of users and their stories.</simpara>
<simpara>In our examples, some of the people have already used Bitcoin and others are completely new to the Bitcoin network. Each person and their story, as listed here, illustrate one or more specific use cases. We&#8217;ll be revisiting them throughout this book:</simpara>
<variablelist>
<varlistentry>
<term>
Consumer
</term>
<listitem>
<simpara>
Alice is a Bitcoin user who wants to make fast, secure, cheap, and private payments for small retail purchases. She buys coffee with bitcoin, using the Lightning Network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Merchant
</term>
<listitem>
<simpara>
Bob owns a coffee shop, "Bob&#8217;s Cafe." On-chain Bitcoin payments don&#8217;t scale for small amounts like a cup of coffee, so he uses the Lightning Network to accept Bitcoin payments almost instantaneously and for low fees.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Software service business
</term>
<listitem>
<simpara>
Chan is a Chinese entrepreneur who sells information services related to the Lightning Network, as well as Bitcoin and other cryptocurrencies. Chan is selling these information services over the internet by implementing micropayments over the Lightning Network. Additionally, Chan has implemented a liquidity provider service that rents inbound channel capacity on the Lightning Network, charging a small bitcoin fee for each rental period.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Gamer
</term>
<listitem>
<simpara>
Dina is a teenage gamer from Russia. She plays many different computer games, but her favorite ones are those that have an "in-game economy" based on real money. As she plays games, she also earns money by acquiring and selling virtual in-game items. The Lightning Network allows her to transact in small amounts for in-game items as well as earn small amounts for completing quests.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_conclusion">
<title>Conclusion</title>
<simpara>In this chapter, we talked about the fundamental concept that underlies both Bitcoin and the Lightning Network: the fairness protocol.</simpara>
<simpara>We looked at the history of the Lightning Network and the motivations behind second layer scaling solutions for Bitcoin and other blockchain-based networks.</simpara>
<simpara>We learned basic terminology including node, payment channel, on-chain transactions, and off-chain payments.</simpara>
<simpara>Finally, we met Alice, Bob, Chan, and Dina, whom we&#8217;ll be following throughout the rest of the book.<indexterm>
</indexterm> In the next chapter, we&#8217;ll meet Alice and walk through her thought process as she selects a Lightning wallet and prepares to make her first Lightning payment to buy a cup of coffee from Bob&#8217;s Cafe.<indexterm>
  <primary>Bitcoin (system)</primary><secondary>Lightning Network compared to</secondary>
</indexterm>
<indexterm>
  <primary>Lightning Network compared to</primary>
</indexterm><indexterm>
  <primary>channel</primary>
</indexterm><indexterm>
  <primary>containers</primary>
</indexterm><indexterm>
  <primary>delivering payment</primary>
</indexterm><indexterm>
  <primary>DoS attacks</primary>
</indexterm><indexterm>
  <primary>encrypted message transport</primary>
</indexterm><indexterm>
  <primary>future issues</primary>
</indexterm><indexterm>
  <primary>HTLCs</primary>
</indexterm><indexterm>
  <primary>invoices</primary>
</indexterm><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>Bitcoin compared to</secondary>
</indexterm>
<indexterm>
  <primary>Bitcoin compared to</primary>
</indexterm><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>invoices</secondary>
</indexterm>
<indexterm>
  <primary>invoices</primary>
</indexterm><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>network architecture</secondary>
</indexterm>
<indexterm>
  <primary>network architecture</primary>
</indexterm><indexterm>
  <primary>Lightning Network node</primary>
</indexterm><indexterm>
  <primary>Lightning payment requests</primary>
</indexterm><indexterm>
  <primary>LN node</primary>
</indexterm><indexterm>
  <primary>LND node project</primary>
</indexterm><indexterm>
  <primary>message transport</primary>
</indexterm><indexterm>
  <primary>node</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>routing on network of</secondary>
</indexterm>
<indexterm>
  <primary>routing on network of</primary>
</indexterm><indexterm>
  <primary>payment requests</primary>
</indexterm><indexterm>
  <primary>payment routing</primary>
</indexterm><indexterm>
  <primary>privacy</primary>
</indexterm><indexterm>
  <primary>privacy</primary>
</indexterm><indexterm>
  <primary>private channels</primary>
</indexterm><indexterm>
  <primary>TLV</primary>
</indexterm><indexterm>
  <primary>wallet</primary>
</indexterm></simpara>
</section>
</chapter>
<chapter id="getting-started">
<title>Getting Started</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>example</secondary>
</indexterm>
<indexterm>
  <primary>example</primary>
</indexterm>In this chapter, we will begin where most people start when encountering the Lightning Network for the first time&#x2014;choosing software to participate in the LN economy. We will examine the choices of two users who represent a common use case for the Lightning Network and learn by example. Alice, a coffee shop customer, will be using a Lightning wallet on her mobile device to buy coffee from Bob&#8217;s Cafe. Bob, a merchant, will be using a Lightning node and wallet to run a point-of-sale system at his cafe, so he can accept payments over the Lightning Network.</simpara>
<section id="_alice_8217_s_first_lightning_wallet">
<title>Alice&#8217;s First Lightning Wallet</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>Lightning wallet</secondary>
</indexterm>
<indexterm>
  <primary>Lightning wallet</primary>
</indexterm><indexterm>
  <primary>Lightning wallet</primary>
</indexterm>Alice is a longtime Bitcoin user. We first met Alice in Chapter 1 of <emphasis>Mastering Bitcoin</emphasis>,<footnote><simpara>Andreas M. Antonopoulos, <emphasis>Mastering Bitcoin</emphasis>, 2nd Edition, <ulink url="https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch01.asciidoc">Chapter 1</ulink> (O&#8217;Reilly)</simpara></footnote> when she bought a cup of coffee from Bob&#8217;s cafe using a Bitcoin transaction. If you are not yet familiar with how Bitcoin transactions work or need a refresher, please read <emphasis>Mastering Bitcoin</emphasis> or the summary in <xref linkend="bitcoin_fundamentals_review"/>.</simpara>
<simpara>Alice recently learned that Bob&#8217;s Cafe just started accepting LN payments! Alice is eager to learn about and experiment with the Lightning Network; she wants to be one of Bob&#8217;s first LN customers. To do this, first, Alice has to select a Lightning wallet that meets her needs.</simpara>
<simpara>Alice does not want to entrust custody of her bitcoin to third parties. She has learned enough about cryptocurrency to know how to use a wallet. She also wants a mobile wallet so that she can use it for small payments on the go, so she chooses the <emphasis>Eclair</emphasis> wallet, a popular noncustodial mobile Lightning wallet. Let&#8217;s learn more about how and why she&#8217;s made these choices.</simpara>
</section>
<section id="_lightning_nodes">
<title>Lightning Nodes</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary>
</indexterm>The Lightning Network is accessed via software applications that can speak the LN protocol. A <emphasis>Lightning Network node</emphasis> (LN node or simply node) is a software application that has three important characteristics. First, Lightning nodes are wallets, so they send and receive payments over the Lightning Network as well as on the Bitcoin network. Second, nodes must communicate on a peer-to-peer basis with other Lightning nodes creating the network. Finally, Lightning nodes also need access to the Bitcoin blockchain (or other blockchains for other cryptocurrencies) to secure the funds used for payments.</simpara>
<simpara>Users have the highest degree of control by running their own Bitcoin node and Lightning node. However, <indexterm>
  <primary>simplified payment verification (SPV)</primary>
</indexterm><indexterm>
  <primary>SPV (simplified payment verification)</primary>
</indexterm>Lightning nodes can also use a lightweight Bitcoin client, commonly referred to as simplified payment verification (SPV), to interact with the Bitcoin blockchain.</simpara>
</section>
<section id="ln_explorer">
<title>Lightning Explorers</title>
<simpara><indexterm>
  <primary>Lightning explorers</primary>
</indexterm>LN explorers are useful tools to show the statistics of nodes, channels, and network capacity.</simpara>
<simpara>Following is an inexhaustive list:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://1ml.com">1ML Lightning explorer</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://explorer.acinq.co">ACINQ&#8217;s Lightning explorer</ulink>, with fancy visualization
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://amboss.space">Amboss Space Lightning explorer</ulink>, with community metrics and intuitive <span class="keep-together">visualizations</span>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://ln.bigsun.xyz">Fiatjaf&#8217;s Lightning explorer</ulink> with many diagrams
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://hashxp.org/lightning/node">hashXP Lightning explorer</ulink>
</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>Note that when using Lightning explorers, just like with other block explorers, privacy can be a concern.
If users are careless, the website may track their IP addresses and collect their behavior records (for example, the nodes users are interested in).</simpara>
<simpara>Also, it should be noted that because there is no global consensus of the current Lightning graph or the current state of any existing channel policy, users should never rely on Lightning explorers to retrieve the most current information.
Furthermore, as users open, close, and update channels, the graph will change and individual Lightning explorers may not be up to date.
Use Lightning explorers to visualize the network or gather information, but not as an authoritative source of what is happening on the Lightning Network.
To have an authoritative view of the Lightning Network, run your own Lightning node that will build a channel graph and collect various statistics, which you can view with a web-based interface.</simpara>
</tip>
</section>
<section id="_lightning_wallets">
<title>Lightning Wallets</title>
<simpara><indexterm>
  <primary>Lightning wallet</primary><secondary>basics</secondary>
</indexterm>
<indexterm>
  <primary>basics</primary>
</indexterm>The term <emphasis>Lightning wallet</emphasis> is somewhat ambiguous because it can describe a broad variety of components combined with some user interface. The most common components of Lightning wallet software include:</simpara>
<itemizedlist>
<listitem>
<simpara>
A keystore that holds secrets, such as private keys
</simpara>
</listitem>
<listitem>
<simpara>
An LN node (Lightning node) that communicates on the peer-to-peer network, as described previously
</simpara>
</listitem>
<listitem>
<simpara>
A Bitcoin node that stores blockchain data and communicates with other Bitcoin nodes
</simpara>
</listitem>
<listitem>
<simpara>
A database "map" of nodes and channels that are announced on the Lightning Network
</simpara>
</listitem>
<listitem>
<simpara>
A channel manager that can open and close LN channels
</simpara>
</listitem>
<listitem>
<simpara>
A close-up system that can find a path of connected channels from payment source to payment destination
</simpara>
</listitem>
</itemizedlist>
<simpara>A Lightning wallet may contain all of these functions, acting as a "full" wallet, with no reliance on any third-party services. Or one or more of these components may rely (partially or entirely) on third-party services that mediate those functions.</simpara>
<simpara>A <emphasis>key</emphasis> distinction (pun intended) is whether the keystore function is internal or outsourced. In blockchains, control of keys determines custody of funds, as memorialized by the phrase "your keys, your coins; not your keys, not your coins." <indexterm>
  <primary>custodial wallet</primary>
</indexterm>Any wallet that outsources management of keys is called a <emphasis>custodial</emphasis> wallet because a third party acting as custodian has control of the user&#8217;s funds, not the user. <indexterm>
  <primary>noncustodial wallet</primary>
</indexterm>A <emphasis>noncustodial</emphasis> or <indexterm>
  <primary>self-custody wallet</primary>
</indexterm><emphasis>self-custody</emphasis> wallet, by comparison, is one where the keystore is part of the wallet, and keys are controlled directly by the user.  The term noncustodial wallet just implies that the keystore is local and under the user&#8217;s control. However, one or more of the other wallet components may or may not be outsourced and rely on trusted third parties.</simpara>
<simpara>Blockchains, especially open blockchains like Bitcoin, attempt to minimize or eliminate trust in third parties and empower users. <indexterm>
  <primary>trustless systems</primary><secondary>blockchains as</secondary>
</indexterm>
<indexterm>
  <primary>blockchains as</primary>
</indexterm>This is often called a "trustless" model, though "trust minimized" is a better term. In such systems, the user trusts the software rules, not third parties. Therefore, the issue of control over keys is a principal consideration when choosing a Lightning wallet.</simpara>
<simpara>Every other component of a Lightning wallet brings similar considerations of trust. If all the components are under the control of the user, then the amount of trust in third parties is minimized, bringing maximum power to the user. Of course, this brings a direct trade-off because with that power comes the corresponding responsibility to manage complex software.</simpara>
<simpara>Every user must consider their own technical skills before deciding what type of Lightning wallet to use. Those with strong technical skills should use a Lightning wallet that puts all of the components under the direct control of the user. Those with fewer technical skills, but with a desire to control their funds, should choose a noncustodial Lightning wallet.
Often the trust in these cases relates to privacy.
If users decide to outsource some functionality to a third party, they usually give up some privacy as the third party will learn some information about them.</simpara>
<simpara>Finally, those seeking simplicity and convenience, even at the expense of control and security, may choose a custodial Lightning wallet. This is the least technically challenging option, but it <emphasis>undermines the trust model of cryptocurrency</emphasis> and should therefore be considered only as a stepping stone toward more control and self-reliance.</simpara>
<simpara>There are many ways wallets can be characterized or categorized.
The most important questions to ask about a specific wallet are:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Does this Lightning wallet have a full Lightning node or does it use a third-party Lightning node?
</simpara>
</listitem>
<listitem>
<simpara>
Does this Lightning wallet have a full Bitcoin node or does it use a third-party Bitcoin node?
</simpara>
</listitem>
<listitem>
<simpara>
Does this Lightning wallet store its own keys under user control (self-custody) or are the keys held by a third-party custodian?
</simpara>
</listitem>
</orderedlist>
<tip>
<simpara>If a Lightning wallet uses a third-party Lightning node, it is this third-party Lightning node that decides how to communicate with Bitcoin. Hence, using a third-party Lightning node implies that you are also using a third-party Bitcoin node. Only when the Lightning wallet uses its own Lightning node does the choice between full Bitcoin node and third-party Bitcoin node exist.</simpara>
</tip>
<simpara>At the highest level of abstraction, Questions 1 and 3 are the most elementary ones.
From these two questions, we can derive four possible categories.
We can place these four categories into a quadrant, as seen in <xref linkend="lnwallet-categories"/>.
But remember that this is just one way of categorizing Lightning wallets.</simpara>
<table id="lnwallet-categories"
frame="all"
rowsep="1" colsep="1"
>
<title>Lightning wallets quadrant</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">                        </entry>
<entry align="left" valign="top"> <emphasis role="strong">Full Lightning node</emphasis>      </entry>
<entry align="left" valign="top"> <emphasis role="strong">Third-party Lightning node</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Self-custody</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Q1: High technical skill, least trust in third parties, most permissionless</simpara></entry>
<entry align="left" valign="top"><simpara>Q2: Below medium technical skills, below medium trust in third parties, requires some permissions</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Custodial</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Q3: Above medium technical skills, above medium trust in third parties, requires some permissions</simpara></entry>
<entry align="left" valign="top"><simpara>Q4: Low technical skills, high trust in third parties, least permissionless</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Quadrant 3 (Q3), where a full Lightning node is used, but the keys are held by a custodian, is currently not common.
Future wallets from that quadrant may let a user worry about the operational aspects of their node, but then delegate access to the keys to a third party which primarily uses cold storage.</simpara>
<simpara>Lightning wallets can be installed on a variety of devices, including laptops, servers, and mobile devices. To run a full Lightning node, you will need to use a server or desktop computer, because mobile devices and laptops are usually not powerful enough in terms of capacity, processing, battery life, and connectivity.</simpara>
<simpara>The category third-party Lightning nodes can again be subdivided:</simpara>
<variablelist>
<varlistentry>
<term>
Lightweight
</term>
<listitem>
<simpara>
 This means that the wallet does not operate a Lightning node and thus needs to obtain information about the Lightning Network over the internet from someone else&#8217;s Lightning node.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
None
</term>
<listitem>
<simpara>
 This means that not only is the Lightning node operated by a third party, but most of the wallet is operated by a third party in the cloud. This is a custodial wallet where someone else controls custody of the funds.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>These subcategories are used in <xref linkend="lnwallet-examples"/>.</simpara>
<simpara role="pagebreak-before">Other terms that need explanation in <xref linkend="lnwallet-examples"/> in the column "Bitcoin node" are:</simpara>
<variablelist>
<varlistentry>
<term>
Neutrino
</term>
<listitem>
<simpara>
 This wallet does not operate a Bitcoin node. Instead, a Bitcoin node operated by someone else (a third party) is accessed via the Neutrino Protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Electrum
</term>
<listitem>
<simpara>
 This wallet does not operate a Bitcoin node. Instead, a Bitcoin node operated by someone else (a third party) is accessed via the Electrum Protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Bitcoin Core
</term>
<listitem>
<simpara>
 This is an implementation of a Bitcoin node.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
btcd
</term>
<listitem>
<simpara>
 This is another implementation of a Bitcoin node.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>In <xref linkend="lnwallet-examples"/>, we see some examples of currently popular Lightning node and wallet applications for different types of devices. The list is sorted first by device type and then alphabetically.</simpara>
<table id="lnwallet-examples"
frame="all"
rowsep="1" colsep="1"
>
<title>Examples of popular Lightning wallets</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top"> Application    </entry>
<entry align="left" valign="top"> Device  </entry>
<entry align="left" valign="top"> Lightning node </entry>
<entry align="left" valign="top"> Bitcoin node          </entry>
<entry align="left" valign="top"> Keystore</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Blue Wallet</simpara></entry>
<entry align="left" valign="top"><simpara>Mobile</simpara></entry>
<entry align="left" valign="top"><simpara>None</simpara></entry>
<entry align="left" valign="top"><simpara>None</simpara></entry>
<entry align="left" valign="top"><simpara>Custodial</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Breez Wallet</simpara></entry>
<entry align="left" valign="top"><simpara>Mobile</simpara></entry>
<entry align="left" valign="top"><simpara>Full node</simpara></entry>
<entry align="left" valign="top"><simpara>Neutrino</simpara></entry>
<entry align="left" valign="top"><simpara>Self-custody</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Eclair Mobile</simpara></entry>
<entry align="left" valign="top"><simpara>Mobile</simpara></entry>
<entry align="left" valign="top"><simpara>Lightweight</simpara></entry>
<entry align="left" valign="top"><simpara>Electrum</simpara></entry>
<entry align="left" valign="top"><simpara>Self-custody</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>lntxbot</simpara></entry>
<entry align="left" valign="top"><simpara>Mobile</simpara></entry>
<entry align="left" valign="top"><simpara>None</simpara></entry>
<entry align="left" valign="top"><simpara>None</simpara></entry>
<entry align="left" valign="top"><simpara>Custodial</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Muun</simpara></entry>
<entry align="left" valign="top"><simpara>Mobile</simpara></entry>
<entry align="left" valign="top"><simpara>Lightweight</simpara></entry>
<entry align="left" valign="top"><simpara>Neutrino</simpara></entry>
<entry align="left" valign="top"><simpara>Self-custody</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Phoenix Wallet</simpara></entry>
<entry align="left" valign="top"><simpara>Mobile</simpara></entry>
<entry align="left" valign="top"><simpara>Lightweight</simpara></entry>
<entry align="left" valign="top"><simpara>Electrum</simpara></entry>
<entry align="left" valign="top"><simpara>Self-custody</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Zeus</simpara></entry>
<entry align="left" valign="top"><simpara>Mobile</simpara></entry>
<entry align="left" valign="top"><simpara>Full node</simpara></entry>
<entry align="left" valign="top"><simpara>Bitcoin Core/btcd</simpara></entry>
<entry align="left" valign="top"><simpara>Self-custody</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Electrum</simpara></entry>
<entry align="left" valign="top"><simpara>Desktop</simpara></entry>
<entry align="left" valign="top"><simpara>Full node</simpara></entry>
<entry align="left" valign="top"><simpara>Bitcoin Core/Electrum</simpara></entry>
<entry align="left" valign="top"><simpara>Self-custody</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Zap Desktop</simpara></entry>
<entry align="left" valign="top"><simpara>Desktop</simpara></entry>
<entry align="left" valign="top"><simpara>Full node</simpara></entry>
<entry align="left" valign="top"><simpara>Neutrino</simpara></entry>
<entry align="left" valign="top"><simpara>Self-custody</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>c-lightning</simpara></entry>
<entry align="left" valign="top"><simpara>Server</simpara></entry>
<entry align="left" valign="top"><simpara>Full node</simpara></entry>
<entry align="left" valign="top"><simpara>Bitcoin Core</simpara></entry>
<entry align="left" valign="top"><simpara>Self-custody</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Eclair Server</simpara></entry>
<entry align="left" valign="top"><simpara>Server</simpara></entry>
<entry align="left" valign="top"><simpara>Full node</simpara></entry>
<entry align="left" valign="top"><simpara>Bitcoin Core/Electrum</simpara></entry>
<entry align="left" valign="top"><simpara>Self-custody</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>lnd</simpara></entry>
<entry align="left" valign="top"><simpara>Server</simpara></entry>
<entry align="left" valign="top"><simpara>Full node</simpara></entry>
<entry align="left" valign="top"><simpara>Bitcoin Core/btcd</simpara></entry>
<entry align="left" valign="top"><simpara>Self-custody</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section id="testnet-bitcoin">
<title>Testnet Bitcoin</title>
<simpara><indexterm>
  <primary>Lightning wallet</primary><secondary>testnet bitcoin and</secondary>
</indexterm>
<indexterm>
  <primary>testnet bitcoin and</primary>
</indexterm><indexterm>
  <primary>testnet bitcoin (tBTC)</primary>
</indexterm>The Bitcoin system offers an alternative chain for testing purposes called <emphasis>testnet</emphasis>, in contrast with the "normal" Bitcoin chain which is referred to as <emphasis>mainnet</emphasis>. On testnet, the currency is <emphasis>testnet bitcoin</emphasis> (<emphasis>tBTC</emphasis>), which is a worthless copy of bitcoin used exclusively for testing. Every function of Bitcoin is replicated exactly, but the money is worth nothing, so you literally have nothing to lose!</simpara>
<simpara>Some Lightning wallets can also operate on testnet, allowing you to make Lightning payments with testnet bitcoin, without risking real funds. This is a great way to experiment with Lightning safely. Eclair Mobile, which Alice uses in this chapter, is one example of a Lightning wallet that supports testnet operation.</simpara>
<simpara>You can get some tBTC to play with from a <emphasis>testnet bitcoin faucet</emphasis>, which gives out free tBTC on demand. Here are a few testnet faucets:</simpara>
<ul class="simplelist">
<li><a href="https://coinfaucet.eu/en/btc-testnet/"><em>https://coinfaucet.eu/en/btc-testnet</em></a></li>
<li><a href="https://testnet-faucet.mempool.co/"><em>https://testnet-faucet.mempool.co</em></a></li>
<li><a href="https://bitcoinfaucet.uo1.net/"><em>https://bitcoinfaucet.uo1.net</em></a></li>
<li><a href="https://testnet.help/en/btcfaucet/testnet"><em>https://testnet.help/en/btcfaucet/testnet</em></a></li>
</ul>
<simpara>All of the examples in this book can be replicated exactly on testnet with tBTC, so you can follow along if you want without risking real money.<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_balancing_complexity_and_control">
<title>Balancing Complexity and Control</title>
<simpara><indexterm>
  <primary>Lightning wallet</primary><secondary>balancing complexity and control</secondary>
</indexterm>
<indexterm>
  <primary>balancing complexity and control</primary>
</indexterm>Lightning wallets have to strike a careful balance between complexity and user control. Those that give the user the most control over their funds, the highest degree of privacy, and the greatest independence from third-party services are necessarily more complex and difficult to operate. As the technology advances, some of these trade-offs will become less stark, and users may be able to get more control without more complexity. However, for now, different companies and projects are exploring different positions along this control-complexity spectrum, hoping to find the "sweet spot" for the users they are targeting.</simpara>
<simpara>When selecting a wallet, keep in mind that even if you don&#8217;t see these trade-offs, they still exist. For example, many wallets will attempt to remove the burden of channel management from their users. To do so, they introduce central <emphasis>hub nodes</emphasis> that all their wallets connect to automatically. While this trade-off simplifies the user interface and user experience, it introduces a single point of failure (SPoF) as these hub nodes become indispensable for the wallet&#8217;s operation. Furthermore, relying on a "hub" like this can reduce user privacy since the hub knows the sender and potentially (if constructing the payment route on behalf of the user) also the recipient of each payment made by the user&#8217;s wallet.</simpara>
<simpara>In the next section, we will return to our first user and walk through her first Lightning wallet setup. She has chosen a wallet that is more sophisticated than the easier custodial wallets. This allows us to show some of the underlying complexity and introduce some of the inner workings of an advanced wallet. You may find that your first ideal wallet is oriented toward ease of use, accepting some of the control and privacy trade-offs. Or perhaps you are more of a power user and want to run your own Lightning and Bitcoin nodes as part of your wallet solution.</simpara>
</section>
<section id="_downloading_and_installing_a_lightning_wallet">
<title>Downloading and Installing a Lightning Wallet</title>
<simpara><indexterm>
  <primary>Lightning wallet</primary><secondary>downloading/installing</secondary>
</indexterm>
<indexterm>
  <primary>downloading/installing</primary>
</indexterm>When looking for a new cryptocurrency wallet, you must be very careful to select a secure source for the software.</simpara>
<simpara>Unfortunately, many fake wallet applications will steal your money, and some of these even find their way onto reputable and supposedly vetted software sites like the Apple and Google application stores. Whether you are installing your first or your tenth wallet, always exercise extreme caution. A rogue app may not just steal any money you entrust it with, but it might also be able to steal keys and passwords from other applications by compromising your mobile device operating system.</simpara>
<simpara><indexterm>
  <primary>Eclair wallet, downloading/installing</primary>
</indexterm>Alice uses an Android device and will use the Google Play Store to download and install the Eclair wallet. Searching on Google Play, she finds an entry for "Eclair Mobile," as shown in <xref linkend="eclair-playstore"/>.</simpara>
<figure id="eclair-playstore"><title>Eclair Mobile in the Google Play Store</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0201.png"/>
  </imageobject>
  <textobject><phrase>Eclair wallet in the Google Play Store</phrase></textobject>
</mediaobject>
</figure>
<tip>
<simpara>It is possible to experiment and test all Bitcoin-type software with zero risk (except for your own time) by using testnet bitcoins. You can also download the Eclair testnet wallet to try Lightning (on testnet) by going to the Google Play Store.</simpara>
</tip>
<simpara>Alice notices a few different elements on this page that help her ascertain that this is, most likely, the correct "Eclair Mobile" wallet she is looking for. Firstly, the organization ACINQ<footnote><simpara>ACINQ: Developers of the Eclair Mobile Lightning wallet.</simpara></footnote> is listed as the developer of this mobile wallet, which Alice knows from her research is the correct developer. Secondly, the wallet has been installed "10,000+" times and has more than 320 positive reviews. It is unlikely that this is a rogue app that has snuck into the Google Play Store. As a third step, she goes to the <ulink url="https://acinq.co">ACINQ website</ulink>. She verifies that the web page is secure by checking that the address begins with https, or prefixed by a padlock in some browsers. On the website, she goes to the Download section or looks for the link to the Google App Store. She finds the link and clicks it. She compares that this link brings her to the very same app in the Google App Store. Satisfied by these findings, Alice installs the Eclair app on her mobile device.</simpara>
<warning>
<simpara>Always exercise great care when installing software on any device. There are many fake cryptocurrency wallets that will not only steal your money but might also compromise all other applications on your device.</simpara>
</warning>
</section>
<section id="_creating_a_new_wallet">
<title>Creating a New Wallet</title>
<simpara><indexterm>
  <primary>Lightning wallet</primary><secondary>creating a new wallet</secondary>
</indexterm>
<indexterm>
  <primary>creating a new wallet</primary>
</indexterm>When Alice opens the Eclair Mobile app for the first time, she is presented with a choice to "Create a New Wallet" or to "Import an Existing Wallet." Alice will create a new wallet, but let&#8217;s first discuss why these options are presented here and what it means to import an existing wallet.</simpara>
<section id="_responsibility_with_key_custody">
<title>Responsibility with Key Custody</title>
<simpara><indexterm>
  <primary>keys</primary><secondary>Lightning wallet and</secondary>
</indexterm>
<indexterm>
  <primary>Lightning wallet and</primary>
</indexterm><indexterm>
  <primary>Lightning wallet</primary><secondary>responsibility with key custody</secondary>
</indexterm>
<indexterm>
  <primary>responsibility with key custody</primary>
</indexterm>As we mentioned at the beginning of this section, Eclair is a <emphasis>noncustodial</emphasis> wallet, meaning that Alice has sole custody of the keys used to control her bitcoin. This also means that Alice is responsible for protecting and backing up those keys. If Alice loses the keys, no one can help her recover the bitcoin, and they will be lost forever.</simpara>
<warning>
<simpara>With the Eclair Mobile wallet, Alice has custody and control of the keys and, therefore, full responsibility to keep the keys safe and backed up. If she loses the keys, she loses the bitcoin, and no one can help her recover from that loss!</simpara>
</warning>
</section>
<section id="_mnemonic_words">
<title>Mnemonic Words</title>
<simpara><indexterm>
  <primary>Lightning wallet</primary><secondary>mnemonic phrase</secondary>
</indexterm>
<indexterm>
  <primary>mnemonic phrase</primary>
</indexterm><indexterm>
  <primary>mnemonic phrase</primary>
</indexterm><indexterm>
  <primary>seed (mnemonic) phrase</primary>
</indexterm>Similar to most Bitcoin wallets, Eclair Mobile provides a <emphasis>mnemonic phrase</emphasis> (also sometimes called a "seed" or "seed phrase") for Alice to back up. The mnemonic phrase consists of 24 English words, selected randomly by the software and used as the basis for the keys that are generated by the wallet. Alice can use the mnemonic phrase to restore all the transactions and funds in the Eclair Mobile wallet in the case of a lost mobile device, a software bug, or memory corruption.</simpara>
<tip>
<simpara>The correct term for these backup words is "mnemonic phrase." We avoid the use of the term "seed" to refer to a mnemonic phrase because even though its use is common, it is incorrect.</simpara>
</tip>
<simpara>When Alice chooses to create a new wallet, she will see a screen with her mnemonic phrase, which looks like the screenshot in <xref linkend="eclair-mnemonic"/>.</simpara>
<figure id="eclair-mnemonic"><title>New wallet mnemonic phrase</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0202.png"/>
  </imageobject>
  <textobject><phrase>New Wallet Mnemonic Phrase</phrase></textobject>
</mediaobject>
</figure>
<simpara>In <xref linkend="eclair-mnemonic"/>, we have purposely obscured part of the mnemonic phrase to prevent readers of this book from reusing the mnemonic.</simpara>
</section>
<section id="mnemonic-storage">
<title>Storing the Mnemonic Safely</title>
<simpara><indexterm>
  <primary>Lightning wallet</primary><secondary>mnemonic phrase storage</secondary>
</indexterm>
<indexterm>
  <primary>mnemonic phrase storage</primary>
</indexterm>Alice needs to be careful to store the mnemonic phrase in a way that prevents theft but also avoids accidental loss. The recommended way to properly balance these risks is to write two copies of the mnemonic phrase on paper, with each of the words numbered&#x2014;the order matters.</simpara>
<simpara>Once Alice has recorded the mnemonic phrase, after touching "OK GOT IT" on her screen, she will be presented with a quiz to make sure that she correctly recorded the mnemonic. The quiz will ask for three or four of the words at random. Alice isn&#8217;t expecting a quiz, but since she recorded the mnemonic correctly, she passes without any difficulty.</simpara>
<simpara>Once Alice has recorded the mnemonic phrase and passed the quiz, she should store each copy in a separate secure location, such as a locked desk drawer or a fireproof safe.</simpara>
<warning>
<simpara>Never attempt a "DIY" security scheme that deviates in any way from the best practice recommendation in <xref linkend="mnemonic-storage"/>. Do not cut your mnemonic in half, make screenshots, store it on USB drives or cloud drives, encrypt it, or try any other nonstandard method. You will tip the balance in such a way as to risk permanent loss. Many people have lost funds, not from theft, but because they tried a nonstandard solution without having the expertise to balance the risks involved. The best practice recommendation is carefully considered by experts and suitable for the vast majority of users.</simpara>
</warning>
<simpara>After Alice initializes her Eclair Mobile wallet, she will see a brief tutorial that highlights the various elements of the user interface. We won&#8217;t replicate the tutorial here, but we will explore all of those elements as we follow Alice&#8217;s attempt to buy a cup of coffee!<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_loading_bitcoin_onto_the_wallet">
<title>Loading Bitcoin onto the Wallet</title>
<simpara><indexterm>
  <primary>bitcoin (currency)</primary><secondary>loading onto Lightning wallet</secondary>
</indexterm>
<indexterm>
  <primary>loading onto Lightning wallet</primary>
</indexterm><indexterm>
  <primary>Lightning wallet</primary><secondary>loading bitcoin onto</secondary>
</indexterm>
<indexterm>
  <primary>loading bitcoin onto</primary>
</indexterm>Alice now has a Lightning wallet. But it&#8217;s empty! She now faces one of the more challenging aspects of this experiment: she has to find a way to acquire some bitcoin and load it onto her Eclair wallet.</simpara>
<tip>
<simpara>If Alice already has bitcoin in another wallet, she could choose to send that bitcoin to her Eclair wallet instead of acquiring new bitcoin to load onto her new wallet.</simpara>
</tip>
<section id="acquiring-bitcoin">
<title>Acquiring Bitcoin</title>
<simpara><indexterm>
  <primary>bitcoin (currency)</primary><secondary>acquiring for Lightning wallet</secondary>
</indexterm>
<indexterm>
  <primary>acquiring for Lightning wallet</primary>
</indexterm><indexterm>
  <primary>Lightning wallet</primary><secondary>acquiring bitcoin for</secondary>
</indexterm>
<indexterm>
  <primary>acquiring bitcoin for</primary>
</indexterm>There are several ways Alice can acquire bitcoin:</simpara>
<itemizedlist>
<listitem>
<simpara>
She can exchange some of her national currency (e.g., USD) on a cryptocurrency exchange.
</simpara>
</listitem>
<listitem>
<simpara>
She can buy some from a friend, or an acquaintance from a Bitcoin meetup, in exchange for cash.
</simpara>
</listitem>
<listitem>
<simpara>
She can find a <emphasis>Bitcoin ATM</emphasis> in her area, which acts as a vending machine, selling bitcoin for cash.
</simpara>
</listitem>
<listitem>
<simpara>
She can offer her skills or a product she sells and accept payment in bitcoin.
</simpara>
</listitem>
<listitem>
<simpara>
She can ask her employer or clients to pay her in bitcoin.
</simpara>
</listitem>
</itemizedlist>
<simpara role="pagebreak-before">All of these methods have varying degrees of difficulty, and many will involve paying a fee. Some will also require Alice to provide identification documents to comply with local banking regulations. However, with all these methods, Alice will be able to receive bitcoin.</simpara>
</section>
<section id="_receiving_bitcoin">
<title>Receiving Bitcoin</title>
<simpara><indexterm>
  <primary>bitcoin (currency)</primary><secondary>receiving for Lightning wallet</secondary>
</indexterm>
<indexterm>
  <primary>receiving for Lightning wallet</primary>
</indexterm><indexterm>
  <primary>Bitcoin ATM</primary>
</indexterm><indexterm>
  <primary>Lightning wallet</primary><secondary>receiving bitcoin</secondary>
</indexterm>
<indexterm>
  <primary>receiving bitcoin</primary>
</indexterm>Let&#8217;s assume Alice has found a local Bitcoin ATM and has decided to buy some bitcoin in exchange for cash. An example of a Bitcoin ATM, one built by the Lamassu Company, is shown in <xref linkend="bitcoin-atm"/>. Such Bitcoin ATMs accept national currency (cash) through a cash slot and send bitcoin to a Bitcoin address scanned from a user&#8217;s wallet using a built-in camera.</simpara>
<figure id="bitcoin-atm"><title>A Lamassu Bitcoin ATM</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0203.png"/>
  </imageobject>
  <textobject><phrase>Lamassu Bitcoin ATM</phrase></textobject>
</mediaobject>
</figure>
<simpara>To receive the bitcoin in her Eclair Lightning wallet, Alice will need to present a Bitcoin address from the Eclair Lightning wallet to the ATM. The ATM can then send Alice&#8217;s newly acquired bitcoin to this Bitcoin address.</simpara>
<simpara>To see a Bitcoin address on the Eclair wallet, Alice must swipe to the left column titled YOUR BITCOIN ADDRESS (see <xref linkend="eclair-receive"/>), where she will see a square barcode (called a <emphasis>QR code</emphasis>) and a string of letters and numbers below that.</simpara>
<simpara>The QR code contains the same string of letters and numbers shown below it, in an easy to scan format. This way, Alice doesn&#8217;t have to type the Bitcoin address. In the screenshot (<xref linkend="eclair-receive"/>), we have purposely blurred both, to prevent readers from inadvertently sending bitcoin to this address.</simpara>
<figure id="eclair-receive"><title>Alice&#8217;s bitcoin address, shown in Eclair</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0204.png"/>
  </imageobject>
  <textobject><phrase>Eclair bitcoin address QR code</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara>Both Bitcoin addresses and QR codes contain error detection information that prevents any typing or scanning errors from producing a "wrong" Bitcoin address. If there is a mistake in the address, any Bitcoin wallet will notice the error and refuse to accept the Bitcoin address as valid.</simpara>
</note>
<simpara role="pagebreak-before">Alice can take her mobile device to the ATM and show it to the built-in camera, as shown in <xref linkend="bitcoin-atm-receive"/>. After inserting some cash into the slot, she will receive bitcoin in Eclair!</simpara>
<figure id="bitcoin-atm-receive"><title>Bitcoin ATM scans the QR code</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0205.png"/>
  </imageobject>
  <textobject><phrase>Bitcoin ATM scans the QR code</phrase></textobject>
</mediaobject>
</figure>
<simpara>Alice will see the transaction from the ATM in the TRANSACTION HISTORY tab of the Eclair wallet. Although Eclair will detect the bitcoin transaction in just a few seconds, it will take approximately one hour for the bitcoin transaction to be "confirmed" on the Bitcoin blockchain. As you can see in <xref linkend="eclair-tx1"/>, Alice&#8217;s Eclair wallet shows "6+ conf" below the transaction, indicating that the transaction has received the required minimum of six confirmations, and her funds are now ready to use.</simpara>
<tip>
<simpara>The number of confirmations on a transaction is the number of blocks mined since (and inclusive of) the block that contained that transaction. Six confirmations is best practice, but different Lightning wallets can consider a channel open after any number of confirmations. Some wallets even scale up the number of expected confirmations by the monetary value of the channel.</simpara>
</tip>
<simpara>Although in this example Alice used an ATM to acquire her first bitcoin, the same basic concepts would apply even if she used one of the other methods in <xref linkend="acquiring-bitcoin"/>. For example, if Alice wanted to sell a product or provide a professional service in exchange for bitcoin, her customers could scan the Bitcoin address with their wallets and pay her in bitcoin.</simpara>
<figure id="eclair-tx1"><title>Alice receives bitcoin</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0206.png"/>
  </imageobject>
  <textobject><phrase>Bitcoin transaction received</phrase></textobject>
</mediaobject>
</figure>
<simpara>Similarly, if she billed a client for a service offered over the internet, Alice could send an email or instant message with the Bitcoin address or the QR code to her client, and they could paste or scan the information into a Bitcoin wallet to pay her.</simpara>
<simpara>Alice could even print the QR code and affix it to a sign and display it publicly to receive tips. For example, she could have a QR code affixed to her guitar and receive tips while performing on the street!<footnote><simpara>It is generally not advisable to reuse the same Bitcoin address for multiple payments because all Bitcoin transactions are public.
A nosy person passing by could scan Alice&#8217;s QR code and see how many tips Alice has already received to this address on the Bitcoin blockchain.
Fortunately, the Lightning Network offers more private solutions to this, discussed later in the book!</simpara></footnote></simpara>
<simpara>Finally, if Alice bought bitcoin from a cryptocurrency exchange, she could (and should) "withdraw" the bitcoin by pasting her Bitcoin address into the exchange website. The exchange will then send the bitcoin to her address directly<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm>.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_from_bitcoin_to_lightning_network">
<title>From Bitcoin to Lightning Network</title>
<simpara><indexterm>
  <primary>Lightning wallet</primary><secondary>bridging of Bitcoin and Lightning networks</secondary>
</indexterm>
<indexterm>
  <primary>bridging of Bitcoin and Lightning networks</primary>
</indexterm>Alice&#8217;s bitcoin is now controlled by her Eclair wallet and has been recorded on the Bitcoin blockchain. At this point, Alice&#8217;s bitcoin is <emphasis>on-chain</emphasis>, meaning that the transaction has been broadcast to the entire Bitcoin network, verified by all Bitcoin nodes, and <emphasis>mined</emphasis> (recorded) onto the Bitcoin blockchain.</simpara>
<simpara>So far, the Eclair Mobile wallet has behaved only as a Bitcoin wallet, and Alice hasn&#8217;t used the Lightning Network features of Eclair. As is the case with many Lightning wallets, Eclair bridges Bitcoin and the Lightning Network by acting as both a Bitcoin wallet and a Lightning wallet.</simpara>
<simpara>Now, Alice is ready to start using the Lightning Network by taking her bitcoin off-chain to take advantage of the fast, cheap, and private payments that the Lightning Network offers.</simpara>
<section id="_lightning_network_channels">
<title>Lightning Network Channels</title>
<simpara><indexterm>
  <primary>Lightning Network channels</primary><secondary>basics</secondary>
</indexterm>
<indexterm>
  <primary>basics</primary>
</indexterm><indexterm>
  <primary>Lightning Network channels</primary><secondary>opening a channel</secondary>
</indexterm>
<indexterm>
  <primary>opening a channel</primary>
</indexterm><indexterm>
  <primary>Lightning wallet</primary><secondary>LN channels and</secondary>
</indexterm>
<indexterm>
  <primary>LN channels and</primary>
</indexterm>Swiping right, Alice accesses the LIGHTNING CHANNELS section of Eclair. Here she can manage the channels that will connect her wallet to the Lightning Network.</simpara>
<simpara>Let&#8217;s review the definition of an LN channel at this point, to make things a bit clearer. Firstly, the word "channel" is a metaphor for a <emphasis>financial relationship</emphasis> between Alice&#8217;s Lightning wallet and another Lightning wallet. We call it a channel because it is a means for Alice&#8217;s wallet and this other wallet to exchange many payments with each other on the Lightning Network (off-chain) without committing transactions to the Bitcoin blockchain (on-chain).</simpara>
<simpara><indexterm>
  <primary>channel peer</primary>
</indexterm>The wallet or <emphasis>node</emphasis> that Alice opens a channel to is called her <emphasis>channel peer</emphasis>. Once "opened," a channel can be used to send many payments back and forth between Alice&#8217;s wallet and her channel peer.</simpara>
<simpara>Furthermore, Alice&#8217;s channel peer can <emphasis>forward</emphasis> payments via other channels further into the Lightning Network. This way, Alice can <emphasis>route</emphasis> a payment to any wallet (e.g., Bob&#8217;s Lightning wallet) as long as Alice&#8217;s wallet can find a viable <emphasis>path</emphasis> made by hopping from channel to channel, all the way to Bob&#8217;s wallet.</simpara>
<tip>
<simpara>Not all channel peers are <emphasis>good</emphasis> peers for routing payments. Well-connected peers will be able to route payments over shorter paths to the destination, increasing the chance of success. Channel peers with ample funds will be able to route larger payments.</simpara>
</tip>
<simpara>In other words, Alice needs one or more channels that connect her to one or more other nodes on the Lightning Network. She doesn&#8217;t need a channel to connect her wallet directly to Bob&#8217;s Cafe in order to send Bob a payment, though she can choose to open a direct channel, too. Any node in the Lightning Network can be used for Alice&#8217;s first channel. The more well-connected a node is, the more people Alice can reach. In this example, since we want to also demonstrate payment routing, we won&#8217;t have Alice open a channel directly to Bob&#8217;s wallet. Instead, we will have Alice open a channel to a well-connected node and then later use that node to forward her payment, routing it through any other nodes as necessary to reach Bob.</simpara>
<simpara>At first, there are no open channels, so as we see in <xref linkend="eclair-channels"/>, the LIGHTNING CHANNELS tab displays an empty list. If you notice, in the bottom-right corner there is a plus symbol (+), which is a button to open a new channel.</simpara>
<figure id="eclair-channels"><title>LIGHTNING CHANNELS tab</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0207.png"/>
  </imageobject>
  <textobject><phrase>LIGHTNING CHANNELS tab</phrase></textobject>
</mediaobject>
</figure>
<simpara role="pagebreak-before">Alice presses the plus symbol and is presented with four possible ways to open a channel:</simpara>
<itemizedlist>
<listitem>
<simpara>
Paste a node URI
</simpara>
</listitem>
<listitem>
<simpara>
Scan a node URI
</simpara>
</listitem>
<listitem>
<simpara>
Random node
</simpara>
</listitem>
<listitem>
<simpara>
ACINQ node
</simpara>
</listitem>
</itemizedlist>
<simpara>A "node URI" is a Universal Resource Identifier (URI) that identifies a specific Lightning node. Alice can either paste such a URI from her clipboard or scan a QR code containing that same information. An example of a node URI is shown as a QR code in <xref linkend="node-URI-QR"/> and then as a text string.</simpara>
<figure id="node-URI-QR"><title>Node URI as a QR code</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0208.png" contentwidth="120"/>
  </imageobject>
  <textobject><phrase>Lightning node URI QR code</phrase></textobject>
</mediaobject>
</figure>
<formalpara id="node-URI-example"><title>node URI</title><para>
<screen>0237fefbe8626bf888de0cad8c73630e32746a22a2c4faa91c1d9877a3826e1174@1.ln.aantonop.com:9735</screen>
</para></formalpara>
<simpara>While Alice could select a specific Lightning node, or use the "Random node" option to have the Eclair wallet select a node at random, she will select the ACINQ Node option to connect to one of ACINQ&#8217;s well-connected Lightning nodes.</simpara>
<simpara>Choosing the ACINQ node will slightly reduce Alice&#8217;s privacy, because it will give ACINQ the ability to see all of Alice&#8217;s transactions. It will also create a single point of failure, since Alice will only have one channel, and if the ACINQ node is not available, Alice will not be able to make payments. To keep things simple at first, we will accept these trade-offs. In subsequent chapters, we will gradually learn how to gain more independence and make fewer trade-offs!</simpara>
<simpara>Alice selects ACINQ Node and is ready to open her first channel on the Lightning Network.<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
<section id="_opening_a_lightning_channel">
<title>Opening a Lightning Channel</title>
<simpara><indexterm>
  <primary>Lightning wallet</primary><secondary>opening a Lightning channel</secondary>
</indexterm>
<indexterm>
  <primary>opening a Lightning channel</primary>
</indexterm>When Alice selects a node to open a new channel, she is asked to select how much bitcoin she wants to allocate to this channel. In subsequent chapters, we will discuss the implications of these choices, but for now, Alice will allocate almost all her funds to the channel. Since she will have to pay transaction fees to open the channel, she will select an amount slightly less than her total balance.<footnote><simpara>The Eclair wallet doesn&#8217;t offer an option to automatically calculate the necessary fees and allocate the maximum amount of funds to a channel, so Alice has to calculate this herself.</simpara></footnote></simpara>
<simpara>Alice allocates 0.018 BTC of her 0.020 BTC total to her channel and accepts the default fee rate, as shown in <xref linkend="eclair-open-channel"/>.</simpara>
<figure id="eclair-open-channel"><title>Opening a Lightning channel</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0209.png"/>
  </imageobject>
  <textobject><phrase>Opening a Lightning Channel</phrase></textobject>
</mediaobject>
</figure>
<simpara>Once she clicks OPEN, her wallet constructs the special Bitcoin transaction that <indexterm>
  <primary>funding transaction</primary>
</indexterm>opens a Lightning channel, known as the <emphasis>funding transaction</emphasis>. The on-chain funding transaction is sent to the Bitcoin network for confirmation.</simpara>
<simpara>Alice now has to wait again (see <xref linkend="eclair-channel-waiting"/>) for the transaction to be recorded on the Bitcoin blockchain. As with the initial Bitcoin transaction that she used to acquire her bitcoin, she has to wait for six or more confirmations (approximately one hour).</simpara>
<figure id="eclair-channel-waiting"><title>Waiting for the funding transaction to open the channel</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0210.png"/>
  </imageobject>
  <textobject><phrase>Waiting for the Funding Transaction to Open the Channel</phrase></textobject>
</mediaobject>
</figure>
<simpara>Once the funding transaction is confirmed, Alice&#8217;s channel to the ACINQ node is open, funded, and ready, as shown in <xref linkend="eclair-channel-open"/>.</simpara>
<figure id="eclair-channel-open"><title>Channel is open</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0211.png"/>
  </imageobject>
  <textobject><phrase>Channel is Open</phrase></textobject>
</mediaobject>
</figure>
<tip>
<simpara>Did you notice that the channel amount seems to have changed? It hasn&#8217;t: the channel contains 0.018 BTC, but in the time between screenshots, the BTC exchange rate changed, so the USD value is different. You can choose to show balances in BTC or USD, but keep in mind that USD values are calculated in real time and will change<indexterm>
</indexterm>!<indexterm>
</indexterm></simpara>
</tip>
</section>
</section>
<section id="_buying_a_cup_of_coffee_using_the_lightning_network">
<title>Buying a Cup of Coffee Using the Lightning Network</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>example: buying a cup of coffee</secondary>
</indexterm>
<indexterm>
  <primary>example: buying a cup of coffee</primary>
</indexterm><indexterm>
  <primary>Lightning wallet</primary><secondary>example: buying a cup of coffee</secondary>
</indexterm>
<indexterm>
  <primary>example: buying a cup of coffee</primary>
</indexterm>Alice now has everything ready to start using the Lightning Network. As you can see, it took a bit of work and a bit of time waiting for confirmations. However, now subsequent actions are fast and easy. The Lightning Network enables payments without having to wait for confirmations, as funds get settled in seconds.</simpara>
<simpara>Alice grabs her mobile device and runs to Bob&#8217;s Cafe in her neighborhood. She is excited to try her new Lightning wallet and use it to buy something!</simpara>
<section id="_bob_8217_s_cafe">
<title>Bob&#8217;s Cafe</title>
<simpara>Bob has a simple point-of-sale (PoS) application for the use of any customer who wants to pay with bitcoin over the Lightning Network. As we will see in the next chapter, Bob uses the popular open source platform <emphasis>BTCPay Server</emphasis> which contains all the necessary components for an ecommerce or retail solution, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>
A Bitcoin node using the Bitcoin Core software
</simpara>
</listitem>
<listitem>
<simpara>
A Lightning node using the c-lightning software
</simpara>
</listitem>
<listitem>
<simpara>
A simple PoS application for a tablet
</simpara>
</listitem>
</itemizedlist>
<simpara>BTCPay Server makes it simple to install all the necessary software, upload pictures and product prices, and launch a store quickly.</simpara>
<simpara>On the counter at Bob&#8217;s Cafe, there is a tablet device showing what you see in <xref linkend="bob-cafe-posapp"/>.</simpara>
<figure id="bob-cafe-posapp"><title>Bob&#8217;s point-of-sale application</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0212.png"/>
  </imageobject>
  <textobject><phrase>Bob's Point-of-Sale Application</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_a_lightning_invoice">
<title>A Lightning Invoice</title>
<simpara><indexterm>
  <primary>Lightning invoices</primary>
</indexterm><indexterm>
  <primary>Lightning wallet</primary><secondary>invoices</secondary>
</indexterm>
<indexterm>
  <primary>invoices</primary>
</indexterm>Alice selects the Cafe Latte option from the screen and is presented with a <emphasis>Lightning invoice</emphasis> (also known as a "payment request"), as shown in <xref linkend="bob-cafe-invoice"/>.</simpara>
<figure id="bob-cafe-invoice"><title>Lightning invoice for Alice&#8217;s latte</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0213.png"/>
  </imageobject>
  <textobject><phrase>BTCPay Server Lightning invoice</phrase></textobject>
</mediaobject>
</figure>
<simpara role="pagebreak-before">To pay the invoice, Alice opens her Eclair wallet and selects the Send button (which looks like an up-facing arrow) under the TRANSACTION HISTORY tab, as shown in <xref linkend="alice-send-start"/>.</simpara>
<figure id="alice-send-start"><title>Alice selecting Send</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0214.png" contentwidth="300"/>
  </imageobject>
  <textobject><phrase>Lightning transaction send</phrase></textobject>
</mediaobject>
</figure>
<tip>
<simpara>The term "payment request" can refer to a Bitcoin payment request or a Lightning invoice, and the terms "invoice" and "payment request" are often used interchangeably. The correct technical term is "Lightning invoice," regardless of how it is named in the wallet.</simpara>
</tip>
<simpara>Alice selects the option to "scan a payment request," scans the QR code displayed on the screen of the tablet (see <xref linkend="bob-cafe-invoice"/>), and is prompted to confirm her payment, as shown in <xref linkend="alice-send-detail"/>.</simpara>
<simpara>Alice presses PAY, and a second later, Bob&#8217;s tablet shows a successful payment. Alice has completed her first LN payment! It was fast, inexpensive, and easy. Now she can enjoy her latte which was purchased using bitcoin through a payment system that is fast, cheap, and decentralized. From now on, Alice can simply select an item on Bob&#8217;s tablet screen, scan the QR code with her cell phone, click PAY, and be served a coffee, all within seconds and all without an on-chain transaction.</simpara>
<figure id="alice-send-detail"><title>Alice&#8217;s send confirmation</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0215.png" contentwidth="300"/>
  </imageobject>
  <textobject><phrase>Lightning transaction send confirmation</phrase></textobject>
</mediaobject>
</figure>
<simpara>Lightning payments are better for Bob, too. He&#8217;s confident that he will be paid for Alice&#8217;s latte without waiting for an on-chain confirmation. In the future, whenever Alice feels like drinking a coffee at Bob&#8217;s Cafe, she can choose to pay with bitcoin on the Bitcoin network or the Lightning Network. Which one do you think she will choose<indexterm>
</indexterm><indexterm>
</indexterm>?<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_conclusion_2">
<title>Conclusion</title>
<simpara>In this chapter, we followed Alice as she downloaded and installed her first Lightning wallet, acquired and transferred some bitcoin, opened her first Lightning channel, and bought a cup of coffee by making her first payment on the Lightning Network.<indexterm>
</indexterm> In the following chapters, we will look "under the covers" at how each component in the Lightning Network works and how Alice&#8217;s payment reached Bob&#8217;s Cafe.</simpara>
</section>
</chapter>
<chapter id="ch03_How_Lightning_Works">
<title>How the Lightning Network Works</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>mechanism of operation</secondary>
</indexterm>
<indexterm>
  <primary>mechanism of operation</primary>
</indexterm>Now that we&#8217;ve followed Alice as she set up a Lightning wallet and purchased a coffee from Bob, we&#8217;ll look under the hood and unpack the different components of the Lightning Network involved in that process.
This chapter will give a high-level overview and will not delve into all the technical details.
The goal is rather to help you to become aware of the most important concepts and building blocks of the Lightning Network.</simpara>
<simpara>If you have experience in computer science, cryptography, Bitcoin, and protocol development, then this chapter should be enough for you to be able to fill out the connecting details by yourself.
If you are less experienced, this chapter will give you a good enough overview so you have an easier time understanding the formal protocol specifications, known as BOLTs (Basis of Lightning Technology).
If you are a beginner, this chapter will help you better understand the technical chapters of the book.</simpara>
<simpara>If you need a refresher on the fundamentals of Bitcoin, you can find a summary review of the following topics in <xref linkend="bitcoin_fundamentals_review"/>:</simpara>
<itemizedlist>
<listitem>
<simpara>
Keys and addresses
</simpara>
</listitem>
<listitem>
<simpara>
Hash functions
</simpara>
</listitem>
<listitem>
<simpara>
Digital signatures
</simpara>
</listitem>
<listitem>
<simpara>
Transaction structure
</simpara>
</listitem>
<listitem>
<simpara>
Transaction inputs and outputs
</simpara>
</listitem>
<listitem>
<simpara>
Transaction chaining
</simpara>
</listitem>
<listitem>
<simpara>
Bitcoin Script
</simpara>
</listitem>
<listitem>
<simpara>
Multisignature addresses and scripts
</simpara>
</listitem>
<listitem>
<simpara>
Timelocks
</simpara>
</listitem>
<listitem>
<simpara>
Complex scripts
</simpara>
</listitem>
</itemizedlist>
<simpara>We&#8217;ll start with a one-sentence definition of what the Lightning Network is and break it down in the remainder of this chapter.</simpara>
<simpara>The Lightning Network is a peer-to-peer network of <emphasis>payment channels</emphasis> implemented as smart contracts on the <emphasis>Bitcoin blockchain</emphasis> as well as a communication protocol that defines how participants set up and execute these smart contracts.</simpara>
<section id="what_is_payment_channel">
<title>What Is a Payment Channel?</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>payment channel defined</secondary>
</indexterm>
<indexterm>
  <primary>payment channel defined</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>defined</secondary>
</indexterm>
<indexterm>
  <primary>defined</primary>
</indexterm>There are several ways to describe a payment channel, depending on the context. Let&#8217;s start at a high level and then add some more detail.</simpara>
<simpara>A payment channel is a <emphasis>financial relationship</emphasis> between two nodes on the Lightning Network, called the <emphasis>channel partners</emphasis>. The financial relationship allocates a <emphasis>balance of funds</emphasis> (denominated in millisatoshis), between the two channel partners.</simpara>
<simpara><indexterm>
  <primary>cryptographic protocol</primary>
</indexterm>The payment channel is managed by a <emphasis>cryptographic protocol</emphasis>, meaning a predefined process based on cryptography is used by the channel partners to redistribute the balance of the channel in favor of one or the other channel partner. The cryptographic protocol ensures that one channel partner cannot cheat the other, so that the partners do not need to trust each other.</simpara>
<simpara>The cryptographic protocol is established by the funding of a 2-of-2 <emphasis>multisignature address</emphasis> that requires the two channel partners to cooperate and prevents either channel partner from spending the funds unilaterally.</simpara>
<simpara>To summarize: a payment channel is a financial relationship between nodes, allocating funds from a multisignature address through a strictly defined cryptographic protocol.</simpara>
</section>
<section id="_payment_channel_basics">
<title>Payment Channel Basics</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>payment channel basics</secondary>
</indexterm>
<indexterm>
  <primary>payment channel basics</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>basics</secondary>
</indexterm>
<indexterm>
  <primary>basics</primary>
</indexterm>Underlying the payment channel is simply a 2-of-2 multisignature address on the Bitcoin blockchain, for which you hold one key and your channel partner holds the other key.</simpara>
<simpara>You and your channel partner negotiate a sequence of transactions that spend from this multisignature address. Instead of transmitting and recording these transactions on the Bitcoin blockchain, you both hold on to them, unspent.</simpara>
<simpara>The latest transaction in that sequence encodes the balance of the channel and defines how that balance is divided between you and your channel partner.</simpara>
<simpara>Thus, adding a new transaction to this sequence is equivalent to moving some part of the channel balance from one channel partner to the other, without the Bitcoin network being aware of it. As you negotiate each new transaction, changing the allocation of funds in the channel, you also revoke the previous transaction, so that neither party can regress to a previous state.</simpara>
<simpara>Each transaction in the sequence makes use of Bitcoin&#8217;s scripting language, and thus the negotiation of funds between you and your channel partner is managed by a Bitcoin smart contract.
The smart contract is set up to penalize a channel member if they try to submit a previously revoked state of the channel.</simpara>
<note>
<simpara>If you have an unpublished transaction from a 2-of-2 multisignature address that pays you part of the balance, then a signature from the other party ensures that you can independently publish this transaction anytime by adding your own signature.</simpara>
<simpara>The ability to hold a partially signed transaction, offline and unpublished, with the option to publish and own that balance at any time, is the basis of the Lightning Network.</simpara>
</note>
</section>
<section id="_routing_payments_across_channels">
<title>Routing Payments Across Channels</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>routing payments across channels</secondary>
</indexterm>
<indexterm>
  <primary>routing payments across channels</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>routing payments across channels</secondary>
</indexterm>
<indexterm>
  <primary>routing payments across channels</primary>
</indexterm>Once several participants have channels from one party to another, payments can also be "forwarded" from payment channel to payment channel by setting up a <emphasis>path</emphasis> across the network connecting several payment channels together.</simpara>
<simpara>For example, Alice can send money to Charlie if Alice has a channel with Bob and Bob has a channel with Charlie.</simpara>
<simpara>By the design of the Lightning Network, it is possible to extend the smart contracts that operate the channel so that Bob has no way of stealing the funds that are being forwarded through his channel.</simpara>
<simpara>In the same way that the smart contract protects the channel partners so they don&#8217;t need to trust each other, the entire network protects the participants so that they can forward payments without trusting any of the other participants.</simpara>
<simpara>Because the channels are constructed from multisignature addresses and the balance update transactions are presigned Bitcoin transactions, all the trust that is needed to operate the Lightning Network comes from the trust in the decentralized Bitcoin network!</simpara>
<simpara>The aforementioned innovations are certainly the major breakthroughs that allowed the creation of the Lightning Network.
However, the Lightning Network is so much more than the cryptographic protocols on top of the Bitcoin Script language.
It is a comprehensive communication protocol that allows peers to exchange Lightning messages to achieve the transfer of bitcoin.
The communication protocol defines how Lightning messages are encrypted and exchanged.</simpara>
<simpara>The Lightning Network also uses a gossip protocol to distribute public information about the channels (network topology) to all the participants.</simpara>
<simpara>Alice, for example, needs the network topology information to be aware of the channel between Bob and Charlie, so that she can construct a route to Charlie.</simpara>
<simpara>Last but not least, it is important to understand that the Lightning Network is nothing more than an application on top of Bitcoin, using Bitcoin transactions and Bitcoin Script. There is no "Lightning coin" or "Lightning blockchain."
Beyond all the technical primitives, the LN protocol is a creative way to get more benefits out of Bitcoin by allowing an arbitrary amount of instant payments with instant settlements without the necessity of having to trust anyone else but the Bitcoin network.</simpara>
</section>
<section id="_payment_channels">
<title>Payment Channels</title>
<simpara>As we saw in the previous chapter, Alice used her wallet software to create a payment channel between herself and another LN participant.</simpara>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>limitations on</secondary>
</indexterm>
<indexterm>
  <primary>limitations on</primary>
</indexterm>A channel is only limited by three things:</simpara>
<itemizedlist>
<listitem>
<simpara>
First, the time it takes for the internet to transfer the few hundred bytes of data that the protocol requires to move funds from one end of the channel to the other
</simpara>
</listitem>
<listitem>
<simpara>
Second, the capacity of the channel, meaning the amount of bitcoin that is committed to the channel when it is opened
</simpara>
</listitem>
<listitem>
<simpara>
Third, the maximum size limit of a Bitcoin transaction also limits the number of incomplete (in progress) routed payments that can be carried simultaneously over a channel
</simpara>
</listitem>
</itemizedlist>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>useful properties</secondary>
</indexterm>
<indexterm>
  <primary>useful properties</primary>
</indexterm>Payment channels have a few very interesting and useful properties:</simpara>
<itemizedlist>
<listitem>
<simpara>
Because the time to update a channel is primarily bound by the communication speed of the internet, making a payment on a payment channel can be almost instant.
</simpara>
</listitem>
<listitem>
<simpara>
If the channel is open, making a payment does not require the confirmation of Bitcoin blocks. In fact&#x2014;as long as you and your channel partner follow the protocol&#x2014;it does not require any interaction with the Bitcoin network or anyone else other than your channel partner.
</simpara>
</listitem>
<listitem>
<simpara>
The cryptographic protocol is constructed such that there is little to no trust needed between you and your channel partner. If your partner becomes unresponsive or tries to cheat you, you can ask the Bitcoin system to act as a "court," resolving the smart contract you and your partner have previously agreed upon.
</simpara>
</listitem>
<listitem>
<simpara>
Payments made in a payment channel are only known to you and your partner. In that sense, you gain privacy compared to Bitcoin, where every transaction is public.  Only the final balance, which is the aggregate of all payments in that channel, will become visible on the Bitcoin blockchain.
</simpara>
</listitem>
</itemizedlist>
<simpara role="pagebreak-before">Bitcoin was about five years old when talented developers first figured out how bidirectional, indefinite lifetime, routable payment channels could be constructed, and by now there are at least three different known methods.</simpara>
<simpara>This chapter will focus on the channel construction method first described in the <ulink url="https://lightning.network/lightning-network-paper.pdf">Lightning Network whitepaper</ulink> by Joseph Poon and Thaddeus Dryja in 2015. <indexterm>
  <primary>Poon-Dryja channels</primary>
</indexterm>These are known as <emphasis>Poon-Dryja</emphasis> channels, and are the channel construction method currently used in the Lightning Network.
The other two proposed methods are <emphasis>Duplex Micropayment</emphasis> channels, introduced by Christian Decker around the same time as the Poon-Dryja channels and <emphasis>eltoo</emphasis> channels, introduced in <ulink url="https://blockstream.com/eltoo.pdf">"eltoo: A Simple Layer2 Protocol for Bitcoin"</ulink>  by Christian Decker, Rusty Russel, and (coauthor of this book) Olaoluwa Osuntokun in 2018.</simpara>
<simpara>eltoo channels have some interesting properties and simplify the implementation of payment channels. However, eltoo channels require a change in the Bitcoin Script language and therefore cannot be implemented on the Bitcoin mainnet as of 2020.</simpara>
<section id="_multisignature_address">
<title>Multisignature Address</title>
<simpara><indexterm>
  <primary>multisignature addresses</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>multisignature addresses</secondary>
</indexterm>
<indexterm>
  <primary>multisignature addresses</primary>
</indexterm>Payment channels are built on top of 2-of-2 multisignature addresses.</simpara>
<simpara>In summary, a multisignature address is where bitcoin is locked so that it requires multiple signatures to unlock and spend. In a 2-of-2 multisignature address, as used in the Lightning Network, there are two participating signers and <emphasis>both</emphasis> need to sign to spend the funds.</simpara>
<simpara>Multisignature scripts and addresses are explained in more detail in <xref linkend="multisig"/>.</simpara>
</section>
<section id="_funding_transaction" role="pagebreak-before less_space">
<title>Funding Transaction</title>
<simpara><indexterm>
  <primary>funding transaction</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>funding transaction</secondary>
</indexterm>
<indexterm>
  <primary>funding transaction</primary>
</indexterm>The fundamental building block of a payment channel is a 2-of-2 multisignature address. One of the two channel partners will fund the payment channel by sending bitcoin to the multisignature address. This transaction is called the <emphasis>funding transaction</emphasis>, and is recorded on the Bitcoin blockchain.<footnote><simpara>While the original Lightning whitepaper described channels funded by both channel partners, the current specification, as of 2020, assumes that just one partner commits funds to the channel. As of May 2021, dual-funded lightning channels are experimental in the c-lightning LN implementation.</simpara></footnote></simpara>
<simpara>Even though the funding transaction is public, it is not obvious that it is a Lightning payment channel until it is closed unless the channel is publicly advertised. Channels are typically publicly announced by routing nodes that wish to forward payments. However, nonadvertised channels also exist, and are usually created by mobile nodes that don&#8217;t actively participate in routing. Furthermore, channel payments are still not visible to anyone other than the channel partners, nor is the distribution of the channel balance between them.</simpara>
<simpara><indexterm>
  <primary>channel capacity</primary>
</indexterm>The amount deposited in the multisignature address is called the <emphasis>channel capacity</emphasis> and sets the maximum amount that can be sent across the payment channel. However, since funds can be sent back and forth, the channel capacity is not the upper limit on how much value can flow across the channel. That&#8217;s because if the channel capacity is exhausted with payments in one direction, it can be used to send payments in the opposite direction again.</simpara>
<note>
<simpara>The funds sent to the multisignature address in the funding transaction are sometimes referred to as "locked in a Lightning channel." However, in practice, funds in a Lightning channel are not "locked" but rather "unleashed." Lightning channel funds are more liquid than funds on the Bitcoin blockchain, as they can be spent faster, cheaper, and more privately. There are some disadvantages to moving funds into the Lightning Network (such as the need to keep them in a "hot" wallet), but the idea of "locking funds" in Lightning is misleading.</simpara>
</note>
<section id="_example_of_a_poor_channel_opening_procedure">
<title>Example of a poor channel opening procedure</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>example of poor channel opening procedure</secondary>
</indexterm>
<indexterm>
  <primary>example of poor channel opening procedure</primary>
</indexterm>If you think carefully about 2-of-2 multisignature addresses, you will realize that putting your funds into such an address seems to carry some risk. What if your channel partner refuses to sign a transaction to release the funds? Are they stuck forever? Let&#8217;s now look at that scenario and how the LN protocol avoids it.</simpara>
<simpara>Alice and Bob want to create a payment channel. They each create a private/public key pair and then exchange public keys. Now, they can construct a multisignature 2-of-2 with the two public keys, forming the foundation for their payment channel.</simpara>
<simpara>Next, Alice constructs a Bitcoin transaction sending a few mBTC to the multisignature address created from Alice&#8217;s and Bob&#8217;s public keys. If Alice doesn&#8217;t take any additional steps and simply broadcasts this transaction, she has to trust that Bob will provide his signature to spend from the multisignature address. Bob, on the other hand, has the chance to blackmail Alice by withholding his signature and denying Alice access to her funds.</simpara>
<simpara>To prevent this, Alice will need to create an additional transaction that spends from the multisignature address, refunding her mBTC. Alice then has Bob sign the refund transaction <emphasis>before</emphasis> broadcasting her funding transaction to the Bitcoin network. This way, Alice can get a refund even if Bob disappears or fails to cooperate.</simpara>
<simpara>The "refund" transaction that protects Alice is the first of a class of transactions called <emphasis>commitment transactions</emphasis>, which we will examine in more detail next.</simpara>
</section>
</section>
<section id="_commitment_transaction">
<title>Commitment Transaction</title>
<simpara><indexterm>
  <primary>commitment transactions</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>commitment transaction</secondary>
</indexterm>
<indexterm>
  <primary>commitment transaction</primary>
</indexterm>A <emphasis>commitment transaction</emphasis> is a transaction that pays each channel partner their channel balance and ensures that the channel partners do not have to trust each other. By signing a commitment transaction, each channel partner "commits" to the current balance and gives the other channel partner the ability to get their funds back whenever they want.</simpara>
<simpara>By holding a signed commitment transaction, each channel partner can get their funds even without the cooperation of the other channel partner. This protects them against the other channel partner&#8217;s disappearance, refusal to cooperate, or attempt to cheat by violating the payment channel protocol.</simpara>
<simpara>The commitment transaction that Alice prepared in the previous example was a refund of her initial payment to the multisignature address. More generally, however, a commitment transaction splits the funds of the payment channel, paying the two channel partners according to the distribution (balance) they each hold. At first, Alice holds all the balance, so it is a simple refund. But as funds flow from Alice to Bob, they will exchange signatures for new commitment transactions that represent the new balance distribution, with some part of the funds paid to Alice and some paid to Bob.</simpara>
<simpara>Let&#8217;s assume that Alice opens a channel with a capacity of 100,000 satoshi with Bob.
Initially, Alice owns 100,000 satoshi, the entirety of the funds in the channel. Here&#8217;s how the payment channel protocol works:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Alice creates a new private/public key pair and informs Bob that she wishes to open a channel via the <literal>open_channel</literal> message (a message in the LN protocol).
</simpara>
</listitem>
<listitem>
<simpara>
Bob also creates a new private/public key pair and agrees to accept a channel from Alice, sending his public key to Alice via the <literal>accept_channel</literal> message.
</simpara>
</listitem>
<listitem>
<simpara>
Alice now creates a funding transaction from her wallet that sends 100k satoshi to the multisignature address with a locking script: <literal>2 &lt;PubKey Alice&gt; &lt;PubKey Bob&gt; 2 CHECKMULTISIG</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Alice does not yet broadcast this funding transaction but sends Bob the transaction ID in a <literal>funding_created</literal> message along with her signature for Bob&#8217;s commitment transaction.
</simpara>
</listitem>
<listitem>
<simpara>
Both Alice and Bob create their version of a commitment transaction. This transaction will spend from the funding transaction and send all the bitcoin back to an address controlled by Alice.
</simpara>
</listitem>
<listitem>
<simpara>
Alice and Bob don&#8217;t need to exchange these commitment transactions, since they each know how they are constructed and can build both independently (because they&#8217;ve agreed on a canonical ordering of the inputs and outputs). They only need to exchange signatures.
</simpara>
</listitem>
<listitem>
<simpara>
Bob provides a signature for Alice&#8217;s commitment transaction and sends this back to Alice via the <literal>funding_signed</literal> message.
</simpara>
</listitem>
<listitem>
<simpara>
Now that signatures have been exchanged, Alice will broadcast the funding transaction to the Bitcoin network.
</simpara>
</listitem>
</orderedlist>
<simpara>By following this protocol, Alice does not give up ownership of her 100k satoshi even though the funds are sent to a 2-of-2 multisignature address for which Alice controls only one key.
If Bob stops responding to Alice, she will be able to broadcast her commitment transaction and receive her funds back.
Her only costs are the fees for the on-chain transactions.
As long as she follows the protocol, this is her only risk when opening a channel.</simpara>
<simpara>After this initial exchange, commitment transactions are created each time the channel balance changes. In other words, each time a payment is sent between Alice and Bob, new commitment transactions are created and signatures are exchanged. Each new commitment transaction encodes the latest balance between Alice and Bob.</simpara>
<simpara>If Alice wants to send 30k satoshi to Bob, both would create a new version of their commitment transactions, which would now pay 70k satoshi to Alice and 30k satoshi to Bob. By encoding a new balance for Alice and Bob, the new commitment transactions are the means by which a payment is "sent" across the channel.</simpara>
<simpara>Now that we understand commitment transactions, let&#8217;s look at some of the more subtle details. You may notice that this protocol leaves a way for either Alice or Bob to cheat.</simpara>
</section>
<section id="_cheating_with_prior_state">
<title>Cheating with Prior State</title>
<simpara><indexterm>
  <primary>cheating</primary><secondary>with prior state</secondary>
</indexterm>
<indexterm>
  <primary>with prior state</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>cheating with prior state</secondary>
</indexterm>
<indexterm>
  <primary>cheating with prior state</primary>
</indexterm>How many commitment transactions does Alice hold after she pays 30k satoshi to Bob? She holds two: the original one paying her 100k satoshi and the more recent one, paying her 70k satoshi and Bob 30k satoshi.</simpara>
<simpara>In the channel protocol we have seen so far, nothing stops Alice from publishing a previous commitment transaction. A cheating Alice could publish the commitment transaction that grants her 100k satoshi.
Since that commitment transaction was signed by Bob, he can&#8217;t prevent Alice from transmitting it.</simpara>
<simpara>Some mechanism is needed to prevent Alice from publishing an old commitment transaction. Let&#8217;s now find out how this can be achieved and how it enables the Lightning Network to operate without requiring any trust between Alice and Bob.</simpara>
<simpara>Because Bitcoin is censorship resistant, no one can prevent someone from publishing an old commitment transaction. To prevent this form of cheating, commitment transactions are constructed so that if an old one is transmitted, the cheater can be punished. By making the penalty large enough, we create a strong incentive against cheating, and this makes the system secure.</simpara>
<simpara>The way the penalty works is by giving the cheated party an opportunity to claim the balance of the cheater. So if someone attempts to cheat by broadcasting an old commitment transaction, in which they are paid a higher balance than they are due, the other party can punish them by taking <emphasis>both</emphasis> their own balance and the balance of the cheater. The cheater loses everything.</simpara>
<tip>
<simpara>You might notice that if Alice drains her channel balance almost completely, she could then try cheating with little risk. Bob&#8217;s penalty wouldn&#8217;t be so painful if her channel balance is low. To prevent this, the Lightning protocol requires each channel partner to keep a minimum balance in the channel (called the <emphasis>reserve</emphasis>) so they always have "skin in the game."</simpara>
</tip>
<simpara>Let us go through the channel construction scenario again, adding a penalty mechanism to protect against cheating:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Alice creates a channel with Bob and puts 100k satoshi into it.
</simpara>
</listitem>
<listitem>
<simpara>
Alice sends 30k satoshi to Bob.
</simpara>
</listitem>
<listitem>
<simpara>
Alice tries to cheat Bob out of his earned 30k satoshi by publishing an old commitment transaction claiming the full 100k satoshi for herself.
</simpara>
</listitem>
<listitem>
<simpara>
Bob detects the fraud and punishes Alice by taking the full 100k satoshi for himself.
</simpara>
</listitem>
<listitem>
<simpara>
Bob ends up with 100k satoshi, gaining 70k satoshi for catching Alice cheating.
</simpara>
</listitem>
<listitem>
<simpara>
Alice ends up with 0 satoshi.
</simpara>
</listitem>
<listitem>
<simpara>
Trying to cheat Bob out of 30k satoshi, she loses the 70k satoshi she owned.
</simpara>
</listitem>
</orderedlist>
<simpara>With a strong penalty mechanism, Alice is not tempted to cheat by publishing an old commitment transaction because she risks losing her entire balance.</simpara>
<note>
<simpara>In Chapter 12 of <emphasis>Mastering Bitcoin</emphasis>, Andreas Antonopoulos (the coauthor of this book) states it as follows:
"A key characteristic of Bitcoin is that once a transaction is valid, it remains valid and does not expire. The only way to cancel a transaction is by double-spending its inputs with another transaction before it is mined."</simpara>
</note>
<simpara>Now that we understand <emphasis>why</emphasis> a penalty mechanism is needed and how it will prevent cheating, let&#8217;s see <emphasis>how</emphasis> it works in detail.</simpara>
<simpara>Usually, the commitment transaction has at least two outputs, paying each channel partner. <indexterm>
  <primary>revocation secret</primary>
</indexterm><indexterm>
  <primary>timelock delay</primary>
</indexterm>We change this to add a <emphasis>timelock delay</emphasis> and a <emphasis>revocation secret</emphasis> to one of the payments. The timelock prevents the owner of the output from spending it immediately once the commitment transaction is included in a block. The revocation secret allows either party to immediately spend that payment, bypassing the timelock.</simpara>
<simpara>So, in our example, Bob holds a commitment transaction that pays Alice <emphasis>immediately</emphasis>, but his own payment is delayed and revocable. Alice also holds a commitment transaction, but hers is the opposite: it pays Bob immediately but her own payment is delayed and revocable.</simpara>
<simpara>The two channel partners hold half of the revocation secret, so that neither one knows the whole secret. If they share their half, then the other channel partner has the full secret and can use it to exercise the revocation condition. When signing a new commitment transaction, each channel partner revokes the previous commitment by giving the other party their half of the revocation secret.</simpara>
<simpara>We will examine the revocation mechanism in more detail in <xref linkend="revocation"/>, where we will learn the details of how revocation secrets are constructed and used.</simpara>
<simpara>In simple terms, Alice signs Bob&#8217;s new commitment transaction only if Bob offers his half of the revocation secret for the previous commitment. Bob only signs Alice&#8217;s new commitment transaction if she gives him her half of the revocation secret from the previous commitment.</simpara>
<simpara>With each new commitment, they exchange the necessary "punishment" secret that allows them to effectively <emphasis>revoke</emphasis> the prior commitment transaction by making it unprofitable to transmit. Essentially, they destroy the ability to use old commitments as they sign the new ones. What we mean is that while it is still technically possible to use old commitments, the penalty mechanism makes it economically irrational to <span class="keep-together">do so</span>.</simpara>
<simpara>The timelock is set to a number of blocks up to 2,016 (approximately two weeks). If either channel partner publishes a commitment transaction without cooperating with the other partner, they will have to wait for that number of blocks (e.g., two weeks) to claim their balance. The other channel partner can claim their own balance at any time. Furthermore, if the commitment they published was previously revoked, the channel partner can <emphasis>also</emphasis> immediately claim the cheating party&#8217;s balance, bypassing the timelock and punishing the cheater.</simpara>
<simpara>The timelock is adjustable and can be negotiated between channel partners. Usually, it is longer for larger capacity channels, and shorter for smaller channels, to align the incentives with the value of the funds.</simpara>
<simpara>For every new update of the channel balance, new commitment transactions and new revocation secrets have to be created and saved. As long as a channel remains open, all revocation secrets <emphasis>ever created</emphasis> for the channel need to be kept because they might be needed in the future. Fortunately, the secrets are rather small and it is only the channel partners who need to keep them, not the entire network. Furthermore, due to a smart derivation mechanism used to derive revocation secrets, we only need to store the most recent secret, because previous secrets can be derived from it (see <xref linkend="revocation_secret_derivation"/>).</simpara>
<simpara>Nevertheless, managing and storing the revocation secrets is one of the more elaborate parts of Lightning nodes that require node operators to maintain backups.</simpara>
<note>
<simpara>Technologies such as watchtower services or changing the channel construction protocol to the eltoo protocol might be future strategies to mitigate these issues and reduce the need for revocation secrets, penalty transactions, and channel backups.</simpara>
</note>
<simpara>Alice can close the channel at any time if Bob does not respond, claiming her fair share of the balance.
After publishing the <emphasis>last</emphasis> commitment transaction on-chain, Alice has to wait for the timelock to expire before she can spend her funds from the commitment transaction. As we will see later, there is an easier way to close a channel without waiting, as long as Alice and Bob are both online and cooperate to close the channel with the correct balance allocation. But the commitment transactions stored by each channel partner act as a fail-safe, ensuring they do not lose funds if there is a problem with their channel partner.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
<section id="_announcing_the_channel">
<title>Announcing the Channel</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>announcing the channel</secondary>
</indexterm>
<indexterm>
  <primary>announcing the channel</primary>
</indexterm><indexterm>
  <primary>public channel, announcing</primary>
</indexterm>Channel partners can agree to announce their channel to the whole Lightning Network, making it a <emphasis>public channel</emphasis>. To announce the channel, they use the Lightning Network&#8217;s gossip protocol to tell other nodes about the existence, capacity, and fees of the channel.</simpara>
<simpara>Announcing channels publicly allows other nodes to use them for payment routing, thereby also generating routing fees for the channel partners.</simpara>
<simpara><indexterm>
  <primary>unannounced channels</primary>
</indexterm>By contrast, the channel partners may decide not to announce the channel, making it an <emphasis>unannounced</emphasis> channel.</simpara>
<note>
<simpara>You may hear the term "private channel" used to describe an unannounced channel. We avoid using that term because it is misleading and creates a false sense of privacy. Although an unannounced channel will not be known to others while it is in use, its existence and capacity will be revealed when the channel closes because those details will be visible on-chain in the final settlement transaction. Its existence can also leak in a variety of other ways, so we avoid calling it "private."</simpara>
</note>
<simpara>Unannounced channels are still used to route payments but only by the nodes that are aware of their existence, or given "routing hints" about a path that includes an unannounced channel.</simpara>
<simpara>When a channel and its capacity are publicly announced using the gossip protocol, the announcement can also include information about the channel (metadata), such as its routing fees and timelock duration.</simpara>
<simpara>When new nodes join the Lightning Network, they collect the channel announcements propagated via the gossip protocol from their peers, building an internal map of the Lightning Network. This map can then be used to find paths for payments, connecting channels together end-to-end.</simpara>
</section>
<section id="_closing_the_channel">
<title>Closing the Channel</title>
<simpara><indexterm>
  <primary>closing the channel</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>closing the channel</secondary>
</indexterm>
<indexterm>
  <primary>closing the channel</primary>
</indexterm>The best way to close a channel is&#8230;to not close it!
Opening and closing channels requires an on-chain transaction, which will incur transaction fees.
So it&#8217;s best to keep channels open as long as possible.
You can keep using your channel to make and forward payments, as long as you have sufficient capacity on your end of the channel.
But even if you send all the balance to the other end of the channel, you can then use the channel to receive payments from your channel partner.
This concept of using a channel in one direction and then using it in the opposite direction is called "rebalancing," and we will examine it in more detail in another chapter.
By rebalancing a channel, it can be kept open almost indefinitely and used for an essentially unlimited number of payments.</simpara>
<simpara>However, sometimes closing a channel is desirable or necessary. For example:</simpara>
<itemizedlist>
<listitem>
<simpara>
You want to reduce the balance held on your Lightning channels for security reasons and want to send funds to "cold storage."
</simpara>
</listitem>
<listitem>
<simpara>
Your channel partner becomes unresponsive for a long time and you cannot use the channel anymore.
</simpara>
</listitem>
<listitem>
<simpara>
The channel is not being used often because your channel partner is not a well-connected node, so you want to use the funds for another channel with a better-connected node.
</simpara>
</listitem>
<listitem>
<simpara>
Your channel partner has breached the protocol either due to a software bug or on purpose, forcing you to close the channel to protect your funds.
</simpara>
</listitem>
</itemizedlist>
<simpara>There are three ways to close a payment channel:</simpara>
<itemizedlist>
<listitem>
<simpara>
Mutual close (the good way)
</simpara>
</listitem>
<listitem>
<simpara>
Force close (the bad way)
</simpara>
</listitem>
<listitem>
<simpara>
Protocol breach (the ugly way)
</simpara>
</listitem>
</itemizedlist>
<simpara>Each of these methods is useful for different circumstances, which we will explore in the next sections of this chapter.
For example, if your channel partner is offline, you will not be able to follow "the good way" because a mutual close cannot be done without a cooperating partner.
Usually, your LN software will automatically select the best closing mechanism available under the circumstances.</simpara>
<section id="_mutual_close_the_good_way">
<title>Mutual close (the good way)</title>
<simpara><indexterm>
  <primary>closing the channel</primary><secondary>mutual close</secondary>
</indexterm>
<indexterm>
  <primary>mutual close</primary>
</indexterm><indexterm>
  <primary>mutual close</primary>
</indexterm>Mutual close is when both channel partners agree to close a channel, and is the preferred method of channel closure.</simpara>
<simpara>When you decide that you want to close a channel, your LN node will inform your channel partner about your intention.
Now both your node and the channel partner&#8217;s node work together to close the channel.
No new routing attempts will be accepted from either channel partner, and any ongoing routing attempts will be settled or removed after they time out.
Finalizing the routing attempts takes time, so a mutual close can also take some time to complete.</simpara>
<simpara><indexterm>
  <primary>closing transactions</primary>
</indexterm>Once there are no pending routing attempts, the nodes cooperate to prepare a <emphasis>closing transaction</emphasis>.
This transaction is similar to the commitment transaction: it encodes the last balance of the channel, but the outputs are NOT encumbered with a timelock.</simpara>
<simpara>The on-chain transaction fees for the closing transaction are paid by the channel partner who opened the channel and not by the one who initiated the closing procedure.
Using the on-chain fee estimator, the channel partners agree on the appropriate fee and both sign the closing transaction.</simpara>
<simpara>Once the closing transaction is broadcast and confirmed by the Bitcoin network, the channel is effectively closed and each channel partner has received their share of the channel balance.
Despite the waiting time, a mutual close is typically faster than a force close.</simpara>
</section>
<section id="_force_close_the_bad_way">
<title>Force close (the bad way)</title>
<simpara><indexterm>
  <primary>closing the channel</primary><secondary>force close</secondary>
</indexterm>
<indexterm>
  <primary>force close</primary>
</indexterm><indexterm>
  <primary>force close</primary>
</indexterm>A force close is when one channel partner attempts to close a channel without the other channel partner&#8217;s consent.</simpara>
<simpara>This usually happens when one of the channel partners is unreachable, so a mutual close is not possible.
In this case, you would initiate a force close to unilaterally close the channel and "free" the funds.</simpara>
<simpara>To initiate a force close, you can simply publish the last commitment transaction your node has.
After all, that&#8217;s what commitment transactions are for&#x2014;they offer a guarantee that you don&#8217;t need to trust your channel partner to retrieve the balance of your channel.</simpara>
<simpara><indexterm>
  <primary>commitment transactions</primary><secondary>during force close</secondary>
</indexterm>
<indexterm>
  <primary>during force close</primary>
</indexterm>Once you broadcast the last commitment transaction to the Bitcoin network and it is confirmed, it will create two spendable outputs, one for you and one for your partner.
As we discussed previously, the Bitcoin network has no way of knowing if this was the most recent commitment transaction or an old one which was published to steal from your partner.
Hence this commitment transaction will give a slight advantage to your partner.
The partner who initiated the force close will have their output encumbered by a timelock, and the other partner&#8217;s output will be spendable immediately.
In the case that you broadcasted an earlier commitment transaction, the timelock delay gives your partner the opportunity to dispute the transaction using the revocation secret and punish you for cheating.</simpara>
<simpara>When publishing a commitment transaction during a force close, the on-chain fees will be higher than a mutual close for several reasons:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
When the commitment transaction was negotiated, the channel partners didn&#8217;t know how much the on-chain fees would be at the future time the transaction would be broadcast. Since the fees cannot be changed without changing the outputs of the commitment transaction (which needs both signatures), and since the force close happens when a channel partner is not available to sign, the protocol developers decided to be very generous with the fee rate included in the commitment transactions. It can be up to five times higher than the fee estimators suggest at the time the commitment transaction is negotiated.
</simpara>
</listitem>
<listitem>
<simpara>
The commitment transaction includes additional outputs for any pending routing attempts hash time-locked contracts (HTLCs), which makes the commitment transaction larger (in terms of bytes) than a mutual close transaction. Larger transactions incur more fees.
</simpara>
</listitem>
<listitem>
<simpara>
Any pending routing attempts will have to be resolved on-chain, causing additional on-chain transactions.
</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Hash time-locked contracts (HTLCs) will be covered in detail in <xref linkend="htlcs"/>.
For now, assume that these are payments that are routed across the Lightning Network, rather than payments made directly between the two channel partners.
These HTLCs are carried as additional outputs in the commitment transactions, thereby increasing the transaction size and on-chain fees.</simpara>
</note>
<simpara>In general, a force close is not recommended unless absolutely necessary.
Your funds will be locked for a longer time and the person who opened the channel will have to pay higher fees.
Furthermore, you might have to pay on-chain fees to abort or settle routing attempts even if you didn&#8217;t open the channel.</simpara>
<simpara>If the channel partner is known to you, you might consider contacting that individual or company to inquire why their Lightning node is down and request that they restart it so that you can achieve a mutual close of the channel.</simpara>
<simpara>You should consider a force close only as the last resort.</simpara>
</section>
<section id="_protocol_breach_the_ugly_way">
<title>Protocol breach (the ugly way)</title>
<simpara><indexterm>
  <primary>closing the channel</primary><secondary>protocol breach</secondary>
</indexterm>
<indexterm>
  <primary>protocol breach</primary>
</indexterm><indexterm>
  <primary>protocol breach</primary>
</indexterm>A protocol breach is when your channel partner tries to cheat you, whether deliberately or not, by publishing an outdated commitment transaction to the Bitcoin blockchain, essentially initiating a (dishonest) force close from their side.</simpara>
<simpara>Your node must be online and watching new blocks and transactions on the Bitcoin blockchain to detect this.</simpara>
<simpara>Because your channel partner&#8217;s payment will be encumbered by a timelock, your node has some time to act to detect a protocol breach and publish a <indexterm>
  <primary>punishment transaction</primary>
</indexterm><emphasis>punishment transaction</emphasis> before the timelock expires.</simpara>
<simpara>If you successfully detect the protocol breach and enforce the penalty, you will receive all of the funds in the channel, including your channel partner&#8217;s funds.</simpara>
<simpara>In this scenario, the channel closure will be rather fast.
You will have to pay on-chain fees to publish the punishment transaction, but your node can set these fees according to the fee estimation and not overpay.
You will generally want to pay higher fees to guarantee confirmation as soon as possible.
However, because you will eventually receive all of the cheater&#8217;s funds, it is essentially the cheater who will be paying for this transaction.</simpara>
<simpara>If you fail to detect the protocol breach and the timelock expires, you will receive only the funds allocated to you by the commitment transaction your partner published.
Any funds you received after this will have been stolen by your partner.
If there is any balance allocated to you, you will have to pay on-chain fees to collect that balance.</simpara>
<simpara>As with a force close, all pending routing attempts will also have to be resolved in the commitment transaction.</simpara>
<simpara>A protocol breach can be executed faster than a mutual close because you do not wait to negotiate a close with your partner, and faster than a force close because you do not need to wait for your timelock to expire.</simpara>
<simpara>Game theory predicts that cheating is not an appealing strategy because it is easy to detect a cheater, and the cheater risks losing <emphasis>all</emphasis> of their funds while only standing to gain what they had in an earlier state.
Furthermore, as the Lightning Network matures, and watchtowers become widely available, cheaters will be detectable by a third party even if the cheated channel partner is offline.</simpara>
<simpara>Hence, we do not recommend cheating.
We do, however, recommend that anyone catching a cheater punish them by taking their funds.</simpara>
<simpara>So, how do you catch a cheat or a protocol breach in your day-to-day activities?
You do so by running software that monitors the public Bitcoin blockchain for on-chain transactions that correspond to any commitment transactions for any of your channels.
This software is one of three types:</simpara>
<itemizedlist>
<listitem>
<simpara>
A properly maintained Lightning node, running 24/7
</simpara>
</listitem>
<listitem>
<simpara>
A single-purpose watchtower node that you run to watch your channels
</simpara>
</listitem>
<listitem>
<simpara>
A third-party watchtower node that you pay to watch your channels
</simpara>
</listitem>
</itemizedlist>
<simpara>Remember that the commitment transaction has a timeout period specified in a given number of blocks, up to a maximum of 2,016 blocks.
As long as you run your Lightning node once before the timeout period is reached, it will catch all cheating attempts.
It is not advisable to take this kind of risk; it is important to keep a well-maintained node running continuously (see <xref linkend="continuous_operation"/>).<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
</section>
<section id="_invoices">
<title>Invoices</title>
<simpara><indexterm>
  <primary>Lightning invoices</primary>
</indexterm>Most payments on the Lightning Network start with an invoice, generated by the recipient of the payment. In our previous example, Bob creates an invoice to request a payment from Alice.</simpara>
<note>
<simpara>There is a way to send an unsolicited payment without an invoice, using a workaround in the protocol called <literal>keysend</literal>. We will examine this in  <xref linkend="keysend"/>.</simpara>
</note>
<simpara>An invoice is a simple payment instruction containing information such as a unique payment identifier (called a payment hash), a recipient, an amount, and an optional text description.</simpara>
<simpara><indexterm>
  <primary>payment hash</primary>
</indexterm>The most important part of the invoice is the payment hash, which allows the payment to travel across multiple channels in an <emphasis>atomic</emphasis> way. Atomic, in computer science, means any action or state change that is either completed successfully or not at all&#x2014;there is no possibility of an intermediate state or partial action. In the Lightning Network, that means that the payment either travels the whole path or fails completely. It cannot be partially completed such that an intermediate node on the path can receive the payment and keep it.
There is no such thing as a "partial payment" or "partly successful payment."</simpara>
<simpara>Invoices are not communicated over the Lightning Network. Instead, they are communicated "out of band," using any other communication mechanism. This is similar to how Bitcoin addresses are communicated to senders outside the Bitcoin network: as a QR code, over email, or a text message. For example, Bob can present a Lightning invoice to Alice as a QR code, via email, or through any other message channel.</simpara>
<simpara>Invoices are usually encoded either as a long <emphasis>bech32</emphasis>-encoded string or as a QR code, to be scanned by a smartphone Lightning wallet. The invoice contains the amount of bitcoin that is requested and a signature of the recipient. The sender uses the signature to extract the public key (also known as the node ID) of the recipient so that the sender knows where to send the payment.</simpara>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>addresses versus invoices</secondary>
</indexterm>
<indexterm>
  <primary>addresses versus invoices</primary>
</indexterm>Did you notice how this contrasts with Bitcoin and how different terms are used? In Bitcoin, the recipient passes an address to the sender. In Lightning, the recipient creates an invoice and sends an invoice to the sender. In Bitcoin, the sender sends funds to an address. In Lightning, the sender pays an invoice and the payment gets routed to the recipient. Bitcoin is based on the concept of an "address," and Lightning is a payment network based on the concept of an "invoice." In Bitcoin, we create a "transaction," whereas in Lightning we send a "payment."</simpara>
<section id="_payment_hash_and_preimage">
<title>Payment Hash and Preimage</title>
<simpara><indexterm>
  <primary>Lightning invoices</primary><secondary>payment hash/preimage</secondary>
</indexterm>
<indexterm>
  <primary>payment hash/preimage</primary>
</indexterm>The most important part of the invoice is the <emphasis>payment hash</emphasis>. When constructing the invoice, Bob will make a payment hash as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<indexterm>
  <primary>payment secret (preimage)</primary>
</indexterm><indexterm>
  <primary>preimage (payment secret)</primary>
</indexterm>Bob chooses a random number <emphasis>r</emphasis>. This random number is called the <emphasis>preimage</emphasis> or <emphasis>payment secret</emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
Bob uses SHA-256 to calculate the hash <emphasis>H</emphasis> of <emphasis>r</emphasis> called the <emphasis>payment hash</emphasis>: <br/><emphasis>H</emphasis> = SHA-256(<emphasis>r</emphasis>).
</simpara>
</listitem>
</orderedlist>
<note>
<simpara>The term <emphasis>preimage</emphasis> comes from mathematics. In any function <span class="keep-together"><em>y</em> = <em>f</em>(<em>x</em>)</span>, the set of inputs that produce a certain value <emphasis>y</emphasis> are called the preimage of <emphasis>y</emphasis>. In this case, the function is the SHA-256 hash algorithm, and any value <emphasis>r</emphasis> that produces the hash <emphasis>H</emphasis> is called a preimage.</simpara>
</note>
<simpara>There is no known way to find the inverse of SHA-256 (i.e., compute a preimage from a hash). Only Bob knows the value <emphasis>r</emphasis>, so it is Bob&#8217;s secret. But once Bob reveals <emphasis>r</emphasis>, anyone who has the hash <emphasis>H</emphasis> can check that <emphasis>r</emphasis> is the correct secret, by calculating SHA-256(<emphasis>r</emphasis>) and seeing that it matches <emphasis>H</emphasis>.</simpara>
<simpara>The payment process of the Lightning Network is only secure if <emphasis>r</emphasis> is chosen completely randomly and is not predictable. This security relies on the fact that hash functions cannot be inverted or feasibly brute-forced and, therefore, no one can find <emphasis>r</emphasis> from <emphasis>H</emphasis>.</simpara>
</section>
<section id="_additional_metadata">
<title>Additional Metadata</title>
<simpara><indexterm>
  <primary>Lightning invoices</primary><secondary>additional metadata</secondary>
</indexterm>
<indexterm>
  <primary>additional metadata</primary>
</indexterm><indexterm>
  <primary>metadata, Lightning invoices and</primary>
</indexterm>Invoices can optionally include other useful metadata such as a short text description. If a user has several invoices to pay, the user can read the description and be reminded of what the invoice is about.</simpara>
<simpara><indexterm>
  <primary>routing hints</primary>
</indexterm>The invoice can also include some <emphasis>routing hints</emphasis>, which allow the sender to use unannounced channels to construct a route to the recipient. Routing hints can also be used to suggest public channels, for example, channels known by the recipient to have enough inbound capacity to route the payment.</simpara>
<simpara>In case the sender&#8217;s Lightning node is unable to send the payment over the Lightning Network, invoices can optionally include an on-chain Bitcoin address as a fallback.</simpara>
<note>
<simpara>While it is always possible to "fall back" to an on-chain Bitcoin transaction, it is actually better to open a new channel to the recipient instead. If you have to incur on-chain fees to make a payment, you might as well incur those fees to open a channel and make the payment over Lightning. After the payment is made, you are left with an open channel that has liquidity on the recipient&#8217;s end and can be used to route payments back to your Lightning node in the future. One on-chain transaction gives you a payment and a channel for future use.</simpara>
</note>
<simpara>Lightning invoices contain an expiry date. Since the recipient must keep the preimage <emphasis>r</emphasis> for every invoice issued, it is useful to have invoices expire so that these preimages do not need to be kept forever. Once an invoice expires or is paid, the recipient can discard the preimage.<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_delivering_the_payment">
<title>Delivering the Payment</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>delivering payment</secondary>
</indexterm>
<indexterm>
  <primary>delivering payment</primary>
</indexterm><indexterm>
  <primary>payment</primary><secondary>delivering</secondary>
</indexterm>
<indexterm>
  <primary>delivering</primary>
</indexterm><indexterm>
  <primary>payment delivery</primary>
</indexterm>We have seen how the recipient creates an invoice that contains a payment hash. This payment hash will be used to move the payment across a series of payment channels, from sender to recipient, even if they do not have a direct payment channel between them.</simpara>
<simpara>In the next few sections, we will dive into the ideas and methods that are being used to deliver a payment over the Lightning Network and use all the concepts we have presented so far.</simpara>
<simpara>First, let&#8217;s look at the Lightning Network&#8217;s communication protocol.</simpara>
<section id="_the_peer_to_peer_gossip_protocol">
<title>The Peer-to-Peer Gossip Protocol</title>
<simpara><indexterm>
  <primary>gossip protocol</primary><secondary>peer-to-peer</secondary>
</indexterm>
<indexterm>
  <primary>peer-to-peer</primary>
</indexterm><indexterm>
  <primary>payment delivery</primary><secondary>peer-to-peer gossip protocol</secondary>
</indexterm>
<indexterm>
  <primary>peer-to-peer gossip protocol</primary>
</indexterm><indexterm>
  <primary>peer-to-peer gossip protocol</primary>
</indexterm>As we mentioned previously, when a payment channel is constructed, the channel partners have the option of making it public, announcing its existence and details to the whole Lightning Network.</simpara>
<simpara>Channel announcements are communicated over a peer-to-peer <emphasis>gossip protocol</emphasis>. A peer-to-peer protocol is a communications protocol in which each node connects to a random selection of other nodes in the network, usually over TCP/IP. Each of the nodes that are directly connected (over TCP/IP) to your node are called your <emphasis>peers</emphasis>. Your node, in turn, is one of their peers. Keep in mind that when we say that your node is connected to other peers, we don&#8217;t mean that you have payment channels, but only that you are connected via the gossip protocol.</simpara>
<simpara><indexterm>
  <primary>channel_announcement message</primary><secondary>peer-to-peer gossip protocol and</secondary>
</indexterm>
<indexterm>
  <primary>peer-to-peer gossip protocol and</primary>
</indexterm>After opening a channel, a node may choose to send out an announcement of the channel via the <literal>channel_announcement</literal> message to its peers.
Every peer validates the information from the <literal>channel_announcement</literal> message and verifies that the funding transaction is confirmed on the Bitcoin blockchain.
After verification, the node will forward the gossip message to its own peers, and they will forward it to their peers, and so on, spreading the announcement across the entire network.
To avoid excessive communication, the channel announcement is only forwarded by each node if it has not already forwarded that announcement previously.</simpara>
<simpara><indexterm>
  <primary>node_announcement message</primary><secondary>peer-to-peer gossip protocol and</secondary>
</indexterm>
<indexterm>
  <primary>peer-to-peer gossip protocol and</primary>
</indexterm>The gossip protocol is also used to announce information about known nodes with the <literal>node_announcement</literal> message.
For this message to be forwarded, a node has to have at least one public channel announced on the gossip protocol, again to avoid excessive communication traffic.</simpara>
<simpara>Payment channels have various metadata that are useful for other participants of the network.
This metadata is mainly used for making routing decisions.
<indexterm>
  <primary>channel_update message</primary>
</indexterm>Because nodes might occasionally change the metadata of their channels, this information is shared in a <literal>channel_update</literal> message.
These messages will only be forwarded approximately four times a day (per channel) to prevent excessive communication.
The gossip protocol also has a variety of queries and messages to initially synchronize a node with the view of the network or to update the node&#8217;s view after being offline for a while.</simpara>
<simpara>A major challenge for the participants of the Lightning Network is that the topology information being shared by the gossip protocol is only partial.
For example, the capacity of the payment channels is shared on the gossip protocol via the <phrase role=".keep-together"><literal>channel_announcement</literal></phrase> message.
However, this information is not as useful as the actual distribution of the capacity in terms of the local balance between the two channel partners.
A node can only forward as much bitcoin as it actually owns (local balance) within that channel.</simpara>
<simpara>Although the Lightning Network could have been designed to share balance information of channels and a precise topology, this has not been done for several reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>
To protect the privacy of the users, it does not shout out every financial transaction and payment. Channel balance updates would reveal that a payment has moved across the channel. This information could be correlated to reveal all payment sources and destinations.
</simpara>
</listitem>
<listitem>
<simpara>
To scale the amount of payments that can be conducted with the Lightning Network. Remember that the Lightning Network was created in the first place because notifying every participant about every payment does not scale well. Thus, the Lightning Network cannot be designed in a way that shares channel balance updates among participants.
</simpara>
</listitem>
<listitem>
<simpara>
The Lightning Network is a dynamic system. It changes constantly and frequently. Nodes are being added, other nodes are being turned off, balances change, etc. Even if everything is always communicated, the information will be valid only for a short amount of time. As a matter of fact, information is often outdated by the time it is received.
</simpara>
</listitem>
</itemizedlist>
<simpara>We will examine the details of the gossip protocol in a later chapter.</simpara>
<simpara>For now, it is only important to know that the gossip protocol exists and that it is used to share topology information of the Lightning Network.
This topology information is crucial for delivering payments through the network of payment channels.<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
<section id="_pathfinding_and_routing">
<title>Pathfinding and Routing</title>
<simpara><indexterm>
  <primary>pathfinding</primary>
</indexterm><indexterm>
  <primary>payment delivery</primary><secondary>pathfinding and routing</secondary>
</indexterm>
<indexterm>
  <primary>pathfinding and routing</primary>
</indexterm><indexterm>
  <primary>routing</primary><secondary>payment delivery and</secondary>
</indexterm>
<indexterm>
  <primary>payment delivery and</primary>
</indexterm>Payments on the Lightning Network are forwarded along a <emphasis>path</emphasis> made of channels linking one participant to another, from the payment source to the payment destination. The process of finding a path from source to destination is called <emphasis>pathfinding</emphasis>. The process of using that path to make the payment is called <emphasis>routing</emphasis>.</simpara>
<note>
<simpara>A frequent criticism of the Lightning Network is that routing is not solved, or even that it is an "unsolvable" problem. In fact, routing is trivial. Pathfinding, on the other hand, is a difficult problem. The two terms are often confused and need to be clearly defined to identify which problem we are attempting to solve.</simpara>
</note>
<simpara>As we will see next, the Lightning Network currently uses a <emphasis>source-based</emphasis> protocol for pathfinding and an <emphasis>onion-routed</emphasis> protocol for routing payments. Source-based means that the sender of the payment has to find a path through the network to the intended destination. Onion-routed means that the elements of the path are layered (like an onion), with each layer encrypted so that it can only be seen by one node at a time. We will discuss onion routing in the next section.<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_source_based_pathfinding">
<title>Source-Based Pathfinding</title>
<simpara><indexterm>
  <primary>pathfinding</primary><secondary>source-based</secondary>
</indexterm>
<indexterm>
  <primary>source-based</primary>
</indexterm><indexterm>
  <primary>payment delivery</primary><secondary>source-based pathfinding</secondary>
</indexterm>
<indexterm>
  <primary>source-based pathfinding</primary>
</indexterm><indexterm>
  <primary>source-based pathfinding</primary>
</indexterm>If we knew the exact channel balances of every channel, we could easily compute a payment path using any of the standard pathfinding algorithms taught in any computer science class. This could even be solved in a way that optimizes the fees paid to nodes for forwarding the payment.</simpara>
<simpara>However, the balance information of all channels is not and cannot be known to all participants of the network. We need more innovative pathfinding strategies.</simpara>
<simpara>With only partial information about the network topology, pathfinding is a real challenge, and active research is still being conducted into this part of the Lightning Network. The fact that the pathfinding problem is not "fully solved" in the Lightning Network is a major point of criticism toward the technology.</simpara>
<note>
<simpara>One common criticism of pathfinding in the Lightning Network is that it is unsolvable because it is equivalent to the NP-complete <indexterm>
  <primary>traveling salesperson problem</primary>
</indexterm><emphasis>traveling salesperson problem</emphasis> (TSP), a fundamental problem in computational complexity theory. In fact, pathfinding in Lightning is not equivalent to TSP and falls into a different class of problems. We successfully solve these types of problems (pathfinding in graphs with incomplete information) every time we ask Google to give us driving directions with traffic avoidance. We also successfully solve this problem every time we route a payment on the Lightning Network.</simpara>
</note>
<simpara>Pathfinding and routing can be implemented in a number of different ways, and multiple pathfinding and routing algorithms can coexist on the Lightning Network, just as multiple pathfinding and routing algorithms exist on the internet. Source-based pathfinding is one of many possible solutions and is successful at the current scale of the Lightning Network.</simpara>
<simpara>The pathfinding strategy currently implemented by Lightning nodes is to iteratively try paths until one is found that has enough liquidity to forward the payment. This is an iterative process of trial and error, until success is achieved or no path is found. The algorithm currently does not necessarily result in the path with the lowest fees. While this is not optimal and certainly can be improved, even this simplistic strategy works quite well.</simpara>
<simpara>This "probing" is done by the Lightning node or wallet and is not directly seen by the user.
The user might only realize that probing is taking place if the payment does not complete instantly.</simpara>
<note>
<simpara>On the internet, we use the Internet Protocol and an IP forwarding algorithm to forward internet packages from the sender to the destination. While these protocols have the nice property of allowing internet hosts to collaboratively find a path for information flow through the internet, we cannot reuse and adopt this protocol for forwarding payments on the Lightning Network. Unlike the internet, Lightning payments have to be <emphasis>atomic</emphasis>, and channel balances have to remain <emphasis>private</emphasis>. Furthermore, the channel capacity in Lightning changes frequently, unlike the internet where connection capacity is relatively static. These constraints require novel <span class="keep-together">strategies</span>.</simpara>
</note>
<simpara>Of course, pathfinding is trivial if we want to pay our direct channel partner and we have enough balance on our side of the channel to do so. In all other cases, our node uses information from the gossip protocol to do pathfinding. This includes currently known public payment channels, known nodes, known topology (how known nodes are connected), known channel capacities, and known fee policies set by the node owners.</simpara>
<section id="_onion_routing">
<title>Onion Routing</title>
<simpara><indexterm>
  <primary>onion routing protocol</primary>
</indexterm><indexterm>
  <primary>pathfinding</primary><secondary>onion routing protocol</secondary>
</indexterm>
<indexterm>
  <primary>onion routing protocol</primary>
</indexterm><indexterm>
  <primary>payment delivery</primary><secondary>onion routing protocol</secondary>
</indexterm>
<indexterm>
  <primary>onion routing protocol</primary>
</indexterm>The Lightning Network uses an <emphasis>onion routing protocol</emphasis> similar to the famous Tor (The Onion Router) network.
<indexterm>
  <primary>SPHINX Mix Format</primary>
</indexterm>The onion routing protocol used in Lightning is called the <emphasis>SPHINX Mix Format</emphasis>,<footnote><simpara>George Danezis and Ian Goldberg, "Sphinx: A Compact and Provably Secure Mix Format," in <emphasis>IEEE Symposium on Security and Privacy</emphasis> (New York: IEEE, 2009), 269–282.</simpara></footnote> which will be explained in detail in a later chapter.</simpara>
<note>
<simpara>Lightning&#8217;s onion routing SPHINX Mix Format is only similar to the Tor network routing in concept, but both the protocol and the implementation are entirely different from those used in the Tor network.</simpara>
</note>
<simpara>A payment package used for routing is called an "onion."<footnote><simpara>The term "onion" was originally used by the Tor project. Moreover, the Tor network is also called the Onion network and the project uses an onion as its logo. The top-level domain name used by Tor services on the internet is <emphasis>onion</emphasis>.</simpara></footnote></simpara>
<simpara>Let&#8217;s use the onion analogy to follow a routed payment. On its route from payment sender (payer) to payment destination (payee) the onion is passed from node to node along the path. The sender constructs the entire onion, from the center out. First, the sender creates the payment information for the (final) recipient of the payment and encrypts it with a layer of encryption that only the recipient can decrypt. Then, the sender wraps that layer with instructions for the node in the path <emphasis>immediately preceding the final recipient</emphasis> and encrypts with a layer that only that node can decrypt.</simpara>
<simpara>The layers are built up with instructions, working backward until the entire path is encoded in layers. The sender then gives the complete onion to the first node in the path, which can only read the outermost layer. Each node peels a layer, finds instructions inside revealing the next node in the path, and passes the onion on. As each node peels one layer, it can&#8217;t read the rest of the onion. All it knows is where the onion has just come from and where it is going next, without any indication as to who is the original sender or the ultimate recipient.</simpara>
<simpara>This continues until the onion reaches the payment destination (payee). Then, the destination node opens the onion and finds there are no further layers to decrypt and can read the payment information inside.</simpara>
<note>
<simpara>Unlike a real onion, when peeling each layer, the nodes add some encrypted padding to keep the size of the onion the same for the next node. As we will see, this makes it impossible for any of the intermediate nodes to know anything about the size (length) of the path, how many nodes are involved in routing, how many nodes preceded them, or how many follow. This increases privacy by preventing trivial traffic analysis attacks.</simpara>
</note>
<simpara>The onion routing protocol used in Lightning has the following properties:</simpara>
<itemizedlist>
<listitem>
<simpara>
An intermediary node can only see on which channel it received an onion and on which channel to forward the onion. This means that no routing node can know who initiated the payment and to whom the payment is destined. This is the most important property, which results in a high degree of privacy.
</simpara>
</listitem>
<listitem>
<simpara>
The onions are small enough to fit into a single TCP/IP packet and even a link layer (e.g., Ethernet) frame. This makes traffic analysis of the payments significantly more difficult, increasing privacy further.
</simpara>
</listitem>
<listitem>
<simpara>
The onions are constructed such that they will always have the same length independent of the position of the processing node along the path. As each layer is "peeled," the onion is padded with encrypted "junk" data to keep the size of the onion the same. This prevents intermediary nodes from knowing their position in the path.
</simpara>
</listitem>
<listitem>
<simpara>
Onions have an HMAC (hash-based message authentication code) at each layer so that manipulations of onions are prevented and practically impossible.
</simpara>
</listitem>
<listitem>
<simpara>
Onions can have up to around 26 hops, or onion layers if you prefer. This allows for sufficiently long paths. The precise path length available depends on the amount of bytes allocated to the routing payload at each hop.
</simpara>
</listitem>
<listitem>
<simpara>
The encryption of the onion for every hop uses different ephemeral encryption keys. Should a key (in particular, the private key of a node) leak at some point in time, an attacker cannot decrypt them. In simpler terms, keys are never reused in order to achieve more security.
</simpara>
</listitem>
<listitem>
<simpara>
Errors can be sent back from the erring node to the original sender, using the same onion-routed protocol. Error onions are indistinguishable from routing onions to external observers and intermediary nodes. Error routing enables the trial-and-error "probing" method used to find a path that has sufficient capacity to successfully route a payment.
</simpara>
</listitem>
</itemizedlist>
<simpara>Onion routing will be examined in detail in <xref linkend="onion_routing"/>.</simpara>
</section>
<section id="_payment_forwarding_algorithm">
<title>Payment Forwarding Algorithm</title>
<simpara><indexterm>
  <primary>payment delivery</primary><secondary>payment forwarding algorithm</secondary>
</indexterm>
<indexterm>
  <primary>payment forwarding algorithm</primary>
</indexterm>Once the sender of a payment finds a possible path across the network and constructs an onion, the payment is forwarded by each node in the path. Each node processes one layer of the onion and forwards it to the next node in the path.</simpara>
<simpara><indexterm>
  <primary>update_add_htlc message</primary>
</indexterm>Each intermediary node receives a Lightning message called <literal>update_add_htlc</literal> with a payment hash and an onion. The intermediary node executes a series of steps, called the <emphasis>payment forwarding algorithm</emphasis>:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
The node decrypts the outer layer of the onion and checks the message&#8217;s integrity.
</simpara>
</listitem>
<listitem>
<simpara>
It confirms that it can fulfill the routing hints, based on the channel fees and available capacity on the outgoing channel.
</simpara>
</listitem>
<listitem>
<simpara>
It works with its channel partner on the incoming channel to update the channel state.
</simpara>
</listitem>
<listitem>
<simpara>
It adds some padding to the end of the onion to keep it at a constant length since it removed some data from the beginning.
</simpara>
</listitem>
<listitem>
<simpara>
It follows the routing hints to forward the modified onion package on its outgoing payment channel by also sending an <literal>update_add_htlc</literal> message which includes the same payment hash and the onion.
</simpara>
</listitem>
<listitem>
<simpara>
It works with its channel partner on the outgoing channel to update the channel state.
</simpara>
</listitem>
</orderedlist>
<simpara>Of course, these steps are interrupted and aborted if an error is detected, and an error message is sent back to the originator of the <literal>update_add_htlc</literal> message. The error message is also formatted as an onion and sent backward on the incoming channel.</simpara>
<simpara>As the error propagates backward on each channel along the path, the channel partners remove the pending payment, rolling back the payment in the opposite way from which it started.</simpara>
<simpara>While the likelihood for a payment failure is high if it does not settle quickly, a node should never initiate another payment attempt along a different path before the onion returns with an error. The sender would pay twice if both payment attempts eventually succeeded.<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_peer_to_peer_communication_encryption">
<title>Peer-to-Peer Communication Encryption</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>peer-to-peer communication encryption</secondary>
</indexterm>
<indexterm>
  <primary>peer-to-peer communication encryption</primary>
</indexterm><indexterm>
  <primary>peer-to-peer communication encryption</primary>
</indexterm>The LN protocol is mainly a peer-to-peer protocol between its participants. As we saw in previous sections, there are two overlapping functions in the network, forming two logical networks that together are <emphasis>the Lightning Network</emphasis>:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
A broad peer-to-peer network that uses a gossip protocol to propagate topology information, where peers randomly connect to each other. Peers don&#8217;t necessarily have payment channels between them, so they are not always channel partners.
</simpara>
</listitem>
<listitem>
<simpara>
A network of payment channels between channel partners. Channel partners also gossip about topology, meaning they are peer nodes in the gossip protocol.
</simpara>
</listitem>
</orderedlist>
<simpara>All communication between peers is sent via messages called <emphasis>Lightning messages</emphasis>. These messages are all encrypted, using a cryptographic communications framework <indexterm>
  <primary>Noise Protocol Framework</primary><secondary>Lightning messages and</secondary>
</indexterm>
<indexterm>
  <primary>Lightning messages and</primary>
</indexterm>called the <emphasis>Noise Protocol Framework</emphasis>. The Noise Protocol Framework allows the construction of cryptographic communication protocols that offer authentication, encryption, forward secrecy, and identity privacy. The Noise Protocol Framework is also used in a number of popular end-to-end encrypted communications systems such as WhatsApp, WireGuard, and I2P. More information can be found <ulink url="https://noiseprotocol.org">at the Noise Protocol Framework website</ulink>.</simpara>
<simpara>The use of the Noise Protocol Framework in the Lightning Network ensures that every message on the network is both authenticated and encrypted, increasing the privacy of the network and its resistance to traffic analysis, deep packet inspection, and eavesdropping. However, as a side effect, this makes protocol development and testing a bit tricky because one can&#8217;t simply observe the network with a packet capture or network analysis tool such as Wireshark. Instead, developers have to use specialized plug-ins that decrypt the protocol from the perspective of one node, such as the <ulink url="https://github.com/nayutaco/lightning-dissector"><emphasis>lightning dissector</emphasis></ulink>, a Wireshark plug-in.</simpara>
</section>
<section id="_thoughts_about_trust">
<title>Thoughts About Trust</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>trust and</secondary>
</indexterm>
<indexterm>
  <primary>trust and</primary>
</indexterm><indexterm>
  <primary>trust, Lightning Network and</primary>
</indexterm>As long as a person follows the protocol and has their node secured, there is no major risk of losing funds when participating in the Lightning Network.
However, there is the cost of paying on-chain fees when opening a channel.
Any cost should come with a corresponding benefit.
In our case, the reward for Alice for bearing the cost of opening a channel is that Alice can send and, after moving some of the coins to the other end of the channel, receive payments of bitcoin on the Lightning Network at any time, and that she can earn fees in bitcoin by forwarding payments for other people.
Alice knows that in theory Bob can close the channel immediately after opening, resulting in on-chain closing fees for Alice.
Alice will need to have a small amount of trust in Bob.
Alice has been to Bob&#8217;s Cafe and clearly Bob is interested in selling her coffee, so Alice can trust Bob in this sense.
There are mutual benefits to both Alice and Bob.
Alice decides that the reward is enough for her to take on the cost of the on-chain fee for creating a channel to Bob.
In contrast, Alice will not open a channel to someone unknown who just uninvited sent her an email asking her to open a new channel.</simpara>
</section>
<section id="_comparison_with_bitcoin">
<title>Comparison with Bitcoin</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary>
</indexterm>While the Lightning Network is built on top of Bitcoin and inherits many of its features and properties, there are important differences that users of both networks need to be aware of.</simpara>
<simpara>Some of these differences are differences in terminology. There are also architectural differences and differences in the user experience. In the next few sections, we will examine the differences and similarities, explain the terminology, and adjust our expectations.</simpara>
<section id="_addresses_versus_invoices_transactions_versus_payments">
<title>Addresses Versus Invoices, Transactions Versus Payments</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>addresses versus invoices</secondary>
</indexterm>
<indexterm>
  <primary>addresses versus invoices</primary>
</indexterm><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>transactions versus payments</secondary>
</indexterm>
<indexterm>
  <primary>transactions versus payments</primary>
</indexterm>In a typical payment using Bitcoin, a user receives a Bitcoin address (e.g., scanning a QR code on a web page, or receiving it in an instant message or email from a friend). They then use their Bitcoin wallet to create a transaction to send funds to this address.</simpara>
<simpara>On the Lightning Network, the recipient of a payment creates an invoice. A Lightning invoice can be seen as analogous to a Bitcoin address. The intended recipient gives the Lightning invoice to the sender as a QR code or character string, just like a Bitcoin address.</simpara>
<simpara>The sender uses their Lightning wallet to pay the invoice, copying the invoice text or scanning the invoice QR code. A Lightning payment is analogous to a Bitcoin "transaction."</simpara>
<simpara>There are some differences in the user experience, however. A Bitcoin address is <emphasis>reusable</emphasis>. Bitcoin addresses never expire, and if the owner of the address still holds the keys, the funds held within are always accessible. A sender can send any amount of bitcoin to a previously used address, and a recipient can post a single static address to receive many payments. While this goes against the best practices for privacy reasons, it is technically possible and in fact quite common.</simpara>
<simpara>In Lightning, however, each invoice can only be used once for a specific payment amount. You cannot pay more or less, you cannot use an invoice again, and the invoice has an expiry time built in. In Lightning, a recipient has to generate a new invoice for each payment, specifying the payment amount in advance. There is an exception to this, a mechanism called <emphasis>keysend</emphasis>, which we will examine in <xref linkend="keysend"/>.</simpara>
</section>
<section id="_selecting_outputs_versus_finding_a_path">
<title>Selecting Outputs Versus Finding a Path</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>selecting outputs versus finding a path</secondary>
</indexterm>
<indexterm>
  <primary>selecting outputs versus finding a path</primary>
</indexterm><indexterm>
  <primary>unspent transaction outputs (UTXOs)</primary>
</indexterm><indexterm>
  <primary>UTXOs (unspent transaction outputs)</primary>
</indexterm>To make a payment on the Bitcoin network, a sender needs to consume one or more unspent transaction outputs (UTXOs).
If a user has multiple UTXOs, they (or rather their wallet) will need to select which UTXO(s) to send.
For instance, a user making a payment of 1 BTC can use a single output with value 1 BTC, two outputs with value 0.25 BTC and 0.75 BTC, or four outputs with value 0.25 BTC each.</simpara>
<simpara>On Lightning, payments do not require inputs to be consumed. Instead, each payment results in an update of the channel balance, redistributing it between the two channel partners. The sender experiences this as "moving" the channel balance from their end of a channel to the other end, to their channel partner. Lightning payments use a series of channels to route from sender to recipient. Each of these channels must have sufficient capacity to route the payment.</simpara>
<simpara>Because many possible channels and paths can be used to make a payment, the Lightning user&#8217;s choice of channels and paths is somewhat analogous to the Bitcoin user&#8217;s choice of UTXO.</simpara>
<simpara>With technologies such as atomic multipath payments (AMP) and multipart payments (MPP), which we will review in subsequent chapters, several Lightning paths can be aggregated into a single atomic payment, just like several Bitcoin UTXOs can be aggregated into a single atomic Bitcoin transaction.</simpara>
</section>
<section id="_change_outputs_on_bitcoin_versus_no_change_on_lightning">
<title>Change Outputs on Bitcoin Versus No Change on Lightning</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>change outputs</secondary>
</indexterm>
<indexterm>
  <primary>change outputs</primary>
</indexterm>To make a payment on the Bitcoin network, the sender needs to consume one or more unspent transaction outputs (UTXOs). UTXOs can only be spent in full; they cannot be divided and partially spent. So if a user wishes to spend 0.8 BTC, but only has a 1 BTC UTXO, they need to spend the entire 1 BTC UTXO by sending 0.8 BTC to the recipient and 0.2 BTC back to themselves as change. The 0.2 BTC change payment creates a new UTXO called a "change output."</simpara>
<simpara>On Lightning, the funding transaction spends some Bitcoin UTXO, creating a multisignature UTXO to open the channel. Once the bitcoin is locked within that channel, portions of it can be sent back and forth within the channel, without the need to create any change.
This is because the channel partners simply update the channel balance and only create a new UTXO when the channel is eventually closed using the channel closing transaction.</simpara>
</section>
<section id="_mining_fees_versus_routing_fees">
<title>Mining Fees Versus Routing Fees</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>mining fees versus routing fees</secondary>
</indexterm>
<indexterm>
  <primary>mining fees versus routing fees</primary>
</indexterm>On the Bitcoin network, users pay fees to miners to have their transactions included in a block.
These fees are paid to the miner who mines that particular block.
The amount of the fee is based on the <emphasis>size</emphasis> of the transaction in <emphasis>bytes</emphasis> that the transaction is using in a block, as well as how quickly the user wants that transaction mined.
Because miners will typically mine the most profitable transactions first, a user who wants their transaction mined immediately will pay a <emphasis>higher</emphasis> fee per byte, while a user who is not in a hurry will pay a <emphasis>lower</emphasis> fee per byte.</simpara>
<simpara>On the Lightning Network, users pay fees to other (intermediary node) users to route payments through their channels.
To route a payment, an intermediary node will have to move funds in two or more channels they own, as well as transmit the data for the sender&#8217;s payment. Typically, the routing user will charge the sender based on the <emphasis>value</emphasis> of the payment, having established a minimum <indexterm>
  <primary>base fee</primary>
</indexterm><emphasis>base fee</emphasis> (a flat fee for each payment) and a <indexterm>
  <primary>fee rate</primary>
</indexterm><emphasis>fee rate</emphasis> (a prorated fee proportional to the value of the payment). Higher value payments will thus cost more to route, and a market for liquidity is formed, where different users charge different fees for routing through their channels.</simpara>
</section>
<section id="_varying_fees_depending_on_traffic_versus_announced_fees">
<title>Varying Fees Depending on Traffic Versus Announced Fees</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>varying fees versus announced fees</secondary>
</indexterm>
<indexterm>
  <primary>varying fees versus announced fees</primary>
</indexterm>On the Bitcoin network, miners are profit seeking and will typically include as many transactions in a block as possible, while staying within the block capacity called the <indexterm>
  <primary>block weight</primary>
</indexterm><emphasis>block weight</emphasis>.</simpara>
<simpara><indexterm>
  <primary>transaction weight</primary>
</indexterm>If there are more transactions in the queue (called the <emphasis>mempool</emphasis>) than can fit in a block, they will begin by mining the transactions that pay the highest fees per unit (bytes) of <emphasis>transaction weight</emphasis>.
Thus, when there are many transactions in the queue, users have to pay a higher fee to be included in the next block, or they have to wait until there are fewer transactions in the queue.
This naturally leads to the emergence of a fee market where users pay based on how urgently they need their transaction included in the next block.</simpara>
<simpara>The scarce resource on the Bitcoin network is the space in the blocks. Bitcoin users compete for block space, and the Bitcoin fee market is based on available block space. The scarce resources in the Lightning Network are the <indexterm>
  <primary>channel connectivity</primary>
</indexterm><indexterm>
  <primary>channel liquidity</primary>
</indexterm><emphasis>channel liquidity</emphasis> (capacity of funds available for routing in channels) and <emphasis>channel connectivity</emphasis> (how many well-connected nodes channels can reach). Lightning users compete for capacity <span class="keep-together">and connectivity</span>; therefore, the Lightning fee market is driven by capacity and <span class="keep-together">connectivity</span>.</simpara>
<simpara>On the Lightning Network, users are paying fees to the users routing their payments. Routing a payment, in economic terms, is nothing more than providing and assigning capacity to the sender. Naturally, routers who charge lower fees for the same capacity will be more attractive to route through. Thus a fee market exists where routers are in competition with each other over the fees they charge to route payments through their channels.</simpara>
</section>
<section id="_public_bitcoin_transactions_versus_private_lightning_payments">
<title>Public Bitcoin Transactions Versus Private Lightning Payments</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>public Bitcoin transactions versus private Lightning payments</secondary>
</indexterm>
<indexterm>
  <primary>public Bitcoin transactions versus private Lightning payments</primary>
</indexterm>On the Bitcoin network, every transaction is publicly visible on the Bitcoin blockchain. While the addresses involved are pseudonymous and are not typically tied to an identity, they are still seen and validated by every other user on the network.
In addition, blockchain surveillance companies collect and analyze this data en masse and sell it to interested parties such as private firms, governments, and intelligence agencies.</simpara>
<simpara>LN payments, on the other hand, are almost completely private. Typically, only the sender and the recipient are fully aware of the source, destination, and amount transacted in a particular payment. Furthermore, the receiver may not even know the source of the payment. Because payments are onion routed, the users who route the payment are only aware of the amount of the payment, and they can determine neither the source nor the destination.</simpara>
<simpara>In summary, Bitcoin transactions are broadcast publicly and stored forever. Lightning payments are executed between a few selected peers, and information about them is privately stored only until the channel is closed. Creating mass surveillance and analysis tools equivalent to those used on Bitcoin will be much harder on Lightning.</simpara>
</section>
<section id="_waiting_for_confirmations_versus_instant_settlement">
<title>Waiting for Confirmations Versus Instant Settlement</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>waiting for confirmations versus instant settlement</secondary>
</indexterm>
<indexterm>
  <primary>waiting for confirmations versus instant settlement</primary>
</indexterm>On the Bitcoin network, transactions are only settled once they have been included in a block, in which case they are said to be "confirmed" in that block. As more blocks are mined, the transaction acquires more "confirmations" and is considered more secure.</simpara>
<simpara>On the Lightning Network, confirmations only matter for opening and closing channels on-chain. Once a funding transaction has reached a suitable number of confirmations (e.g., 3), the channel partners consider the channel open. Because the bitcoin in the channel is secured by a smart contract that manages that channel, payments settle <emphasis>instantly</emphasis> once received by the final recipient.
In practical terms, instant settlement means that payments take only a few seconds to execute and settle. As with Bitcoin, Lightning payments are not reversible.</simpara>
<simpara>Finally, when the channel is closed, a transaction is made on the Bitcoin network; once that transaction is confirmed, the channel is considered closed.</simpara>
</section>
<section id="_sending_arbitrary_amounts_versus_capacity_restrictions">
<title>Sending Arbitrary Amounts Versus Capacity Restrictions</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>sending arbitrary amounts versus capacity restrictions</secondary>
</indexterm>
<indexterm>
  <primary>sending arbitrary amounts versus capacity restrictions</primary>
</indexterm>On the Bitcoin network, a user can send any amount of bitcoin that they own to another user, without capacity restrictions. A single transaction can theoretically send up to 21 million bitcoin as a payment.</simpara>
<simpara>On the Lightning Network, a user can only send as much bitcoin as currently exists on their side of a particular channel to a channel partner. For instance, if a user owns one channel with 0.4 BTC on their side, and another channel with 0.2 BTC on their side, then the maximum they can send with one payment is 0.4 BTC. This is true regardless of how much bitcoin the user currently has in their Bitcoin wallet.</simpara>
<simpara><indexterm>
  <primary>multipart payments (MPP)</primary>
</indexterm>Multipart payments (MPP) is a feature which, in the preceding example, allows the user to combine both their 0.4 BTC and 0.2 BTC channels to send a maximum of 0.6 BTC with one payment. MPPs are currently being tested across the Lightning Network and are expected to be widely available and used by the time this book is completed. For more detail on MPP, see <xref linkend="mpp"/>.</simpara>
<simpara>If the payment is routed, every routing node along the routing path must have channels with capacity at least the same as the payment amount being routed. This must hold true for every single channel that the payment is routed through. The capacity of the lowest-capacity channel in a path sets the upper limit for the capacity of the entire path.</simpara>
<simpara>Hence, capacity and connectivity are critical and scarce resources in the Lightning Network.</simpara>
</section>
<section id="_incentives_for_large_value_payment_versus_small_value_payments">
<title>Incentives for Large Value Payment Versus Small Value Payments</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>fee structures</secondary>
</indexterm>
<indexterm>
  <primary>fee structures</primary>
</indexterm><indexterm>
  <primary>fees</primary><secondary>Bitcoin–Lightning Network comparisons</secondary>
</indexterm>
<indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary>
</indexterm>The fee structure in Bitcoin is independent of the transaction value.
A $1 million transaction has the same fee as a $1 transaction on Bitcoin, assuming a similar transaction size, in bytes (more specifically "virtual" bytes after SegWit [Segregated Witness protocol]).
In Lightning the fee is a fixed-base fee plus a percentage of the transaction value.
Therefore, in Lightning the payment fee increases with payment value.
These opposing fee structures create different incentives and lead to different usage in regards to transaction value.
A transaction of greater value will be cheaper on Bitcoin; hence, users will prefer Bitcoin for large value transactions. Similarly, on the other end of the scale, users will prefer Lightning for small value transactions.</simpara>
</section>
<section id="_using_the_blockchain_as_a_ledger_versus_as_a_court_system">
<title>Using the Blockchain as a Ledger Versus as a Court System</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>blockchain: ledger versus court system</secondary>
</indexterm>
<indexterm>
  <primary>blockchain: ledger versus court system</primary>
</indexterm>On the Bitcoin network, every transaction is eventually recorded in a block on the blockchain.
The blockchain thus forms a complete history of every transaction since Bitcoin&#8217;s creation, and a way to fully audit every bitcoin in existence.
Once a transaction is included in the blockchain, it is final.
Thus, no disputes can arise and it is unambiguous how much bitcoin is controlled by a particular address at a particular point in the blockchain.</simpara>
<simpara>On the Lightning Network, the balance in a channel at a particular time is known only to the two channel partners, and is only made visible to the rest of the network when the channel is closed.
When the channel is closed, the final balance of the channel is submitted to the Bitcoin blockchain, and each partner receives their share of the bitcoin in that channel.
For instance, if the opening balance was 1 BTC paid by Alice, and Alice made a payment of 0.3 BTC to Bob, then the final balance of the channel is 0.7 BTC for Alice and 0.3 BTC for Bob.
If Alice tries to cheat by submitting the opening state of the channel to the Bitcoin blockchain, with 1 BTC for Alice and 0 BTC for Bob, then Bob can retaliate by submitting the true final state of the channel, as well as creating a penalty transaction that gives him all the bitcoin in the channel.
For the Lightning Network, the Bitcoin blockchain acts as a court system.
Like a robotic judge, Bitcoin records the initial and final balances of each channel and approves penalties if one of the parties tries to cheat.</simpara>
</section>
<section id="_offline_versus_online_asynchronous_versus_synchronous">
<title>Offline Versus Online, Asynchronous Versus Synchronous</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>minimum payment size: satoshi versus millisatoshi</secondary>
</indexterm>
<indexterm>
  <primary>minimum payment size: satoshi versus millisatoshi</primary>
</indexterm><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>payment activity: asynchronous versus synchronous</secondary>
</indexterm>
<indexterm>
  <primary>payment activity: asynchronous versus synchronous</primary>
</indexterm><indexterm>
  <primary>millisatoshi</primary>
</indexterm><indexterm>
  <primary>satoshi</primary>
</indexterm>When a Bitcoin user sends funds to a destination address, they do not need to know anything about the recipient. The recipient might be offline or online, and no interaction between sender and recipient is needed. The interaction is between sender and the Bitcoin blockchain. Receiving bitcoin on the Bitcoin blockchain is a <emphasis>passive</emphasis> and <emphasis>asynchronous</emphasis> activity that does not require any interaction by the recipient or for the recipient to be online at any time. Bitcoin addresses can even be generated offline and are never "registered" with the Bitcoin network. Only spending bitcoin requires interaction.</simpara>
<simpara>In Lightning, the recipient must be online to complete the payment before it expires.
The recipient must run a node or have someone that runs a node on their behalf (a third-party custodian). To be precise, both nodes, the sender&#8217;s and the recipient&#8217;s, must be online at the time of payment and must coordinate. Receiving a Lightning payment is an <emphasis>active</emphasis> and <emphasis>synchronous</emphasis> activity between sender and recipient, without the participation of most of the Lightning Network or the Bitcoin network (except for the intermediary routing nodes, if any).</simpara>
<simpara>The synchronous and always-online nature of the Lightning Network is probably the biggest difference in the user experience, and this often confounds users who are accustomed to Bitcoin.</simpara>
</section>
<section id="_satoshis_versus_millisatoshis">
<title>Satoshis Versus Millisatoshis</title>
<simpara>On the Bitcoin network, the smallest amount is a <emphasis>satoshi</emphasis>, which cannot be divided any further. Lightning is a bit more flexible, and Lightning nodes work with <emphasis>millisatoshis</emphasis> (thousandths of a satoshi). This allows tiny payments to be sent via Lightning. A single millisatoshi payment can be sent across a payment channel, an amount so small it should properly be characterized as a <emphasis>nanopayment</emphasis>.</simpara>
<simpara>The millisatoshi unit cannot, of course, be settled on the Bitcoin blockchain at that granularity. Upon channel closure, balances are rounded to the nearest satoshi. But over the lifetime of a channel, millions of nanopayments are possible at millisatoshi levels. The Lightning Network breaks through the micropayment barrier.<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_commonality_of_bitcoin_and_lightning">
<title>Commonality of Bitcoin and Lightning</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>commonalities</secondary>
</indexterm>
<indexterm>
  <primary>commonalities</primary>
</indexterm>While the Lightning Network differs from Bitcoin in a number of ways, including in architecture and user experience, it is built from Bitcoin and retains many of Bitcoin’s core features.</simpara>
<section id="_monetary_unit">
<title>Monetary Unit</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>monetary unit commonalities</secondary>
</indexterm>
<indexterm>
  <primary>monetary unit commonalities</primary>
</indexterm>Both the Bitcoin network and the Lightning Network use the same monetary units: bitcoin. Lightning payments use the very same bitcoin as Bitcoin transactions. As an implication, because the monetary unit is the same, the monetary limit is the same: less than 21 million bitcoin. Of Bitcoin&#8217;s 21 million total bitcoin, some are already allocated to 2-of-2 multisignature addresses as part of payment channels on the Lightning Network.</simpara>
</section>
<section id="_irreversibility_and_finality_of_payments">
<title>Irreversibility and Finality of Payments</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>payment irreversibility/finality</secondary>
</indexterm>
<indexterm>
  <primary>payment irreversibility/finality</primary>
</indexterm>Both Bitcoin transactions and Lightning payments are irreversible and immutable. There is no "undo" operation or "chargeback" for either system. As a sender of either one, you have to act responsibly, but also, as a recipient you are guaranteed finality of your transactions.</simpara>
</section>
<section id="_trust_and_counterparty_risk">
<title>Trust and Counterparty Risk</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>trust and counterparty risk</secondary>
</indexterm>
<indexterm>
  <primary>trust and counterparty risk</primary>
</indexterm>As with Bitcoin, Lightning requires the user only to trust mathematics, encryption, and that the software does not have any critical bugs. Neither Bitcoin nor Lightning requires the user to trust a person, a company, an institution, or a government.
Because Lightning sits on top of Bitcoin and relies on Bitcoin as its underlying base layer, it is clear that the security model of Lightning reduces to the security of Bitcoin. This means that Lightning offers broadly the same security as Bitcoin under most circumstances, with only a slight reduction in security under some narrow circumstances.</simpara>
</section>
<section id="_permissionless_operation">
<title>Permissionless Operation</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>permissionless operation</secondary>
</indexterm>
<indexterm>
  <primary>permissionless operation</primary>
</indexterm>Both Bitcoin and Lightning can be used by anybody with access to the internet and to the appropriate software, e.g., node and wallet.
Neither network requires users to get permission, vetting, or authorization from third parties, companies, institutions, or a government. Governments can outlaw Bitcoin or Lightning within their jurisdiction, but cannot prevent their global use.</simpara>
</section>
<section id="_open_source_and_open_system">
<title>Open Source and Open System</title>
<simpara><indexterm>
  <primary>Bitcoin–Lightning Network comparisons</primary><secondary>open source/open system</secondary>
</indexterm>
<indexterm>
  <primary>open source/open system</primary>
</indexterm>Both Bitcoin and Lightning are open source software systems built by a decentralized global community of volunteers, available under open licenses. Both are based on open and interoperable protocols that operate as open systems and open networks. Global, open, and free.<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_conclusion_3">
<title>Conclusion</title>
<simpara>In this chapter we looked at how the Lightning Network actually works and all of the constituent components. We examined each step in constructing, operating, and closing a channel. We looked at how payments are routed, and finally, we compared Lightning with Bitcoin and analyzed their differences and commonalities.<indexterm>
</indexterm></simpara>
<simpara>In the next several chapters we will revisit all these topics, but in much more detail.</simpara>
</section>
</chapter>
<chapter id="set_up_a_lightning_node">
<title>Lightning Node Software</title>
<simpara><indexterm>
  <primary>Lightning node software</primary>
</indexterm>As we have seen in previous chapters, a Lightning node is a computer system that participates in the Lightning Network. The Lightning Network is not a product or company; it is a set of open standards that define a baseline for interoperability. As such, Lightning node software has been built by a variety of companies and community groups. The vast majority of Lightning software is <emphasis>open source</emphasis>, meaning that the source code is open and licensed in such a way as to enable collaboration, sharing, and community participation in the development process. Similarly, the Lightning node implementations we will present in this chapter are all open source and are collaboratively developed.</simpara>
<simpara>Unlike Bitcoin, where the standard is defined by a <emphasis>reference implementation</emphasis> in software (Bitcoin Core), in <indexterm>
  <primary>BOLT (Basis of Lightning Technology) standards documents</primary>
</indexterm>Lightning the standard is defined by a series of standards documents called <emphasis>Basis of Lightning Technology</emphasis> (<emphasis>BOLT</emphasis>), found at the <ulink url="https://github.com/lightningnetwork/lightning-rfc"><emphasis>lightning-rfc</emphasis> repository</ulink>.</simpara>
<simpara>There is no reference implementation of the Lightning Network, but there are several competing, BOLT-compliant, and interoperable implementations developed by different teams and organizations. The teams that develop software for the Lightning Network also contribute in the development and evolution of the BOLT standards.</simpara>
<simpara>Another major difference between Lightning node software and Bitcoin node software is that Lightning nodes do not need to operate in lockstep with consensus rules and can have extended functionality beyond the baseline of the BOLTs. Therefore, different teams may pursue various experimental features that, if successful and broadly deployed, may become part of the BOLTs later.</simpara>
<simpara role="pagebreak-before">In this chapter, you will learn how to set up each of the software packages for the most popular Lightning node implementations. We&#8217;ve presented them in alphabetical order to emphasize that we generally do not prefer or endorse one over the other. Each has its strengths and weaknesses, and choosing one will depend on a variety of factors. Since they are developed in different programming languages (e.g., Go, C, etc.), your choice may also depend on your level of familiarity and expertise with a specific language and development toolset.</simpara>
<section id="_lightning_development_environment">
<title>Lightning Development Environment</title>
<simpara><indexterm>
  <primary>development environment</primary><secondary>Lightning node software</secondary>
</indexterm>
<indexterm>
  <primary>Lightning node software</primary>
</indexterm><indexterm>
  <primary>Lightning node software</primary><secondary>development environment</secondary>
</indexterm>
<indexterm>
  <primary>development environment</primary>
</indexterm>If you&#8217;re a developer, you will want to set up a development environment with all the tools, libraries, and support software for writing and running Lightning software. In this highly technical chapter, we&#8217;ll walk through that process step-by-step. If the material becomes too dense or you&#8217;re not actually setting up a development environment, then feel free to skip to the next chapter, which is less technical.</simpara>
<section id="_using_the_command_line">
<title>Using the Command Line</title>
<simpara><indexterm>
  <primary>command line</primary>
</indexterm><indexterm>
  <primary>development environment</primary><secondary>command line</secondary>
</indexterm>
<indexterm>
  <primary>command line</primary>
</indexterm><indexterm>
  <primary>Lightning node software</primary><secondary>command line</secondary>
</indexterm>
<indexterm>
  <primary>command line</primary>
</indexterm>The examples in this chapter, and more broadly in most of this book, use a command-line terminal. That means that you type commands into a terminal and receive text responses. Furthermore, the examples are demonstrated on an operating system based on the Linux kernel and GNU software system, specifically the latest long-term stable release of Ubuntu (Ubuntu 20.04 LTS). The majority of the examples can be replicated on other operating systems such as Windows or macOS, with small modifications to the commands. The biggest difference between operating systems is the <emphasis>package manager</emphasis> that installs the various software libraries and their prerequisites. In the given examples, we will use <literal>apt</literal>, which is the package manager for Ubuntu. On macOS, a common package manager used for open source development is <ulink url="https://brew.sh">Homebrew</ulink>, which is accessed by the command <literal>brew</literal>.</simpara>
<simpara>In most of the examples here, we will be building the software directly from the source code. While this can be quite challenging, it gives us the most power and control. You may choose to use Docker containers, precompiled packages, or other installation mechanisms instead if you get stuck!</simpara>
<tip>
<simpara>In many of the examples in this chapter we will be using the operating system&#8217;s command-line interface (also known as a <emphasis>shell</emphasis>), accessed via a <emphasis>terminal</emphasis> application. The shell will first display a prompt as an indicator that it is ready for your command. Then you type a command and press the Enter key, to which the shell responds with some text and a new prompt for your next command. The prompt may look different on your system, but in the following examples it is denoted by a <literal>$</literal> symbol. In the examples, when you see text after a <literal>$</literal> symbol, don&#8217;t type the <literal>$</literal> symbol but type the command immediately following it. Then press the Enter key to execute the command. In the examples, the lines following each command are the operating system&#8217;s responses to that command. When you see the next <literal>$</literal> prefix, you&#8217;ll know it is a new command and you should repeat the process.</simpara>
</tip>
<simpara>To keep things consistent, we use the <literal>bash</literal> shell in all command-line examples. While other shells will behave in a similar way, and you will be able to run all the examples without it, some of the shell scripts are written specifically for the <literal>bash</literal> shell and may require some changes or customizations to run in another shell. For consistency, you can install the <literal>bash</literal> shell on Windows and macOS, and it comes installed by default on most Linux systems.</simpara>
</section>
<section id="_downloading_the_book_repository">
<title>Downloading the Book Repository</title>
<simpara><indexterm>
  <primary>development environment</primary><secondary>downloading the book repository</secondary>
</indexterm>
<indexterm>
  <primary>downloading the book repository</primary>
</indexterm>All the code examples are available in the book&#8217;s online repository. Because the repository will be kept up-to-date as much as possible, you should always look for the latest version in the online repository instead of copying it from the printed book or the ebook.</simpara>
<simpara>You can download the repository as a ZIP bundle by visiting <ulink url="https://github.com/lnbook/lnbook">GitHub</ulink> and selecting the green Code button on the right.</simpara>
<simpara>Alternatively, you can use the <literal>git</literal> command to create a version-controlled clone of the repository on your local computer. Git is a distributed version control system that is used by most developers to collaborate on software development and track changes to software repositories. Download and install <literal>git</literal> by following the instructions <ulink url="https://git-scm.com">from the Git Project</ulink>.</simpara>
<simpara>To make a local copy of the repository on your computer, run the <literal>git</literal> command as follows:</simpara>
<screen id="git-clone-lnbook">$ git clone https://github.com/lnbook/lnbook.git</screen>
<simpara>You now have a complete copy of the book repository in a folder called <literal>lnbook</literal>. You will want to change to the newly downloaded directory by running:</simpara>
<screen id="cd-lnbook">$ cd lnbook</screen>
<simpara>All subsequent examples will assume that you are running commands from inside this folder.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_docker_containers">
<title>Docker Containers</title>
<simpara><indexterm>
  <primary>Docker containers</primary><secondary>Lightning node software and</secondary>
</indexterm>
<indexterm>
  <primary>Lightning node software and</primary>
</indexterm><indexterm>
  <primary>Lightning node software</primary><secondary>Docker containers</secondary>
</indexterm>
<indexterm>
  <primary>Docker containers</primary>
</indexterm>Many developers use a <emphasis>container</emphasis>, which is a type of virtual machine, to install a pre-configured operating system and applications with all the necessary dependencies. Much of the Lightning software can also be installed using a container system such as <emphasis>Docker</emphasis> found at <ulink url="https://docker.com">the Docker home page</ulink>. Container installations are a lot easier, especially for those who are not used to a command-line environment.</simpara>
<simpara>The book&#8217;s repository contains a collection of Docker containers that can be used to set up a consistent development environment to practice and replicate the examples on any system. Because the container is a complete operating system that runs with a consistent configuration, you can be sure that the examples will work on your computer without the need to worry about dependencies, library versions, or differences in configuration.</simpara>
<simpara>Docker containers are often optimized to be small, i.e., occupy the minimum disk space. However, in this book we are using containers to <emphasis>standardize</emphasis> the environment and make it consistent for all readers. Furthermore, these containers are not meant to be used to run services in the background. Instead, they are meant to be used to test the examples and learn by interacting with the software. For these reasons, the containers are quite large and come with a lot of development tools and utilities. Commonly, the Alpine distribution is used for Linux containers due to their reduced size. Nonetheless, we provide containers built on Ubuntu because more developers are familiar with Ubuntu, and this familiarity is more important to us than size.</simpara>
<simpara>The installation and use of Docker and its commands are detailed in <xref linkend="appendix_docker"/>. If you are unfamiliar with Docker, now is a good time to quickly review that section.</simpara>
<simpara>You can find the latest container definitions and build configurations in the book&#8217;s repository under the <emphasis>code/docker</emphasis> folder. Each container is in a separate folder, as can be seen in the following:</simpara>
<screen id="tree">$ tree -F --charset=asciii code/docker</screen>
<screen id="docker-dir-list">code/docker
|-- bitcoind/
|   |-- bashrc
|   |-- bitcoind/
|   |   |-- bitcoin.conf
|   |   `-- keys/
|   |       |-- demo_address.txt
|   |       |-- demo_mnemonic.txt
|   |       `-- demo_privkey.txt
|   |-- bitcoind-entrypoint.sh
|   |-- cli
|   |-- Dockerfile
|   `-- mine.sh*
|-- c-lightning/
|   |-- bashrc
|   |-- cli
|   |-- c-lightning-entrypoint.sh
|   |-- devkeys.pem
|   |-- Dockerfile
|   |-- fund-c-lightning.sh
|   |-- lightningd/
|   |   `-- config
|   |-- logtail.sh
|   `-- wait-for-bitcoind.sh
|-- eclair/
|   |-- bashrc
|   |-- cli
|   |-- Dockerfile
|   |-- eclair/
|   |   `-- eclair.conf
|   |-- eclair-entrypoint.sh
|   |-- logtail.sh
|   `-- wait-for-bitcoind.sh
|-- lnd/
|   |-- bashrc
|   |-- cli
|   |-- Dockerfile
|   |-- fund-lnd.sh
|   |-- lnd/
|   |   `-- lnd.conf
|   |-- lnd-entrypoint.sh
|   |-- logtail.sh
|   `-- wait-for-bitcoind.sh
|-- check-versions.sh
|-- docker-compose.yml
|-- Makefile
`-- run-payment-demo.sh*</screen>
<simpara>As we will see in the next few sections, you can build these containers locally, or you can pull them from the book&#8217;s repository on <ulink url="https://hub.docker.com/orgs/lnbook"><emphasis>Docker Hub</emphasis></ulink>. The following sections will assume that you have installed Docker and are familiar with the basic use of the <literal>docker</literal> command.</simpara>
</section>
<section id="_bitcoin_core_and_regtest">
<title>Bitcoin Core and Regtest</title>
<simpara><indexterm>
  <primary>Bitcoin Core</primary>
</indexterm><indexterm>
  <primary>Lightning node software</primary><secondary>Bitcoin Core and regtest</secondary>
</indexterm>
<indexterm>
  <primary>Bitcoin Core and regtest</primary>
</indexterm>Most of the Lightning node implementations need access to a full Bitcoin node to work.</simpara>
<simpara>Installing a full Bitcoin node and syncing the Bitcoin blockchain is outside the scope of this book and is a relatively complex endeavor in itself. If you want to try it, refer to <ulink url="https://github.com/bitcoinbook/bitcoinbook"><emphasis>Mastering Bitcoin</emphasis></ulink>, "Chapter 3: Bitcoin Core: The Reference Implementation," which discusses the installation and operation of a Bitcoin node.</simpara>
<simpara><indexterm>
  <primary>regtest mode</primary>
</indexterm>A Bitcoin node can be operated in <literal>regtest</literal> mode, where the node creates a local simulated Bitcoin blockchain for testing purposes. In the following examples, we will be using the <literal>regtest</literal> mode to allow us to demonstrate Lightning without having to synchronize a Bitcoin node or risk any funds.</simpara>
<simpara>The container for Bitcoin Core is <literal>bitcoind</literal>. It is configured to run Bitcoin Core in <literal>regtest</literal> mode and to mine 6 new blocks every 10 seconds. Its remote procedure call (RPC) port is exposed on port 18443 and is accessible for RPC calls with the username <literal>regtest</literal> and the password <literal>regtest</literal>. You can also access it with an interactive shell and run <literal>bitcoin-cli</literal> commands locally.</simpara>
<section id="_building_the_bitcoin_core_container">
<title>Building the Bitcoin Core Container</title>
<simpara><indexterm>
  <primary>bitcoind container</primary>
</indexterm><indexterm>
  <primary>Docker containers</primary><secondary>Bitcoin Core container</secondary>
</indexterm>
<indexterm>
  <primary>Bitcoin Core container</primary>
</indexterm>Let&#8217;s prepare the <literal>bitcoind</literal> container. The easiest way is to pull the latest container from <emphasis>Docker Hub</emphasis>:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker pull lnbook/bitcoind
Using default tag: latest
latest: Pulling from lnbook/bitcoind
35807b77a593: Pull complete
e1b85b9c5571: Pull complete
[...]
288f1cc78a00: Pull complete
Digest: sha256:861e7e32c9ad650aa367af40fc5acff894e89e47aff4bd400691ae18f1b550e2
Status: Downloaded newer image for lnbook/bitcoind:latest
docker.io/lnbook/bitcoind:latest</programlisting>
<simpara>Alternatively, you can build the container yourself from the local container definition that is in <emphasis>code/docker/bitcoind/Dockerfile</emphasis>.</simpara>
<note>
<simpara>You don&#8217;t need to build the container if you used the <literal>pull</literal> command previously to pull it from Docker Hub.</simpara>
</note>
<simpara>Building the container locally will use a bit less of your network bandwidth, but will take more of your CPU time to build. We use the <literal>docker build</literal> command to build it:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ cd code/docker
$ docker run -it --name bitcoind lnbook/bitcoind
Starting bitcoind...
Bitcoin Core starting
Waiting for bitcoind to start
bitcoind started
================================================
Imported demo private key
Bitcoin address:  2NBKgwSWY5qEmfN2Br4WtMDGuamjpuUc5q1
Private key:  cSaejkcWwU25jMweWEewRSsrVQq2FGTij1xjXv4x1XvxVRF1ZCr3
================================================
================================================
Balance: 0.00000000
================================================
Mining 101 blocks to unlock some bitcoin
[
  "34c744207fd4dd32b70bac467902bd8d030fba765c9f240a2e98f15f05338964",
  "64d82721c641c378d79b4ff2e17572c109750bea1d4eddbae0b54f51e4cdf23e",

 [...]

  "7a8c53dc9a3408c9ecf9605b253e5f8086d67bbc03ea05819b2c9584196c9294",
  "39e61e50e34a9bd1d6eab51940c39dc1ab56c30b21fc28e1a10c14a39b67a1c3",
  "4ca7fe9a55b0b767d2b7f5cf4d51a2346f035fe8c486719c60a46dcbe33de51a"
]
Mining 6 blocks every 10 seconds
Balance: 50.00000000
[
  "5ce76cc475e40515b67e3c0237d1eef597047a914ba3f59bbd62fc3691849055",
  "1ecb27a05ecfa9dfa82a7b26631e0819b2768fe5e6e56c7a2e1078b078e21e9f",
  "717ceb8b6c329d57947c950dc5668fae65bddb7fa03203984da9d2069e20525b",
  "185fc7cf3557a6ebfc4a8cdd1f94a8fa08ed0c057040cdd68bfb7aee2d5be624",
  "59001ae237a3834ebe4f6e6047dcec8fd67df0352ddc70b6b02190f982a60384",
  "754c860fe1b9e0e7292e1de96a65eaa78047feb4c72dbbde2a1d224faa1499dd"
]</programlisting>
<simpara>As you can see, <literal>bitcoind</literal> starts up and mines 101 simulated blocks to get the chain started. This is because under the Bitcoin consensus rules, newly mined bitcoin is not spendable until 100 blocks have elapsed. By mining 101 blocks, we make the first block&#8217;s coinbase spendable. After that initial mining activity, 6 new blocks are mined every 10 seconds to keep the chain moving forward.</simpara>
<simpara>For now, there are no transactions. But we have some test bitcoin that has been mined in the wallet and is available to spend. When we connect some Lightning nodes to this chain, we will send some bitcoin to their wallets so that we can open some Lightning channels between the Lightning nodes.</simpara>
<section id="_interacting_with_the_bitcoin_core_container">
<title>Interacting with the bitcoin core container</title>
<simpara>In the meantime, we can also interact with the <literal>bitcoind</literal> container by sending it shell commands. The container is sending a logfile to the terminal, displaying the mining process of the <literal>bitcoind</literal> process. To interact with the shell we can issue commands in another terminal, using the <literal>docker exec</literal> command. Since we previously named the running container with the <literal>name</literal> argument, we can refer to it by that name when we run the <literal>docker exec</literal> command. First, let&#8217;s run an interactive <literal>bash</literal> shell:</simpara>
<screen>$ docker exec -it bitcoind /bin/bash
root@e027fd56e31a:/bitcoind# ps x
  PID TTY      STAT   TIME COMMAND
    1 pts/0    Ss+    0:00 /bin/bash /usr/local/bin/mine.sh
    7 ?        Ssl    0:03 bitcoind -datadir=/bitcoind -daemon
   97 pts/1    Ss     0:00 /bin/bash
  124 pts/0    S+     0:00 sleep 10
  125 pts/1    R+     0:00 ps x
root@e027fd56e31a:/bitcoind#</screen>
<simpara>Running the interactive shell puts us "inside" the container. It logs in as user <literal>root</literal>, as we can see from the prefix <literal>root@</literal> in the new shell prompt <literal>root@e027fd56e31a:/bitcoind#</literal>. If we issue the <literal>ps x</literal> command to see what processes are running, we see both <literal>bitcoind</literal> and the script <literal>mine.sh</literal> are running in the background. To exit this shell, press Ctrl-D or type <emphasis role="strong"><literal>exit</literal></emphasis>, and you will be returned to your operating system prompt.</simpara>
<simpara>Instead of running an interactive shell, we can also issue a single command that is executed inside the container. For convenience, the <literal>bitcoin-cli</literal> command has an alias "cli" that passes the correct configuration. So let&#8217;s run it to ask Bitcoin Code about the blockchain. We run <literal>cli getblockchaininfo</literal>:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker exec bitcoind cli getblockchaininfo
{
  "chain": "regtest",
  "blocks": 131,
  "headers": 131,
  "bestblockhash": "2cf57aac35365f52fa5c2e626491df634113b2f1e5197c478d57378e5a146110",

[...]

  "warnings": ""
}</programlisting>
<simpara>The <literal>cli</literal> command in the <literal>bitcoind</literal> container allows us to issue RPC commands to the Bitcoin Core node and get JavaScript Object Notation (JSON) encoded results.</simpara>
<simpara>Additionally, all our Docker containers have a command-line JSON encoder/decoder named <literal>jq</literal> preinstalled. <literal>jq</literal> helps us to process JSON-formatted data via the command line or from inside scripts. You can send the JSON output of any command to <literal>jq</literal> using the <literal>|</literal> character. This character as well as this operation is called a "pipe." Let&#8217;s apply a <literal>pipe</literal> and <literal>jq</literal> to the previous command as follows:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker exec bitcoind bash -c "cli getblockchaininfo | jq .blocks"
197</programlisting>
<simpara><literal>jq .blocks</literal> instructs the <literal>jq</literal> JSON decoder to extract the field <literal>blocks</literal> from the <phrase role=".keep-together"><literal>getblockchaininfo</literal></phrase> result. In our case, it extracts and prints the value of 197 which we could use in a subsequent command.</simpara>
<simpara>As you will see in the following sections, we can run several containers at the same time and then interact with them individually. We can issue commands to extract information such as the Lightning node public key or to take actions such as opening a Lightning channel to another node. The <literal>docker run</literal> and <literal>docker exec</literal> commands, together with <literal>jq</literal> for JSON decoding, are all we need to build a working Lightning Network that mixes many different node implementations. This enables us to try out diverse experiments on our own computer<indexterm>
</indexterm><indexterm>
</indexterm>.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
</section>
<section id="_the_c_lightning_lightning_node_project">
<title>The c-lightning Lightning Node Project</title>
<simpara><indexterm>
  <primary>c-lightning Lightning Node project</primary>
</indexterm><indexterm>
  <primary>Lightning node software</primary><secondary>c-lightning Lightning Node project</secondary>
</indexterm>
<indexterm>
  <primary>c-lightning Lightning Node project</primary>
</indexterm><literal>c-lightning</literal> is a lightweight, highly customizable, and standard-compliant implementation of the LN protocol, developed by Blockstream as part of the Elements Project. The project is open source and developed collaboratively on <ulink url="https://github.com/ElementsProject/lightning">GitHub</ulink>.</simpara>
<simpara>In the following sections, we will build a Docker container that runs a <literal>c-lightning</literal> node connecting to the <literal>bitcoind</literal> container we built previously. We will also show you how to configure and built the <literal>c-lightning</literal> software directly from the source code.</simpara>
<section id="_building_c_lightning_as_a_docker_container">
<title>Building c-lightning as a Docker Container</title>
<simpara><indexterm>
  <primary>c-lightning Lightning Node project</primary><secondary>building c-lightning as Docker container</secondary>
</indexterm>
<indexterm>
  <primary>building c-lightning as Docker container</primary>
</indexterm><indexterm>
  <primary>Docker containers</primary><secondary>building c-lightning as</secondary>
</indexterm>
<indexterm>
  <primary>building c-lightning as</primary>
</indexterm>The <literal>c-lightning</literal> software distribution has a Docker container, but it is designed for running <literal>c-lightning</literal> in production systems and alongside a <literal>bitcoind</literal> node. We will be using a somewhat simpler container configured to run <literal>c-lightning</literal> for demonstration purposes.</simpara>
<simpara>Let&#8217;s pull the <literal>c-lightning</literal> container from the book&#8217;s Docker Hub repository:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker pull lnbook/c-lightning
Using default tag: latest
latest: Pulling from lnbook/c-lightning

[...]

Digest: sha256:bdefcefe8a9712e7b3a236dcc5ab12d999c46fd280e209712e7cb649b8bf0688
Status: Downloaded image for lnbook/c-lightning:latest
docker.io/lnbook/c-lightning:latest</programlisting>
<simpara>Alternatively, we can build the <literal>c-lightning</literal> Docker container from the book&#8217;s files which you previously downloaded into a directory named <literal>lnbook</literal>. As before, we will use the <literal>docker build</literal> command in the <literal>code/docker</literal> subdirectory. We will tag the container image with the tag <literal>lnbook/c-lightning</literal>, like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ cd code/docker
$ docker build -t lnbook/c-lightning c-lightning
Sending build context to Docker daemon  91.14kB
Step 1/34 : ARG OS=ubuntu
Step 2/34 : ARG OS_VER=focal
Step 3/34 : FROM ${OS}:${OS_VER} as os-base
 ---&gt; fb52e22af1b0

 [...]

Step 34/34 : CMD ["/usr/local/bin/logtail.sh"]
 ---&gt; Running in 8d3d6c8799c5
Removing intermediate container 8d3d6c8799c5
 ---&gt; 30b6fd5d7503
Successfully built 30b6fd5d7503
Successfully tagged lnbook/c-lightning:latest</programlisting>
<simpara>Our container is now built and ready to run. However, before we run the <literal>c-lightning</literal> container, we need to start the <literal>bitcoind</literal> container in another terminal because <literal>c-lightning</literal> depends on <literal>bitcoind</literal>. We will also need to set up a Docker network that allows the containers to connect to each other as if residing on the same local area network.</simpara>
<tip>
<simpara>Docker containers can "talk" to each other over a virtual local area network managed by the Docker system. Each container can have a custom name, and other containers can use that name to resolve its IP address and easily connect to it.</simpara>
</tip>
</section>
<section id="_setting_up_a_docker_network">
<title>Setting Up a Docker Network</title>
<simpara><indexterm>
  <primary>c-lightning Lightning Node project</primary><secondary>Docker network setup</secondary>
</indexterm>
<indexterm>
  <primary>Docker network setup</primary>
</indexterm>Once a Docker network is set up, Docker will activate the network on our local computer every time Docker starts, e.g., after rebooting. So we only need to set up a network once by using the <literal>docker network create</literal> command. The network name itself is not important, but it has to be unique on our computer. By default, Docker has three networks named <literal>host</literal>, <literal>bridge</literal>, and <literal>none</literal>. We will name our new network <literal>lnbook</literal> and create it like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker network create lnbook
ad75c0e4f87e5917823187febedfc0d7978235ae3e88eca63abe7e0b5ee81bfb
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
7f1fb63877ea        bridge              bridge              local
4e575cba0036        host                host                local
ad75c0e4f87e        lnbook              bridge              local
ee8824567c95        none                null                local</programlisting>
<simpara>As you can see, running <literal>docker network ls</literal> gives us a listing of the Docker networks. Our <literal>lnbook</literal> network has been created. We can ignore the network ID, because it is automatically managed.</simpara>
</section>
<section id="_running_the_bitcoind_and_c_lightning_containers">
<title>Running the bitcoind and c-lightning Containers</title>
<simpara><indexterm>
  <primary>bitcoind container</primary><secondary>and c-lightning containers</secondary>
</indexterm>
<indexterm>
  <primary>and c-lightning containers</primary>
</indexterm><indexterm>
  <primary>c-lightning Lightning Node project</primary><secondary>running bitcoind and c-lightning containers</secondary>
</indexterm>
<indexterm>
  <primary>running bitcoind and c-lightning containers</primary>
</indexterm>The next step is to start the <literal>bitcoind</literal> and <literal>c-lightning</literal> containers and connect them to the <literal>lnbook</literal> network. To run a container in a specific network, we must pass the <phrase role=".keep-together"><literal>network</literal></phrase> argument to <literal>docker run</literal>. To make it easy for containers to find each other, we will also give each one a name with the <literal>name</literal> argument. We start <literal>bitcoind</literal> like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind</programlisting>
<simpara>You should see <literal>bitcoind</literal> start up and start mining blocks every 10 seconds. Leave it running and open a new terminal window to start <literal>c-lightning</literal>. We use a similar <literal>docker run</literal> command with the <literal>network</literal> and <literal>name</literal> arguments to start <literal>c-lightning</literal> as follows:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker run -it --network lnbook --name c-lightning lnbook/c-lightning
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting c-lightning...
2021-09-12T13:14:50.434Z UNUSUAL lightningd: Creating configuration directory /lightningd/regtest
Startup complete
Funding c-lightning wallet
8a37a183274c52d5a962852ba9f970229ea6246a096ff1e4602b57f7d4202b31
lightningd: Opened log file /lightningd/lightningd.log
lightningd: Creating configuration directory /lightningd/regtest
lightningd: Opened log file /lightningd/lightningd.log</programlisting>
<simpara>The <literal>c-lightning</literal> container starts up and connects to the <literal>bitcoind</literal> container over the Docker network. First, our <literal>c-lightning</literal> node will wait for <literal>bitcoind</literal> to start, and then it will wait until <literal>bitcoind</literal> has mined some bitcoin into its wallet. Finally, as part of the container startup, a script will send an RPC command to the <literal>bitcoind</literal> node, which creates a transaction that funds the <literal>c-lightning</literal> wallet with 10 test BTC. Now our <literal>c-lightning</literal> node is not only running, but it even has some test bitcoin to play with!</simpara>
<simpara>As we demonstrated with the <literal>bitcoind</literal> container, we can issue commands to our <literal>c-lightning</literal> container in another terminal to extract information, open channels, etc. The command that allows us to issue command-line instructions to the <literal>c-lightning</literal> node is called <literal>lightning-cli</literal>. This <literal>lightning-cli</literal> command is also aliased as <literal>cli</literal> inside this container. To get the <literal>c-lightning</literal> node&#8217;s information, use the following <literal>docker exec</literal> command in another terminal window:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker exec c-lightning cli getinfo
{
   "id": "026ec53cc8940df5fed5fa18f8897719428a15d860ff4cd171fca9530879c7499e",
   "alias": "IRATEARTIST",
   "color": "026ec5",
   "num_peers": 0,
   "num_pending_channels": 0,

[...]

   "version": "0.10.1",
   "blockheight": 221,
   "network": "regtest",
   "msatoshi_fees_collected": 0,
   "fees_collected_msat": "0msat",
   "lightning-dir": "/lightningd/regtest"
}</programlisting>
<simpara>We now have our first Lightning node running on a virtual network and communicating with a test Bitcoin blockchain. Later in this chapter we will start more nodes and connect them to each other to make some Lightning payments.</simpara>
<simpara>In the next section we will also look at how to download, configure, and compile <literal>c-lightning</literal> directly from the source code. This is an optional and advanced step that will teach you how to use the build tools and allow you to make modifications to <phrase role=".keep-together"><literal>c-lightning</literal></phrase> source code. With this knowledge you can write some code, fix some bugs, or create a plug-in for <literal>c-lightning</literal>.</simpara>
<note>
<simpara>If you are not planning on diving into the source code or programming of a Lightning node, you can skip the next section entirely. The Docker container we just built is sufficient for most of the examples in the book.</simpara>
</note>
</section>
<section id="_installing_c_lightning_from_source_code">
<title>Installing c-lightning from Source Code</title>
<simpara><indexterm>
  <primary>c-lightning Lightning Node project</primary><secondary>installing c-lightning from source code</secondary>
</indexterm>
<indexterm>
  <primary>installing c-lightning from source code</primary>
</indexterm>The <literal>c-lightning</literal> developers have provided detailed instructions for building <literal>c-lightning</literal> from source code. We will be following the instructions <ulink url="https://github.com/ElementsProject/lightning/blob/master/doc/INSTALL.md">from GitHub</ulink>.</simpara>
</section>
<section id="_installing_prerequisite_libraries_and_packages">
<title>Installing Prerequisite Libraries and Packages</title>
<simpara><indexterm>
  <primary>c-lightning Lightning Node project</primary><secondary>installing prerequisite libraries and packages</secondary>
</indexterm>
<indexterm>
  <primary>installing prerequisite libraries and packages</primary>
</indexterm>These installation instructions assume you are building <literal>c-lightning</literal> on a Linux or similar system with GNU build tools. If that is not the case, look for the instructions for your operating system in the Elements Project repository.</simpara>
<simpara>The common first step is the installation of prerequisite libraries. We use the <literal>apt</literal> package manager to install these:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ sudo apt-get update

Get:1 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]
Hit:2 http://eu-north-1b.clouds.archive.ubuntu.com/ubuntu bionic InRelease
Get:3 http://eu-north-1b.clouds.archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]

[...]

Fetched 18.3 MB in 8s (2,180 kB/s)
Reading package lists... Done

$ sudo apt-get install -y \
  autoconf automake build-essential git libtool libgmp-dev \
  libsqlite3-dev python python3 python3-mako net-tools zlib1g-dev \
  libsodium-dev gettext

Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  autotools-dev binutils binutils-common binutils-x86-64-linux-gnu cpp cpp-7 dpkg-dev fakeroot g++ g++-7 gcc gcc-7 gcc-7-base libalgorithm-diff-perl

 [...]

Setting up libsigsegv2:amd64 (2.12-2) ...
Setting up libltdl-dev:amd64 (2.4.6-14) ...
Setting up python2 (2.7.17-2ubuntu4) ...
Setting up libsodium-dev:amd64 (1.0.18-1) ...

[...]
$</programlisting>
<simpara>After a few minutes and a lot of on-screen activity, you will have installed all the necessary packages and libraries. Many of these libraries are also used by other Lightning packages and are needed for software development in general.</simpara>
</section>
<section id="_copying_the_c_lightning_source_code">
<title>Copying the c-lightning Source Code</title>
<simpara><indexterm>
  <primary>c-lightning Lightning Node project</primary><secondary>copying the latest version of c-lightning source code</secondary>
</indexterm>
<indexterm>
  <primary>copying the latest version of c-lightning source code</primary>
</indexterm>Next, we will copy the latest version of <literal>c-lightning</literal> from the source code repository. To do this, we will use the <literal>git clone</literal> command, which clones a version-controlled copy onto your local machine, thereby allowing you to keep it synchronized with subsequent changes without having to download the whole repository again:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git clone --recurse https://github.com/ElementsProject/lightning.git
Cloning into 'lightning'...
remote: Enumerating objects: 24, done.
remote: Counting objects: 100% (24/24), done.
remote: Compressing objects: 100% (22/22), done.
remote: Total 53192 (delta 5), reused 5 (delta 2), pack-reused 53168
Receiving objects: 100% (53192/53192), 29.59 MiB | 19.30 MiB/s, done.
Resolving deltas: 100% (39834/39834), done.

$ cd lightning</programlisting>
<simpara>We now have a copy of <literal>c-lightning</literal> cloned into the <emphasis>lightning</emphasis> subfolder, and we have used the <literal>cd</literal> (change directory) command to enter that subfolder.</simpara>
</section>
<section id="_compiling_the_c_lightning_source_code">
<title>Compiling the c-lightning Source Code</title>
<simpara><indexterm>
  <primary>c-lightning Lightning Node project</primary><secondary>compiling the c-lightning source code</secondary>
</indexterm>
<indexterm>
  <primary>compiling the c-lightning source code</primary>
</indexterm>Next, we use a set of <emphasis>build scripts</emphasis> that are commonly available in many open source projects. These build scripts use the <literal>configure</literal> and <literal>make</literal> commands, which allow <span class="keep-together">us to</span>:</simpara>
<itemizedlist>
<listitem>
<simpara>
Select the build options and check necessary dependencies (<literal>configure</literal>)
</simpara>
</listitem>
<listitem>
<simpara>
Build and install the executables and libraries (<literal>make</literal>)
</simpara>
</listitem>
</itemizedlist>
<simpara>Running <literal>configure</literal> with the <literal>help</literal> option will show us all the available options:</simpara>
<screen>$ ./configure --help
Usage: ./configure [--reconfigure] [setting=value] [options]

Options include:
  --prefix= (default /usr/local)
    Prefix for make install
  --enable/disable-developer (default disable)
    Developer mode, good for testing
  --enable/disable-experimental-features (default disable)
    Enable experimental features
  --enable/disable-compat (default enable)
    Compatibility mode, good to disable to see if your software breaks
  --enable/disable-valgrind (default (autodetect))
    Run tests with Valgrind
  --enable/disable-static (default disable)
    Static link sqlite3, gmp and zlib libraries
  --enable/disable-address-sanitizer (default disable)
    Compile with address-sanitizer</screen>
<simpara>We don&#8217;t need to change any of the defaults for this example. Hence we run <phrase role=".keep-together"><literal>configure</literal></phrase> again without any options to use the defaults:</simpara>
<screen>$ ./configure

Compiling ccan/tools/configurator/configurator...done
checking for python3-mako... found
Making autoconf users comfortable... yes
checking for off_t is 32 bits... no
checking for __alignof__ support... yes

[...]

Setting COMPAT... 1
PYTEST not found
Setting STATIC... 0
Setting ASAN... 0
Setting TEST_NETWORK... regtest
$</screen>
<simpara>Next, we use the <literal>make</literal> command to build the libraries, components, and executables of the <literal>c-lightning</literal> project. This part will take several minutes to complete and will use your computer&#8217;s CPU and disk heavily. Expect some noise from the fans! Run <literal>make</literal>:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ make

cc -DBINTOPKGLIBEXECDIR="\"../libexec/c-lightning\"" -Wall -Wundef -Wmis...

[...]

cc   -Og  ccan-asort.o ccan-autodata.o ccan-bitmap.o ccan-bitops.o ccan-...</programlisting>
<simpara>If all goes well, you will not see any <literal>ERROR</literal> message stopping the execution of the preceding command. The <literal>c-lightning</literal> software package has been compiled from source, and we are now ready to install the executable components we created in the previous step:</simpara>
<screen>$ sudo make install

mkdir -p /usr/local/bin
mkdir -p /usr/local/libexec/c-lightning
mkdir -p /usr/local/libexec/c-lightning/plugins
mkdir -p /usr/local/share/man/man1
mkdir -p /usr/local/share/man/man5
mkdir -p /usr/local/share/man/man7
mkdir -p /usr/local/share/man/man8
mkdir -p /usr/local/share/doc/c-lightning
install cli/lightning-cli lightningd/lightningd /usr/local/bin
[...]</screen>
<simpara>To verify that the <literal>lightningd</literal> and <literal>lightning-cli</literal> commands have been installed correctly, we will ask each executable for its version information:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ lightningd --version
v0.10.1-34-gfe86c11
$ lightning-cli --version
v0.10.1-34-gfe86c11</programlisting>
<simpara>The version consists of the latest release version (v0.10.1), followed by the number of changes since the release (34), and finally a hash identifying exactly which revision (fe86c11). You may see a different version from that shown previously as the software continues to evolve long after this book is published. However, no matter what version you see, the fact that the commands execute and respond with version information means that you have succeeded in building the <literal>c-lightning</literal> software.</simpara>
</section>
</section>
<section id="_the_lightning_network_daemon_node_project">
<title>The Lightning Network Daemon Node Project</title>
<simpara><indexterm>
  <primary>Lightning Network Daemon (LND) node project</primary>
</indexterm><indexterm>
  <primary>Lightning node software</primary><secondary>Lightning Network Daemon node project</secondary>
</indexterm>
<indexterm>
  <primary>Lightning Network Daemon node project</primary>
</indexterm>The Lightning Network Daemon (LND) is a complete implementation of an LN node by Lightning Labs. The LND project provides a number of executable applications, including <literal>lnd</literal> (the daemon itself) and <literal>lncli</literal> (the command-line utility). LND has several pluggable backend chain services, including btcd (a full node), <literal>bitcoind</literal> (Bitcoin Core), and Neutrino (a new, experimental light client). LND is written in the Go programming language. The project is open source and developed collaboratively on <ulink url="https://github.com/LightningNetwork/lnd">GitHub</ulink>.</simpara>
<simpara>In the next few sections we will build a Docker container to run LND, build LND from source code, and learn how to configure and run LND.</simpara>
<section id="_the_lnd_docker_container">
<title>The LND Docker Container</title>
<simpara><indexterm>
  <primary>Lightning Network Daemon (LND) node project</primary><secondary>LND Docker container</secondary>
</indexterm>
<indexterm>
  <primary>LND Docker container</primary>
</indexterm>We can pull the LND example Docker container from the book&#8217;s Docker Hub <span class="keep-together">repository</span>:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker pull lnbook/lnd
Using default tag: latest
latest: Pulling from lnbook/lnd
35807b77a593: Already exists
e1b85b9c5571: Already exists
52f9c252546e: Pull complete

[...]

Digest: sha256:e490a0de5d41b781c0a7f9f548c99e67f9d728f72e50cd4632722b3ed3d85952
Status: Downloaded newer image for lnbook/lnd:latest
docker.io/lnbook/lnd:latest</programlisting>
<simpara>Alternatively, we can build the LND container locally. The container is located in <emphasis>code/docker/lnd</emphasis>. We change the working directory to <emphasis>code/docker</emphasis> and perform the <literal>docker build</literal> command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ cd code/docker
$ docker build -t lnbook/lnd lnd
Sending build context to Docker daemon  9.728kB
Step 1/29 : FROM golang:1.13 as lnd-base
 ---&gt; e9bdcb0f0af9
Step 2/29 : ENV GOPATH /go

[...]

Step 29/29 : CMD ["/usr/local/bin/logtail.sh"]
 ---&gt; Using cache
 ---&gt; 397ce833ce14
Successfully built 397ce833ce14
Successfully tagged lnbook/lnd:latest</programlisting>
<simpara>Our container is now ready to run. As with the <literal>c-lightning</literal> container we built previously, the LND container also depends on a running instance of Bitcoin Core. As before, we need to start the <literal>bitcoind</literal> container in another terminal and connect LND to it via a Docker network. We have already set up a Docker network called <literal>lnbook</literal> and will be using that again here.</simpara>
<tip>
<simpara>Normally, each node operator runs their own Lightning node and their own Bitcoin node on their own server. For us, a single <literal>bitcoind</literal> container can serve many Lightning nodes. On our simulated network we can run several Lightning nodes, all connecting to a single Bitcoin node in <literal>regtest</literal> mode.</simpara>
</tip>
</section>
<section id="_running_the_bitcoind_and_lnd_containers">
<title>Running the bitcoind and LND Containers</title>
<simpara><indexterm>
  <primary>bitcoind container</primary><secondary>and LND containers</secondary>
</indexterm>
<indexterm>
  <primary>and LND containers</primary>
</indexterm><indexterm>
  <primary>Lightning Network Daemon (LND) node project</primary><secondary>running bitcoind and LND containers</secondary>
</indexterm>
<indexterm>
  <primary>running bitcoind and LND containers</primary>
</indexterm>As before, we start the <literal>bitcoind</literal> container in one terminal and LND in another. If you already have the <literal>bitcoind</literal> container running, you do not need to restart it. Just leave it running and skip the next step. To start <literal>bitcoind</literal> in the <literal>lnbook</literal> network, we use <literal>docker run</literal> like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind</programlisting>
<simpara>Next, we start the LND container we just built. As done before, we need to attach it to the <literal>lnbook</literal> network and give it a name:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker run -it --network lnbook --name lnd lnbook/lnd
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting lnd...
Startup complete
Funding lnd wallet
{"result":"dbd1c8e2b224e0a511c11efb985dabd84d72d935957ac30935ec4211d28beacb","error":null,"id":"lnd-run-container"}
[INF] LTND: Version: 0.13.1-beta commit=v0.13.1-beta, build=production, logging=default, debuglevel=info
[INF] LTND: Active chain: Bitcoin (network=regtest)
[INF] RPCS: Generating TLS certificates...</programlisting>
<simpara>The LND container starts up and connects to the <literal>bitcoind</literal> container over the Docker network. First, our LND node will wait for <literal>bitcoind</literal> to start, and then it will wait until <literal>bitcoind</literal> has mined some bitcoin into its wallet. Finally, as part of the container startup, a script will send an RPC command to the <literal>bitcoind</literal> node, thereby creating a transaction that funds the LND wallet with 10 test BTC.</simpara>
<simpara>As we demonstrated previously, we can issue commands to our container in another terminal to extract information, open channels, etc. The command that allows us to issue command-line instructions to the <literal>lnd</literal> daemon is called <literal>lncli</literal>. Once again, in this container we have provided the alias <literal>cli</literal> that runs <literal>lncli</literal> with all the appropriate parameters. Let&#8217;s get the node information using the <literal>docker exec</literal> command in another terminal window:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker exec lnd cli getinfo
{
    "version": "0.13.1-beta commit=v0.13.1-beta",
    "commit_hash": "596fd90ef310cd7abbf2251edaae9ba4d5f8a689",
    "identity_pubkey": "02d4545dccbeda29a10f44e891858940f4f3374b75c0f85dcb7775bb922fdeaa14",

[...]

}</programlisting>
<simpara>We now have another Lightning node running on the <literal>lnbook</literal> network and communicating with <literal>bitcoind</literal>. If you are still running the <literal>c-lightning</literal> container, then there are now two nodes running. They&#8217;re not yet connected to each other, but we will be connecting them to each other soon.</simpara>
<simpara>If desired, you can run any combination of LND and <literal>c-lightning</literal> nodes on the same Lightning Network. For example, to run a second LND node you would issue the <literal>docker run</literal> command with a different container name, like so:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker run -it --network lnbook --name lnd2 lnbook/lnd</programlisting>
<simpara>In the preceding command, we start another LND container, naming it <literal>lnd2</literal>. The names are entirely up to you, as long as they are unique. If you don&#8217;t provide a name, Docker will construct a unique name by randomly combining two English words such as "naughty_einstein." This was the actual name Docker chose for us when we wrote this paragraph. How funny!</simpara>
<simpara>In the next section we will look at how to download and compile LND directly from the source code. This is an optional and advanced step that will teach you how to use the Go language build tools and allow you to make modifications to LND source code. With this knowledge you can write some code or fix some bugs.</simpara>
<note>
<simpara>If you are not planning on diving into the source code or programming of a Lightning node, you can skip the next section entirely. The Docker container we just built is sufficient for most of the examples in the book.</simpara>
</note>
</section>
<section id="_installing_lnd_from_source_code">
<title>Installing LND from Source Code</title>
<simpara><indexterm>
  <primary>Lightning Network Daemon (LND) node project</primary><secondary>installing LND from source code</secondary>
</indexterm>
<indexterm>
  <primary>installing LND from source code</primary>
</indexterm>In this section we will build LND from scratch. LND is written in the Go programming language. If you want to find out more about Go, search for <literal>golang</literal> instead of <literal>go</literal> to avoid irrelevant results. Because it is written in Go and not C or C++, it uses a different "build" framework than the GNU autotools/make framework we saw used in <literal>c-lightning</literal> previously. Don&#8217;t fret though, it is quite easy to install and use the golang tools, and we will show each step here. Go is a fantastic language for collaborative software development because it produces very consistent, precise, and easy-to-read code regardless of the number of authors. Go is focused and "minimalist" in a way that encourages consistency across versions of the language. As a compiled language, it is also quite efficient. Let&#8217;s dive in.</simpara>
<simpara>We will follow the installation instructions found in the <ulink url="https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md">LND project documentation</ulink>.</simpara>
<simpara>First, we will install the <literal>golang</literal> package and associated libraries. We strictly require Go version 1.13 or later. The official Go language packages are distributed as binaries from <ulink url="https://golang.org/dl">the Go Project</ulink>. For convenience they are also packaged as Debian packages available through the <literal>apt</literal> command. You can follow the instructions <ulink url="https://golang.org/dl">from the Go Project</ulink> or use the following <literal>apt</literal> commands on a Debian/Ubuntu Linux system as described on <ulink url="https://github.com/golang/go/wiki/Ubuntu">GitHub&#8217;s wiki page on the Go language</ulink>:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ sudo apt install golang-go</programlisting>
<simpara>Check that you have the correct version installed and ready to use by running:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ go version
go version go1.13.4 linux/amd64</programlisting>
<simpara>We have 1.13.4, so we&#8217;re ready to&#8230;Go! Next we need to tell any programs where to find the Go code. This is accomplished by setting the environment variable <literal>GOPATH</literal>. Usually the Go code is located in a directory named <emphasis>gocode</emphasis> directly in the user&#8217;s home directory. With the following two commands we consistently set the <literal>GOPATH</literal> and make sure your shell adds it to your executable <literal>PATH</literal>. Note that the user&#8217;s home directory is referred to as <literal>~</literal> in the shell.</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ export GOPATH=~/gocode
$ export PATH=$PATH:$GOPATH/bin</programlisting>
<simpara>To avoid having to set these environment variables every time you open a shell, you can add those two lines to the end of your <literal>bash</literal> shell configuration file <emphasis>.bashrc</emphasis> in your home directory, using the editor of your choice.</simpara>
</section>
<section id="_copying_the_lnd_source_code">
<title>Copying the LND Source Code</title>
<simpara><indexterm>
  <primary>Lightning Network Daemon (LND) node project</primary><secondary>copying LND source code</secondary>
</indexterm>
<indexterm>
  <primary>copying LND source code</primary>
</indexterm>As with many open source projects nowadays, the source code for LND is on GitHub (<emphasis>www.github.com</emphasis>). The <literal>go get</literal> command can fetch it directly using the Git protocol:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ go get -d github.com/lightningnetwork/lnd</programlisting>
<simpara>Once <literal>go get</literal> finishes, you will have a subdirectory under <literal>GOPATH</literal> that contains the LND source code.</simpara>
</section>
<section id="_compiling_the_lnd_source_code">
<title>Compiling the LND Source Code</title>
<simpara><indexterm>
  <primary>Lightning Network Daemon (LND) node project</primary><secondary>compiling LND source code</secondary>
</indexterm>
<indexterm>
  <primary>compiling LND source code</primary>
</indexterm>LND uses the <literal>make</literal> build system. To build the project, we change directory to LND&#8217;s source code and then use <literal>make</literal> like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ cd $GOPATH/src/github.com/lightningnetwork/lnd
$ make &amp;&amp; make install</programlisting>
<simpara>After several minutes you will have two new commands, <literal>lnd</literal> and <literal>lncli</literal>, installed. Try them out and check their version to ensure they are installed:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ lnd --version
lnd version 0.10.99-beta commit=clock/v1.0.0-106-gc1ef5bb908606343d2636c8cd345169e064bdc91
$ lncli --version
lncli version 0.10.99-beta commit=clock/v1.0.0-106-gc1ef5bb908606343d2636c8cd345169e064bdc91</programlisting>
<simpara>You will likely see a different version from that shown previously, as the software continues to evolve long after this book is published. However, no matter what version you see, the fact that the commands execute and show you version information means that you have succeeded in building the LND software.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_the_eclair_lightning_node_project">
<title>The Eclair Lightning Node Project</title>
<simpara><indexterm>
  <primary>Eclair Lightning node project</primary>
</indexterm><indexterm>
  <primary>Lightning node software</primary><secondary>Eclair Lightning node project</secondary>
</indexterm>
<indexterm>
  <primary>Eclair Lightning node project</primary>
</indexterm>Eclair (French for lightning) is a Scala implementation of the Lightning Network made by ACINQ. Eclair is also one of the most popular and pioneering mobile Lightning wallets, which we used to demonstrate a Lightning payment in <xref linkend="getting-started"/>. In this section we examine the Eclair server project, which runs a Lightning node. Eclair is an open source project and can be found on <ulink url="https://github.com/ACINQ/eclair">GitHub</ulink>.</simpara>
<simpara>In the next few sections we will build a Docker container to run Eclair, as we did previously with <literal>c-lightning</literal> and LND. We will also build Eclair directly from the source code.</simpara>
<section id="_the_eclair_docker_container">
<title>The Eclair Docker Container</title>
<simpara><indexterm>
  <primary>Eclair Lightning node project</primary><secondary>Docker container for</secondary>
</indexterm>
<indexterm>
  <primary>Docker container for</primary>
</indexterm>Let&#8217;s pull the book&#8217;s Eclair container from the Docker Hub repository:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker pull lnbook/eclair
Using default tag: latest
latest: Pulling from lnbook/eclair
35807b77a593: Already exists
e1b85b9c5571: Already exists

[...]

c7d5d5c616c2: Pull complete
Digest: sha256:17a3d52bce11a62381727e919771a2d5a51da9f91ce2689c7ecfb03a6f028315
Status: Downloaded newer image for lnbook/eclair:latest
docker.io/lnbook/eclair:latest</programlisting>
<simpara>Alternatively, we can build the container locally, instead. By now, you are almost an expert in the basic operations of Docker! In this section we will repeat many of the previously seen commands to build the Eclair container. The container is located in <emphasis>code/docker/eclair</emphasis>. We start in a terminal by switching the working directory to <emphasis>code/docker</emphasis> and issuing the <literal>docker build</literal> command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ cd code/docker
$ docker build -t lnbook/eclair eclair
Sending build context to Docker daemon  11.26kB
Step 1/27 : ARG OS=ubuntu
Step 2/27 : ARG OS_VER=focal
Step 3/27 : FROM ${OS}:${OS_VER} as os-base
 ---&gt; fb52e22af1b0

[...]

Step 27/27 : CMD ["/usr/local/bin/logtail.sh"]
 ---&gt; Running in fe639120b726
Removing intermediate container fe639120b726
 ---&gt; e6c8fe92a87c
Successfully built e6c8fe92a87c
Successfully tagged lnbook/eclair:latest</programlisting>
<simpara>Our image is now ready to run. The Eclair container also depends on a running instance of Bitcoin Core. As before, we need to start the <literal>bitcoind</literal> container in another terminal and connect Eclair to it via a Docker network. We have already set up a Docker network called <literal>lnbook</literal>, and will be reusing it here.</simpara>
<simpara>One notable difference between Eclair and LND or <literal>c-lightning</literal> is that Eclair doesn&#8217;t contain a separate bitcoin wallet but instead relies directly on the bitcoin wallet in Bitcoin Core. Recall that using LND we funded its bitcoin wallet by executing a transaction to transfer bitcoin from Bitcoin Core&#8217;s wallet to LND&#8217;s bitcoin wallet. This step is not necessary using Eclair. When running Eclair, the Bitcoin Core wallet is used directly as the source of funds to open channels. As a result, unlike the LND or <literal>c-lightning</literal> containers, the Eclair container does not contain a script to transfer bitcoin into its wallet on startup.</simpara>
</section>
<section id="_running_the_bitcoind_and_eclair_containers">
<title>Running the bitcoind and Eclair Containers</title>
<simpara><indexterm>
  <primary>bitcoind container</primary><secondary>and Eclair containers</secondary>
</indexterm>
<indexterm>
  <primary>and Eclair containers</primary>
</indexterm><indexterm>
  <primary>Eclair Lightning node project</primary><secondary>running bitcoind and Eclair containers</secondary>
</indexterm>
<indexterm>
  <primary>running bitcoind and Eclair containers</primary>
</indexterm>As before, we start the <literal>bitcoind</literal> container in one terminal and the Eclair container in another. If you already have the <literal>bitcoind</literal> container running, you do not need to restart it. Just leave it running and skip the next step. To start <literal>bitcoind</literal> in the <literal>lnbook</literal> network, we use <literal>docker run</literal> like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind</programlisting>
<simpara>Next, we start the Eclair container we just built. We will need to attach it to the <literal>lnbook</literal> network and give it a name, just as we did with the other containers:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker run -it --network lnbook --name eclair lnbook/eclair
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting eclair...
Eclair node started
INFO  o.b.Secp256k1Context - secp256k1 library successfully loaded
INFO  fr.acinq.eclair.Plugin - loading 0 plugins
INFO  a.e.slf4j.Slf4jLogger - Slf4jLogger started
INFO  fr.acinq.eclair.Setup - hello!
INFO  fr.acinq.eclair.Setup - version=0.4.2 commit=52444b0

[...]</programlisting>
<simpara>The Eclair container starts up and connects to the <literal>bitcoind</literal> container over the Docker network. First, our Eclair node will wait for <literal>bitcoind</literal> to start, and then it will wait until <literal>bitcoind</literal> has mined some bitcoin into its wallet.</simpara>
<simpara>As we demonstrated previously, we can issue commands to our container in another terminal to extract information, open channels, etc. The command that allows us to issue command-line instructions to the <literal>eclair</literal> daemon is called <literal>eclair-cli</literal>. As before, in this container we have provided a useful alias to <literal>eclair-cli</literal>, called simply <literal>cli</literal>, which offers the necessary arguments and parameters. Using the <literal>docker exec</literal> command in another terminal window, we get the node info from Eclair:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker exec eclair cli getinfo
{
  "version": "0.4.2-52444b0",
  "nodeId": "02fa6d5042eb8098e4d9c9d99feb7ebc9e257401ca7de829b4ce757311e0301de7",
  "alias": "eclair",
  "color": "#49daaa",
  "features": {

[...]

  },
  "chainHash": "06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f",
  "network": "regtest",
  "blockHeight": 779,
  "publicAddresses": [],
  "instanceId": "01eb7a68-5db0-461b-bdd0-29010df40d73"
}</programlisting>
<simpara>We now have another Lightning node running on the <literal>lnbook</literal> network and communicating with <literal>bitcoind</literal>. You can run any number and any combination of Lightning nodes on the same Lightning network. Any number of Eclair, LND, and <literal>c-lightning</literal> nodes can coexist. For example, to run a second Eclair node you would issue the <literal>docker run</literal> command with a different container name, as follows:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker run -it --network lnbook --name eclair2 lnbook/eclair</programlisting>
<simpara>In the preceding command we start another Eclair container named <literal>eclair2</literal>.</simpara>
<simpara>In the next section we will also look at how to download and compile Eclair directly from the source code. This is an optional and advanced step that will teach you how to use the Scala and Java language build tools and allow you to make modifications to Eclair&#8217;s source code. With this knowledge, you can write some code or fix some bugs.</simpara>
<note>
<simpara>If you are not planning on diving into the source code or programming of a Lightning node, you can skip the next section entirely. The Docker container we just built is sufficient for most of the examples in the book.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</note>
</section>
<section id="_installing_eclair_from_source_code">
<title>Installing Eclair from Source Code</title>
<simpara><indexterm>
  <primary>Eclair Lightning node project</primary><secondary>installing Eclair from source code</secondary>
</indexterm>
<indexterm>
  <primary>installing Eclair from source code</primary>
</indexterm>In this section we will build Eclair from scratch. Eclair is written in the Scala programming language, which is compiled using the Java compiler. To run Eclair, we first need to install Java and its build tools. We will be following the instructions found in <ulink url="https://github.com/ACINQ/eclair/blob/master/BUILD.md">the <emphasis>BUILD.md</emphasis> document</ulink> of the Eclair project.</simpara>
<simpara>The required Java compiler is part of OpenJDK 11. We will also need a build framework called Maven, version 3.6.0 or above.</simpara>
<simpara>On a Debian/Ubuntu Linux system, we can use the <literal>apt</literal> command to install both OpenJDK 11 and Maven, as shown in the following:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ sudo apt install openjdk-11-jdk maven</programlisting>
<simpara>Verify that you have the correct version installed by running:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ javac -version
javac 11.0.7
$ mvn -v
Apache Maven 3.6.1
Maven home: /usr/share/maven
Java version: 11.0.7, vendor: Ubuntu, runtime: /usr/lib/jvm/java-11-openjdk-amd64</programlisting>
<simpara>We have OpenJDK 11.0.7 and Maven 3.6.1, so we&#8217;re ready.</simpara>
</section>
<section id="_copying_the_eclair_source_code">
<title>Copying the Eclair Source Code</title>
<simpara><indexterm>
  <primary>Eclair Lightning node project</primary><secondary>copying Eclair source code</secondary>
</indexterm>
<indexterm>
  <primary>copying Eclair source code</primary>
</indexterm>The source code for Eclair is on GitHub. The <literal>git clone</literal> command can create a local copy for us. Let&#8217;s change to our home directory and run it there:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ cd ~
$ git clone https://github.com/ACINQ/eclair.git</programlisting>
<simpara>Once <literal>git clone</literal> finishes, you will have a subdirectory <literal>eclair</literal> containing the source code for the Eclair server.</simpara>
</section>
<section id="_compiling_the_eclair_source_code">
<title>Compiling the Eclair Source Code</title>
<simpara><indexterm>
  <primary>Eclair Lightning node project</primary><secondary>compiling Eclair source code</secondary>
</indexterm>
<indexterm>
  <primary>compiling Eclair source code</primary>
</indexterm>Eclair uses the <literal>Maven</literal> build system. To build the project, we change the working directory to Eclair&#8217;s source code and then use <literal>mvn package</literal> like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ cd eclair
$ mvn package
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO]
[INFO] --------------------&lt; fr.acinq.eclair:eclair_2.13 &gt;---------------------
[INFO] Building eclair_2.13 0.4.3-SNAPSHOT                                [1/4]
[INFO] --------------------------------[ pom ]---------------------------------

[...]


[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  01:06 min
[INFO] Finished at: 2020-12-12T09:43:21-04:00
[INFO] ------------------------------------------------------------------------</programlisting>
<simpara>After several minutes, the build of the Eclair package should complete. However, the "package" action will also run tests, and some of these connect to the internet and could fail. If you want to skip tests, add <literal>-DskipTests</literal> to the command.</simpara>
<simpara>Now, unzip and run the build package by following the <ulink url="https://github.com/ACINQ/eclair#installing-eclair">instructions for installing Eclair</ulink> from GitHub.</simpara>
<simpara>Congratulations! You have built Eclair from source and you are ready to code, test, fix bugs, and contribute to this project!<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_building_a_complete_network_of_diverse_lightning_nodes">
<title>Building a Complete Network of Diverse Lightning Nodes</title>
<simpara><indexterm>
  <primary>Lightning Network (example)</primary><secondary>building a complete network of diverse Lightning nodes</secondary>
</indexterm>
<indexterm>
  <primary>building a complete network of diverse Lightning nodes</primary>
</indexterm><indexterm>
  <primary>Lightning node software</primary><secondary>building a complete network of diverse Lightning nodes</secondary>
</indexterm>
<indexterm>
  <primary>building a complete network of diverse Lightning nodes</primary>
</indexterm>Our final example, presented in this section, will bring together all the various containers we&#8217;ve built to form a Lightning Network made of diverse (LND, <literal>c-lightning</literal>, Eclair) node implementations. We&#8217;ll compose the network by connecting the nodes together and opening channels from one node to another. As the final step, we&#8217;ll route a payment across these channels!</simpara>
<simpara>In this example, we will build a demonstration Lightning Network made of four Lightning nodes named Alice, Bob, Chan, and Dina. We will connect Alice to Bob, Bob to Chan, and Chan to Dina. This is shown in <xref linkend="alice_bob_chan_dina_network_demo"/>.</simpara>
<figure id="alice_bob_chan_dina_network_demo"><title>A small demonstration network of four nodes</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1002.png"/>
  </imageobject>
  <textobject><phrase>A small demonstration network of four nodes</phrase></textobject>
</mediaobject>
</figure>
<simpara>Finally, we will have Dina create an invoice and have Alice pay that invoice. Since Alice and Dina are not directly connected, the payment will be routed as an HTLC across all the payment channels.</simpara>
<section id="_using_docker_compose_to_orchestrate_docker_containers">
<title>Using docker-compose to Orchestrate Docker Containers</title>
<simpara><indexterm>
  <primary>docker-compose</primary><secondary>orchestrating Docker containers with</secondary>
</indexterm>
<indexterm>
  <primary>orchestrating Docker containers with</primary>
</indexterm><indexterm>
  <primary>Lightning Network (example)</primary><secondary>using docker-compose to orchestrate Docker containers</secondary>
</indexterm>
<indexterm>
  <primary>using docker-compose to orchestrate Docker containers</primary>
</indexterm>To make this example work, we will be using a <emphasis>container orchestration</emphasis> tool that is available as a command called <literal>docker-compose</literal>. This command allows us to specify an application composed of several containers and run the application by launching all the cooperating containers together.</simpara>
<simpara>First, let&#8217;s install <literal>docker-compose</literal>. The <ulink url="https://docs.docker.com/compose/install">instructions</ulink> depend on your operating system.</simpara>
<simpara>Once you have completed installation, you can verify your installation by running <literal>docker-compose</literal> like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker-compose version
docker-compose version 1.21.0, build unknown
[...]</programlisting>
<simpara>The most common <literal>docker-compose</literal> commands we will use are <literal>up</literal> and <literal>down</literal>, e.g., <literal>docker-compose up</literal>.</simpara>
</section>
<section id="_docker_compose_configuration">
<title>docker-compose Configuration</title>
<simpara><indexterm>
  <primary>docker-compose</primary><secondary>configuration</secondary>
</indexterm>
<indexterm>
  <primary>configuration</primary>
</indexterm><indexterm>
  <primary>Lightning Network (example)</primary><secondary>docker-compose configuration</secondary>
</indexterm>
<indexterm>
  <primary>docker-compose configuration</primary>
</indexterm>The configuration file for <literal>docker-compose</literal> is found in the <emphasis>code/docker</emphasis> directory and is named <emphasis>docker-compose.yml</emphasis>. It contains a specification for a network and each of the four containers. The top looks like this:</simpara>
<screen>version: "3.3"
networks:
  lnnet:

services:
  bitcoind:
    container_name: bitcoind
    build:
        context: bitcoind
    image: lnbook/bitcoind:latest
    networks:
      - lnnet
    expose:
      - "18443"
      - "12005"
      - "12006"

  Alice:
    container_name: Alice</screen>
<simpara>The preceding fragment defines a network called <literal>lnnet</literal> and a container called <literal>bitcoind</literal> which will attach to the <literal>lnnet</literal> network. The container is the same one we built at the beginning of this chapter. We expose three of the container&#8217;s ports, allowing us to send commands to it and monitor blocks and transactions. Next, the configuration specifies an LND container called "Alice." Further down you will also see specifications for containers called "Bob" (<literal>c-lightning</literal>), "Chan" (Eclair), and "Dina" (LND again).</simpara>
<simpara>Since all these diverse implementations follow the BOLT specification and have been extensively tested for interoperability, they have no difficulty working together to build a Lightning network.</simpara>
</section>
<section id="_starting_the_example_lightning_network">
<title>Starting the Example Lightning Network</title>
<simpara><indexterm>
  <primary>Lightning Network (example)</primary><secondary>starting the network</secondary>
</indexterm>
<indexterm>
  <primary>starting the network</primary>
</indexterm>Before we get started, we should make sure we&#8217;re not already running any of the containers. If a new container shares the same name as one that is already running, then it will fail to launch. Use <literal>docker ps</literal>, <literal>docker stop</literal>, and <literal>docker rm</literal> as necessary to stop and remove any currently running containers!</simpara>
<tip>
<simpara>Because we use the same names for these orchestrated Docker containers, we might need to "clean up" to avoid any name conflicts.</simpara>
</tip>
<simpara role="pagebreak-before">To start the example, we switch to the directory that contains the <emphasis>docker-compose.yml</emphasis> configuration file and we issue the command <literal>docker-compose up</literal>:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ cd code/docker
$ docker-compose up
Creating Chan     ... done
Creating Dina     ... done
Creating bitcoind ... done
Creating Bob      ... done
Creating Alice    ... done
Attaching to Chan, Dina, Alice, bitcoind, Bob
Alice       | Waiting for bitcoind to start...
Bob         | Waiting for bitcoind to start...
Dina        | Waiting for bitcoind to start...
Chan        | Waiting for bitcoind to start...
bitcoind    | Starting bitcoind...
bitcoind    | Waiting for bitcoind to start
bitcoind    | bitcoind started
bitcoind    | ================================================

[...]

Chan        | Starting eclair...
Dina        | Starting lnd...
Chan        | Eclair node started
Alice       | ...Waiting for bitcoind to mine blocks...
Bob         | ...Waiting for bitcoind to mine blocks...
Alice       | Starting lnd...
Bob         | Starting c-lightning...

[...]</programlisting>
<simpara>Following the startup, you will see a whole stream of logfiles as each node starts up and reports its progress. It may look quite jumbled on your screen, but each output line is prefixed by the container name, as seen previously. If you wanted to watch the logs from only one container, you can do so in another terminal window by using the <literal>docker-compose logs</literal> command with the <literal>f</literal> (<emphasis>follow</emphasis>) flag and the specific container name:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ docker-compose logs -f Alice</programlisting>
</section>
<section id="_opening_channels_and_routing_a_payment">
<title>Opening Channels and Routing a Payment</title>
<simpara><indexterm>
  <primary>Lightning Network (example)</primary><secondary>opening channels and routing a payment</secondary>
</indexterm>
<indexterm>
  <primary>opening channels and routing a payment</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>opening in Lightning Network</secondary>
</indexterm>
<indexterm>
  <primary>opening in Lightning Network</primary>
</indexterm><indexterm>
  <primary>routing</primary><secondary>Lightning Network example</secondary>
</indexterm>
<indexterm>
  <primary>Lightning Network example</primary>
</indexterm>Our Lightning network should now be running. As we saw in the previous sections of this chapter, we can issue commands to a running Docker container with the <literal>docker exec</literal> command. Regardless of whether we started the container with <literal>docker run</literal> or started a bunch of them with <literal>docker-compose up</literal>, we can still access containers individually using the Docker commands.</simpara>
<simpara>The payment demo is contained in a Bash shell script called <literal>run-payment-demo.sh</literal>. To run this demo you must have the Bash shell installed on your computer. Most Linux and Unix-like systems (e.g., macOS) have <literal>bash</literal> preinstalled. Windows users can install the Windows Subsystem for Linux and use a Linux distribution like Ubuntu to get a native <literal>bash</literal> command on their computer.</simpara>
<simpara>Let&#8217;s run the script to see its effect, and then we will look at how it works internally. We use <literal>bash</literal> to run it as a command:</simpara>
<screen>$ cd code/docker
$ bash run-payment-demo.sh
Starting Payment Demo
======================================================

Waiting for nodes to startup
- Waiting for bitcoind startup...
- Waiting for bitcoind mining...
- Waiting for Alice startup...
- Waiting for Bob startup...
- Waiting for Chan startup...
- Waiting for Dina startup...
All nodes have started
======================================================

Getting node IDs
- Alice:  0335e200756e156f1e13c3b901e5ed5a28b01a3131cd0656a27ac5cc20d4e71129
- Bob:    033e9cb673b641d2541aaaa821c3f9214e8a11ada57451ed5a0eab2a4afbce7daa
- Chan:   02f2f12182f56c9f86b9aa7d08df89b79782210f0928cb361de5138364695c7426
- Dina: 02d9354cec0458e0d6dee5cfa56b83040baddb4ff88ab64960e0244cc618b99bc3
======================================================

[...]

Setting up connections and channels
- Alice to Bob
- Open connection from Alice node to Bob's node

- Create payment channel Alice-&gt;Bob


[...]

Get 10k sats invoice from Dina
- Dina invoice:
lnbcrt100u1psnuzzrpp5rz5dg4wy27973yr7ehwns5ldeusceqdaq0hguu8c29n4nsqkznjsdqqcqzpgxqyz5vqsp5vdpehw33fljnmmexa6ljk55544f3syd8nfttqlm3ljewu4r0q20q9qyyssqxh5nhkpjgfm47yxn4p9ecvndz7zddlsgpufnpyjl0kmnq227tdujlm0acdv39hcuqp2vhs40aav70c9yp0tee6tgzk8ut79mr877q0cpkjcfvr
======================================================

Attempting payment from Alice to Dina
Successful payment!</screen>
<simpara>As you can see from the output, the script first gets the node IDs (public keys) for each of the four nodes. Then, it connects the nodes and sets up a 1,000,000 satoshi channel from each node to the next in the network. Finally, it issues an invoice for 10,000 satoshis from Dina&#8217;s node and pays the invoice from Alice&#8217;s node.</simpara>
<tip>
<simpara>If the script fails, you can try running it again from the beginning. Or you can manually issue the commands found in the script one by one and look at the results.</simpara>
</tip>
<simpara>There is a lot to review in that script, but as you gain understanding of the underlying technology, more and more of that information will become clear. You are invited to revisit this example later.</simpara>
<simpara>Of course, you can do a lot more with this test network than a three-channel, four-node payment. Here are some ideas for your experiments:</simpara>
<itemizedlist>
<listitem>
<simpara>
Create a more complex network by launching many more nodes of different types. Edit the <emphasis>docker-compose.yml</emphasis> file and copy sections, renaming containers as needed.
</simpara>
</listitem>
<listitem>
<simpara>
Connect the nodes in more complex topologies: circular routes, hub-and-spoke, or full mesh.
</simpara>
</listitem>
<listitem>
<simpara>
Run lots of payments to exhaust channel capacity. Then run payments in the opposite direction to rebalance the channels. See how the routing algorithm adapts.
</simpara>
</listitem>
<listitem>
<simpara>
Change the channel fees to see how the routing algorithm negotiates multiple routes and what optimizations it applies. Is a cheap, long route better than an expensive, short route?
</simpara>
</listitem>
<listitem>
<simpara>
Run a circular payment from a node back to itself in order to rebalance its own channels. See how that affects all the other channels and nodes.
</simpara>
</listitem>
<listitem>
<simpara>
Generate hundreds or thousands of small invoices in a loop and then pay them as fast as possible in another loop. Measure how many transactions per second you can squeeze out of this test network.
</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara><ulink url="https://lightningpolar.com">Lightning Polar</ulink> allows you to visualize the network you have been experimenting with using Docker<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm>.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</tip>
</section>
</section>
<section id="_conclusion_4">
<title>Conclusion</title>
<simpara>In this chapter we looked at various projects that implement the BOLT specifications. We built containers to run a sample Lightning network and learned how to build each project from source code. You are now ready to explore further and dig deeper.<indexterm>
</indexterm></simpara>
</section>
</chapter>
<chapter id="node_operations">
<title>Operating a Lightning Network Node</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary>
</indexterm>After having read this far, you have probably set up a Lightning wallet. In this chapter, we will take things one step further and set up a full Lightning node. In addition to setting one up, we will learn how to operate it and maintain it over time.</simpara>
<simpara>There are many reasons why you might want to set up your own Lightning node. They include:</simpara>
<itemizedlist>
<listitem>
<simpara>
To be a full, active participant in the Lightning Network, not just an end user
</simpara>
</listitem>
<listitem>
<simpara>
To run an ecommerce store or receive income via Lightning payments
</simpara>
</listitem>
<listitem>
<simpara>
To earn income from Lightning routing fees or by renting channel liquidity
</simpara>
</listitem>
<listitem>
<simpara>
To develop new services, applications, or plug-ins for the Lightning Network
</simpara>
</listitem>
<listitem>
<simpara>
To increase your financial privacy while using Lightning
</simpara>
</listitem>
<listitem>
<simpara>
To use some apps built on top of Lightning, like Lightning-powered instant messaging apps
</simpara>
</listitem>
<listitem>
<simpara>
For financial freedom, independence, and sovereignty
</simpara>
</listitem>
</itemizedlist>
<simpara>There are costs associated with running an LN node. You need a computer, a permanent internet connection, lots of disk space, and lots of time!
Operational costs will include electricity expenses.</simpara>
<simpara>But the skills you will learn from this experience are valuable and can be applied to a variety of other tasks too.</simpara>
<simpara>Let&#8217;s get started!</simpara>
<note>
<simpara>It is important that you set your own expectations correctly on accurate facts.
If you plan to operate a Lightning node <emphasis>solely</emphasis> to gain income by earning routing fees,
please do your homework diligently first. Running a profitable business by operating a Lightning node is
definitely <emphasis>not</emphasis> easy. Calculate all your initial and ongoing costs in a spreadsheet. Study LN statistics carefully.
What is the current payment volume? What is the volume per node? What are the current average routing fees? Consult forums and ask
for advice or feedback from other community members who have already gained real-world experience. Form your own educated opinion only
<emphasis>after</emphasis> you have done this due diligence exercise. Most people will find their motivation for running a node not in financial gain,
but somewhere else.</simpara>
</note>
<section id="_choosing_your_platform">
<title>Choosing Your Platform</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>choosing a platform</secondary>
</indexterm>
<indexterm>
  <primary>choosing a platform</primary>
</indexterm>There are many ways you can run a Lightning node, ranging from a small mini PC hosted in your home or a dedicated server, to a hosted server in the cloud. The method you choose will depend on the resources you have and how much money you want to spend.</simpara>
<section id="continuous_operation">
<title>Why Is Reliability Important for Running a Lightning Node?</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>reliability issues</secondary>
</indexterm>
<indexterm>
  <primary>reliability issues</primary>
</indexterm><indexterm>
  <primary>reliability, Lightning node and</primary>
</indexterm>In Bitcoin, hardware is not particularly important unless one is specifically running a mining node.
The Bitcoin Core node software can be run on any machine that meets its minimum requirements and does not need to be online to receive payments—only to send them.
If a Bitcoin node goes down for an extended period of time, the user can simply reboot the node, and once it connects to the rest of the network, it will resync the blockchain.</simpara>
<simpara>In Lightning, however, the user needs to be online both to send <emphasis>and</emphasis> to receive payments. If the Lightning node is offline, it cannot receive any payments from anyone, and thus its open invoices cannot be fulfilled.
Furthermore, the open channels of an offline node cannot be used to route payments. Your channel partners will notice that you are offline and cannot contact you to route a payment. If you are offline too often, they may consider the bitcoin locked up in their channels with you to be underutilized capacity, and may close those channels. We already discussed the case of a protocol attack in which your channel partner tries to cheat you by submitting an earlier commitment transaction. If you are offline and your channels aren&#8217;t being monitored, then the attempted theft could succeed, and you will have no recourse once the timelock expires.
Hence, node reliability is extremely important for a Lightning node.</simpara>
<simpara><indexterm>
  <primary>hardware failure</primary>
</indexterm>There are also the issues of hardware failure and loss of data. In Bitcoin, a hardware failure can be a trivial problem if the user has a backup of their mnemonic phrase or private keys. The Bitcoin wallet and the bitcoin inside the wallet can be easily restored from the private keys on a new computer. Most information can be redownloaded from the blockchain.</simpara>
<simpara>In contrast, in Lightning the information about the user&#8217;s channels, including the commitment transactions and revocation secrets, are not publicly known and are only stored on the individual user&#8217;s hardware.
Thus, software and hardware failures in the Lightning Network can easily result in loss of funds.</simpara>
</section>
<section id="_types_of_hardware_lightning_nodes">
<title>Types of Hardware Lightning Nodes</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>types of hardware Lightning nodes</secondary>
</indexterm>
<indexterm>
  <primary>types of hardware Lightning nodes</primary>
</indexterm>There are three main types of hardware Lightning nodes:</simpara>
<variablelist>
<varlistentry>
<term>
General-purpose computers
</term>
<listitem>
<simpara>
An LN node can be run on a home computer or laptop running Windows, macOS, or Linux. Typically this is run alongside a Bitcoin node.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Dedicated hardware
</term>
<listitem>
<simpara>
A Lightning node can also be run on dedicated hardware like a Raspberry Pi, Rock64, or mini PC. This setup would usually run a software stack, including a Bitcoin node and other applications. This setup is popular because the hardware is dedicated to running and maintaining the Lightning node only and is usually set up with an installation "helper."
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Preconfigured hardware
</term>
<listitem>
<simpara>
An LN node can also be run on purpose-built hardware specifically selected and configured for it. This would include "out-of-the-box" Lightning node solutions that can be purchased as a kit or a turnkey system.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_running_in_the_cloud">
<title>Running in the "Cloud"</title>
<simpara><indexterm>
  <primary>cloud, Lightning node operation in</primary>
</indexterm><indexterm>
  <primary>Lightning node operation</primary><secondary>running in the cloud</secondary>
</indexterm>
<indexterm>
  <primary>running in the cloud</primary>
</indexterm><indexterm>
  <primary>virtual private server (VPS)</primary>
</indexterm><emphasis>Virtual private server</emphasis> (VPS) and cloud computing services such as Microsoft Azure, Google Cloud, Amazon Web Services (AWS), or DigitalOcean are quite affordable and can be set up very quickly. A Lightning node can be hosted for between $20 and $40 per month on such a service.</simpara>
<simpara>However, as the saying goes, "&lsquo;Cloud&rsquo; is just other people&#8217;s computers." Using these services means running your node on other people&#8217;s computers. This brings along the corresponding advantages and disadvantages. The key advantages are convenience, efficiency, uptime, and possibly even cost. The cloud operator manages and runs the node to a high degree, automatically providing you with convenience and efficiency. They provide excellent uptime and availability, often much better than what an individual can achieve at home. If you consider that just the electricity cost of running a server in many Western countries is around $10 per month, then add to that the cost of network bandwidth and the hardware itself, the VPS offering becomes financially competitive. Lastly, with a VPS you need no space for a PC at home and don&#8217;t have any issues with PC noise or heat.
On the other hand, there are several notable disadvantages. A Lightning node running in the "cloud" will always be less secure and less private than one running on your own computer. Additionally, these cloud computing services are very centralized. The vast majority of Bitcoin and Lightning nodes running on such services are located in a handful of data centers in Virginia, Sunnyvale, Seattle, London, and Frankfurt. When the networks or data centers of these providers have service problems, it affects thousands of nodes on so-called "decentralized" networks.</simpara>
<simpara>If you have the possibility and capacity of running a node on your own computer at home or in your office, then this might be preferable to running it
in the cloud. Nonetheless, if running your own server is not an option, by all means consider running one on a VPS.</simpara>
</section>
<section id="_running_a_node_at_home">
<title>Running a Node at Home</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>running a node at home</secondary>
</indexterm>
<indexterm>
  <primary>running a node at home</primary>
</indexterm>If you have a reasonable-capacity internet connection at home or in your office, you can certainly run a Lightning node there. Any "broadband" connection is sufficient for the purpose of running a lightweight node, and a fast connection will allow you to run a Bitcoin full node too.</simpara>
<simpara>While you can run a Lightning node (and even a Bitcoin node) on your laptop, it will become annoying quite fast. These programs consume your computer&#8217;s resources and need to run 24/7. Your user applications like your browser or your spreadsheet will be competing against the Lightning background services for your computer&#8217;s resources. In other words, your browser and other desktop workloads will be slowed down.
And when your word-processing app freezes up your laptop, your Lightning node will go down as well, leaving you unable to receive transactions and potentially vulnerable to attacks. Furthermore, you should never turn off your laptop.
All this combined together results in a setup that is not ideal. The same will apply to your daily-use personal desktop PC.</simpara>
<simpara>Instead, most users will choose to run a node on a dedicated computer.
Fortunately, you don&#8217;t need a "server" class computer to do this.
You can run a Lightning node on a single-board computer, such as a Raspberry Pi or on a mini PC (usually marketed as home theater PCs).
These are simple computers which are commonly used as a home automation hub or a media server.
They are relatively inexpensive when compared to a PC or a laptop.
The advantage of a dedicated device as a platform for Lightning and Bitcoin nodes is that it can run continuously, silently, and unobtrusively on your home network, tucked behind your router or TV.
No one will even know that this little box is actually part of a global banking system!</simpara>
<warning>
<simpara>Operating a node on a 32-bit operating system and/or 32-bit CPU is not recommended, because the node software may run into resource issues, causing a crash and possibly a loss of funds.</simpara>
</warning>
</section>
<section id="_what_hardware_is_required_to_run_a_lightning_node">
<title>What Hardware Is Required to Run a Lightning Node?</title>
<simpara><indexterm>
  <primary>hardware, Lightning node</primary>
</indexterm><indexterm>
  <primary>Lightning node operation</primary><secondary>hardware requirements</secondary>
</indexterm>
<indexterm>
  <primary>hardware requirements</primary>
</indexterm>At a minimum, the following are required to run a Lightning node:</simpara>
<variablelist>
<varlistentry>
<term>
CPU
</term>
<listitem>
<simpara>
Sufficient processing power is required to run a Bitcoin node, which will continuously download and validate new blocks. The user also needs to consider the initial block download (IBD) when setting up a new Bitcoin node, which can take anywhere from several hours to several days. A 2-core or 4-core CPU is recommended.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
RAM
</term>
<listitem>
<simpara>
A system with 2 GB of RAM will <emphasis>barely</emphasis> run both Bitcoin and Lightning nodes. It will perform much better with at least 4 GB of RAM. The IBD will be especially challenging with less than 4 GB of RAM. More than 8 GB of RAM is unnecessary because the CPU is the greater bottleneck for these types of services, due to cryptographic operations such as signature validation.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Storage drive
</term>
<listitem>
<simpara>
This can be a hard disk drive (HDD) or a solid state drive (SSD).
An SSD will be significantly quicker (but more expensive) for running a node.
Most of the storage is used for the Bitcoin blockchain, which is hundreds of gigabytes in size.
A fair trade-off (cost for complexity) is to buy a small SSD to boot the OS from, and a larger HDD to store large data objects (mostly databases).
</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>Raspberry Pis are a common choice for running node software, due to the cost and parts availability.
The OS that runs on the device usually boots from a secure digital (SD) card.
For most use cases, this is a nonissue, but Bitcoin Core is notorious for being I/O heavy.
You should make sure to place the Bitcoin blockchain and Lightning data directory on a different drive because long-term intensive I/O can cause an SD card to fail.</simpara>
</note>
<variablelist>
<varlistentry>
<term>
Internet connection
</term>
<listitem>
<simpara>
A reliable internet connection is required to download new Bitcoin blocks, as well as to communicate with other Lightning peers. During operation the estimated data use ranges from 10 to 100 GB per month, depending on configuration. At startup, a Bitcoin full node downloads the full blockchain.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Power supply
</term>
<listitem>
<simpara>
A reliable power supply is required because Lightning nodes need to be online at all times. A power failure will cause in-progress payments to fail. For heavy duty routing nodes, a backup or uninterruptible power supply (UPS) is useful in the event of power outages.
Ideally, you should connect your internet router to this UPS as well.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Backup
</term>
<listitem>
<simpara>
Backup is crucial because a failure can result in loss of data and hence in loss of funds.
You will want to consider some kind of data backup solution. This could be a cloud-based automated backup to a server or web service you control. Alternatively, it could be an automated local hardware backup, such as a second hard drive. For best results, both local and remote backup can be combined.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_switching_server_configuration_in_the_cloud">
<title>Switching Server Configuration in the Cloud</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>switching server configuration in the cloud</secondary>
</indexterm>
<indexterm>
  <primary>switching server configuration in the cloud</primary>
</indexterm>When renting a cloud server, it is often cost effective to change the configuration between two phases of operation. A faster CPU and faster storage will be needed during the IBD (e.g., the first day). After the blockchain has synced, the CPU and storage speed requirements are much less, so the performance can be downgraded to a more cost-effective level.</simpara>
<simpara>For example, on Amazon&#8217;s cloud, we would use an 8&ndash;16 GB RAM, 8-core CPU (e.g., t3-large or m3.large) and faster 400 GB SSD (1000+ provisioned input/output operations per second [IOPS]) for the IBD, reducing its time to just 6-8 hours. Once that is complete, we would switch the server instance to a 2 GB RAM, 2-core CPU (e.g., t3.small) and storage to a general purpose 1 TB HDD. This will cost about the same as if you ran it on the slower server the entire time, but it will get you up and running in less than a day instead of having to wait almost a week for the IBD.</simpara>
<section id="_permanent_data_storage_drive">
<title>Permanent data storage (drive)</title>
<simpara><indexterm>
  <primary>data storage</primary>
</indexterm><indexterm>
  <primary>Lightning node operation</primary><secondary>permanent data storage</secondary>
</indexterm>
<indexterm>
  <primary>permanent data storage</primary>
</indexterm>If you use a mini PC or rent a server, the storage can be the most expensive part, costing as much as the computer and connectivity (data) added together.</simpara>
<simpara>Let&#8217;s have a look at the different options available. First, there are two main types of drives, HDDs and SSDs. HDDs are cheaper and SSDs are faster, but both do the job.</simpara>
<simpara><indexterm>
  <primary>Non-Volatile Memory Express (NVMe)</primary>
</indexterm><indexterm>
  <primary>solid state drives (SSDs)</primary>
</indexterm><indexterm>
  <primary>SSDs (solid state drives)</primary>
</indexterm>The fastest SSDs available today use the Non-Volatile Memory Express (NVMe) interface. The NVMe SSDs are faster in high-end machines, but also more costly.
Traditional SATA-based SSDs are cheaper, but not as fast. SATA SSDs perform sufficiently well for your node setup.
Smaller computers might not be able to take advantage of NVMe SSDs.
For example, the Raspberry Pi 4 cannot benefit from them because of the limited bandwidth of its USB port.</simpara>
<simpara>To choose the size, let&#8217;s look at the Bitcoin blockchain. As of August 2021, its size is 360 GB, including the transaction index, and grows by roughly 60 GB per year. If you want to have some margin available for future growth or to install other data on your node, purchase at least a 512 GB drive, or better yet, a 1 TB drive.<indexterm>
</indexterm></simpara>
</section>
</section>
</section>
<section id="helpers">
<title>Using an Installer or Helper</title>
<simpara><indexterm>
  <primary>helpers (installation/configuration software)</primary>
</indexterm><indexterm>
  <primary>Lightning node operation</primary><secondary>using an installer or helper</secondary>
</indexterm>
<indexterm>
  <primary>using an installer or helper</primary>
</indexterm>Installing a Lightning node or a Bitcoin node may be daunting if you are not familiar with a command-line environment. Luckily, there are a number of projects that make "helpers," i.e., software that installs and configures the various components for you. You will still need to learn some command-line incantations to interact with your node, but most of the initial work is done for you.</simpara>
<section id="_raspiblitz">
<title>RaspiBlitz</title>
<simpara><indexterm>
  <primary>helpers (installation/configuration software)</primary><secondary>RaspiBlitz</secondary>
</indexterm>
<indexterm>
  <primary>RaspiBlitz</primary>
</indexterm><indexterm>
  <primary>RaspiBlitz</primary>
</indexterm>One of the most popular and complete "helpers" is <emphasis>RaspiBlitz</emphasis> (<xref linkend="RaspiBlitz"/>), a project built by Christian Rotzoll. It is intended to be installed on a Raspberry Pi 4. RaspiBlitz comes with a recommended hardware kit that you can build in a matter of hours or at most a weekend. If you attend a Lightning "hackathon" in your city, you are likely to see many people working on their RaspiBlitz setup, swapping tips, and helping each other. You can find the RaspiBlitz project on <ulink url="https://github.com/rootzoll/raspiblitz">GitHub</ulink>.</simpara>
<simpara>In addition to a Bitcoin and Lightning node, RaspiBlitz can install a number of additional services, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>
Tor (run as hidden service)
</simpara>
</listitem>
<listitem>
<simpara>
ElectRS (Electrum server in Rust)
</simpara>
</listitem>
<listitem>
<simpara>
BTCPay Server (cryptocurrency payment processor)
</simpara>
</listitem>
<listitem>
<simpara>
BTC RPC Explorer (Bitcoin blockchain explorer)
</simpara>
</listitem>
<listitem>
<simpara>
Ride The Lightning (Lightning node management GUI)
</simpara>
</listitem>
<listitem>
<simpara>
LNbits (Lightning wallet/accounts system)
</simpara>
</listitem>
<listitem>
<simpara>
Specter Desktop (multisig Trezor, Ledger, Coldcard wallet, and Specter-DIY)
</simpara>
</listitem>
<listitem>
<simpara>
lndmanage (command-line interface for advanced channel management)
</simpara>
</listitem>
<listitem>
<simpara>
Loop (submarine swaps service)
</simpara>
</listitem>
<listitem>
<simpara>
JoinMarket (CoinJoin service)
</simpara>
</listitem>
</itemizedlist>
<figure id="RaspiBlitz"><title>A RaspiBlitz node</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0501.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_0501.png</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_mynode">
<title>Mynode</title>
<simpara><indexterm>
  <primary>helpers (installation/configuration software)</primary><secondary>myNode</secondary>
</indexterm>
<indexterm>
  <primary>myNode</primary>
</indexterm><indexterm>
  <primary>myNode</primary>
</indexterm><ulink url="https://mynodebtc.com"><emphasis>myNode</emphasis></ulink> is another popular open source "helper" project including a lot of Bitcoin related software. It is easy to install: you "flash" the installer onto an SD card and boot your mini PC from the SD card. You do not need any monitor to use myNode because the administrative tools are accessible remotely from a browser. If your mini PC has no monitor, mouse, or keyboard, you can manage it from another computer or even from your smartphone. Once installed, go to <ulink url="http://mynode.local">http://mynode.local</ulink> and create a Lightning wallet and node in two clicks.</simpara>
<simpara>In addition to a Bitcoin and Lightning node, myNode can optionally install a variety of additional services, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>
Ride The Lightning (Lightning node management GUI)
</simpara>
</listitem>
<listitem>
<simpara>
OpenVPN (virtual private network [VPN] support for remote management or wallet)
</simpara>
</listitem>
<listitem>
<simpara>
lndmanage (command-line interface for advanced channel management)
</simpara>
</listitem>
<listitem>
<simpara>
BTC RPC Explorer (a Bitcoin blockchain explorer)
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_umbrel">
<title>Umbrel</title>
<simpara><indexterm>
  <primary>helpers (installation/configuration software)</primary><secondary>Umbrel</secondary>
</indexterm>
<indexterm>
  <primary>Umbrel</primary>
</indexterm><indexterm>
  <primary>Umbrel</primary>
</indexterm>Famous for their UX/UI (shown in <xref linkend="umbrel"/>), <emphasis>Umbrel</emphasis> provides a very easy and accessible way to get your Bitcoin and Lightning node up and running in no time, especially for beginners. A very distinctive feature is that Umbrel utilizes Neutrino/SPV during the IBD so you can instantly start using your node. Once Bitcoin Core is fully synced in the background, it automatically switches over and disables SPV mode. Umbrel OS supports the Raspberry Pi 4 and can also be installed on any Linux-based OS or on a virtual machine on macOS or Windows. You can also connect any wallet that supports Bitcoin Core P2P, Bitcoin Core RPC, the Electrum protocol, or lndconnect.</simpara>
<simpara>There&#8217;s no need to wait for a rainy day&mdash;you can go right to <ulink url="https://getumbrel.com">Umbrel</ulink> to learn more.</simpara>
<figure id="umbrel"><title>The Umbrel web interface</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0502.png"/>
  </imageobject>
  <textobject><phrase>The Umbrel web interface</phrase></textobject>
</mediaobject>
</figure>
<simpara>In addition to a Bitcoin and Lightning node, Umbrel introduced the Umbrel App Store, where you can easily install additional services, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>
Lightning Terminal (interface for managing channel liquidity, Loop In, and Loop Out)
</simpara>
</listitem>
<listitem>
<simpara>
Ride The Lightning (Lightning node management GUI)
</simpara>
</listitem>
<listitem>
<simpara>
Specter Desktop (watch-only coordinator for multisignature and single-key Bitcoin wallets)
</simpara>
</listitem>
<listitem>
<simpara>
BTCPay Server (cryptocurrency payment processor)
</simpara>
</listitem>
<listitem>
<simpara>
BTC RPC Explorer (Bitcoin blockchain explorer)
</simpara>
</listitem>
<listitem>
<simpara>
ThunderHub (monitor and manage your node)
</simpara>
</listitem>
<listitem>
<simpara>
Sphinx Relay (handling connectivity and storage for Sphinx chat)
</simpara>
</listitem>
<listitem>
<simpara>
mempool.space (mempool visualizer and block explorer)
</simpara>
</listitem>
<listitem>
<simpara>
LNbits (Lightning wallet/accounts system)
</simpara>
</listitem>
</itemizedlist>
<simpara>Umbrel is currently still in beta and is not considered secure.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
<section id="_btcpay_server">
<title>BTCPay Server</title>
<simpara><indexterm>
  <primary>BTCPay Server</primary>
</indexterm><indexterm>
  <primary>helpers (installation/configuration software)</primary><secondary>BTCPay Server</secondary>
</indexterm>
<indexterm>
  <primary>BTCPay Server</primary>
</indexterm>While not initially designed as an installation "helper," the ecommerce and payment platform <emphasis>BTCPay Server</emphasis> has an incredibly easy installation system that uses Docker containers and <literal>docker-compose</literal> to install a Bitcoin node, Lightning node, and payment gateway, among many other services. It can be installed on a variety of hardware platforms, from a simple Raspberry Pi 4 (4 GB recommended) to a mini PC or old laptop, desktop, or server.</simpara>
<simpara><ulink url="https://btcpayserver.org">BTCPay Server</ulink> is a fully featured self-hosted, self-custody ecommerce platform that can be integrated with many ecommerce platforms, such as WordPress WooCommerce and others. The installation of the full node is only a step of the ecommerce platform installation.
While originally developed as a feature-for-feature replacement of the <emphasis>BitPay</emphasis> commercial payment service and API, it has evolved past that to be a complete platform for BTC and Lightning services related to ecommerce. For many sellers or shops it is a one-shop turnkey solution to ecommerce.</simpara>
<simpara>In addition to a Bitcoin and Lightning node, BTCPay Server can also install a variety of services, including:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>c-lightning</literal> or LND Lightning node
</simpara>
</listitem>
<listitem>
<simpara>
Litecoin support
</simpara>
</listitem>
<listitem>
<simpara>
Monero support
</simpara>
</listitem>
<listitem>
<simpara>
Spark server (<literal>c-lightning</literal> web wallet)
</simpara>
</listitem>
<listitem>
<simpara>
Charge server (<literal>c-lightning</literal> ecommerce API)
</simpara>
</listitem>
<listitem>
<simpara>
Ride The Lightning (Lightning node management web GUI)
</simpara>
</listitem>
<listitem>
<simpara>
Many BTC forks
</simpara>
</listitem>
<listitem>
<simpara>
BTCTransmuter (event-action automation service supporting currency exchange)
</simpara>
</listitem>
</itemizedlist>
<simpara>The number of additional services and features is growing rapidly, so the preceding list is only a small subset of what is available on the BTCPay Server platform.</simpara>
</section>
<section id="_bitcoin_node_or_lightweight_lightning">
<title>Bitcoin Node or Lightweight Lightning</title>
<simpara><indexterm>
  <primary>Bitcoin node</primary>
</indexterm><indexterm>
  <primary>helpers (installation/configuration software)</primary><secondary>Bitcoin node versus lightweight Lightning node</secondary>
</indexterm>
<indexterm>
  <primary>Bitcoin node versus lightweight Lightning node</primary>
</indexterm>One critical choice for your setup will be the choice of the Bitcoin node and its configuration. <emphasis>Bitcoin Core</emphasis>, the reference implementation, is the most common choice but not the only choice available. One alternative choice is <emphasis>btcd</emphasis>, which is a Go-language implementation of a Bitcoin node. btcd supports some features that are useful for running an LND Lightning node and are not available in Bitcoin Core.</simpara>
<simpara>A second consideration is whether you will run an <emphasis>archival</emphasis> Bitcoin node with a full copy of the blockchain (some 350 GB in mid-2021) or a <emphasis>pruned</emphasis> blockchain that only keeps the most recent blocks. A pruned blockchain can save you some disk space, but you will still need to download the full blockchain at least once (during the IBD). Hence it won&#8217;t save you any network traffic. Using a pruned node to run a Lightning node is still an experimental capability and might not support all the functionality. However, many people are running a node like that successfully.</simpara>
<simpara><indexterm>
  <primary>lightweight Lightning node</primary>
</indexterm>Finally, you also have the option of not running a Bitcoin node at all. Instead you can operate the LND Lightning node in "lightweight" mode, using the Neutrino Protocol to retrieve blockchain information from public Bitcoin nodes operated by others. Running like this means that you are taking resources from the Bitcoin network without offering any in return. Instead, you are offering your resources and contributing to the LN community. For smaller Lightning nodes this will generally reduce network traffic in comparison to running a full Bitcoin node.</simpara>
<simpara>Keep in mind that operating a Bitcoin node allows you to support other services, besides and on top of a Lightning node. These other services may require an archival (not pruned) Bitcoin node and often can&#8217;t run without a Bitcoin node. Consider up front what other services you may want to run now or in the future to make an informed decision on the type of Bitcoin node you select.</simpara>
<simpara>The bottom line for this decision is: if you can afford a disk larger than 500 GB, run a full archival Bitcoin node. You will be contributing resources to the Bitcoin system and helping others who cannot afford to do so. If you can&#8217;t afford such a big disk, run a pruned node. If you can&#8217;t afford the disk or the bandwidth for even a pruned node, run a lightweight LND node over Neutrino.</simpara>
</section>
<section id="_operating_system_choice">
<title>Operating System Choice</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>operating system choice</secondary>
</indexterm>
<indexterm>
  <primary>operating system choice</primary>
</indexterm><indexterm>
  <primary>operating system</primary><secondary>for Lightning node</secondary>
</indexterm>
<indexterm>
  <primary>for Lightning node</primary>
</indexterm>The next step is to select an operating system for your node. The vast majority of internet servers run on some variant of Linux. Linux is the platform of choice for the internet because it is a powerful open source operating system. Linux, however, has a steep learning curve and requires familiarity with a command-line environment. It is often intimidating for new users.</simpara>
<simpara>Ultimately, most of the services can be run on any modern POSIX operating system, which includes macOS, Windows, and of course Linux. Your choice should be driven more by your familiarity and comfort with an operating system and your learning objectives. If you want to expand your knowledge and learn how to operate a Linux system, this is a great opportunity to do so with a specific project and a clear goal. If you just want to get a node up and running, go with what you know.</simpara>
<simpara>Nowadays, many services are also delivered in the form of containers, usually based on the Docker system. These containers can be deployed on a variety of operating systems, abstracting the underlying OS. You may need to learn some Linux CLI commands nonetheless, as most of the containers run some variant of Linux inside.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_choose_your_lightning_node_implementation">
<title>Choose Your Lightning Node Implementation</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>implementation choice</secondary>
</indexterm>
<indexterm>
  <primary>implementation choice</primary>
</indexterm>As with the choice of operating system, your choice of Lightning node implementation should depend primarily on your familiarity with the programming language and development tools used by the projects. While there are some small differences in features between the various node implementations, those are relatively minor, and most implementations converge on the common standards defined by the BOLTs.</simpara>
<simpara>Familiarity with the programming language and build system, on the other hand, is a good basis for choosing a node. That&#8217;s because installation, configuration, ongoing maintenance, and troubleshooting will all involve interacting with the various tools used by the build system. This includes:</simpara>
<itemizedlist>
<listitem>
<simpara>
Make, Autotools, and GNU utilities for <literal>c-lightning</literal>
</simpara>
</listitem>
<listitem>
<simpara>
Go utilities for LND
</simpara>
</listitem>
<listitem>
<simpara>
Java/Maven for Eclair
</simpara>
</listitem>
</itemizedlist>
<simpara>The programming language influences not only the choice of build system but also many other aspects of the program. Each programming language comes with a whole design philosophy and affects many other aspects, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>
Format and syntax of configuration files
</simpara>
</listitem>
<listitem>
<simpara>
File locations (in the filesystem)
</simpara>
</listitem>
<listitem>
<simpara>
Command-line arguments and their syntax
</simpara>
</listitem>
<listitem>
<simpara>
Error message formatting
</simpara>
</listitem>
<listitem>
<simpara>
Prerequisite libraries
</simpara>
</listitem>
<listitem>
<simpara>
Remote procedure call interfaces
</simpara>
</listitem>
</itemizedlist>
<simpara>When you choose your Lightning node, you are also choosing all the aforementioned characteristics. So your familiarity with these tools and design philosophies will make it easier to run a node. Or harder, if you land in an unfamiliar domain.</simpara>
<simpara>On the other hand, if this is your first foray into the command-line and server/service environment, you will find yourself unfamiliar with any implementation and have the opportunity to learn something completely new. In that case you might want to decide based on a number of other factors, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>
Quality of support forums and chat rooms
</simpara>
</listitem>
<listitem>
<simpara>
Quality of documentation
</simpara>
</listitem>
<listitem>
<simpara>
Degree of integration with other tools you want to run
</simpara>
</listitem>
</itemizedlist>
<simpara>As a final consideration, you may want to examine the performance and reliability of different node implementations. This is especially important if you will be using this node in a production environment and expect heavy traffic and high reliability requirements. This might be the case if you plan to run the payment system of a shop on it.</simpara>
</section>
<section id="_installing_a_bitcoin_or_lightning_node">
<title>Installing a Bitcoin or Lightning Node</title>
<simpara><indexterm>
  <primary>Bitcoin node</primary><secondary>installation/configuration</secondary>
</indexterm>
<indexterm>
  <primary>installation/configuration</primary>
</indexterm><indexterm>
  <primary>Lightning node operation</primary><secondary>installing Bitcoin node or Lightning node</secondary>
</indexterm>
<indexterm>
  <primary>installing Bitcoin node or Lightning node</primary>
</indexterm><indexterm>
  <primary>Linux, installing Bitcoin node or Lightning node</primary>
</indexterm>You decided not to use an installation "helper" and instead to dive into the command line of a Linux operating system? That is a brave decision, and we&#8217;ll try to help you make it work. If you&#8217;d rather not try to do this manually, consider using an application that helps you install the node software or a container-based solution, as described in <xref linkend="helpers"/>.</simpara>
<warning>
<simpara>This section will delve into the advanced topic of system administration from the command line. Linux administration is its own skill set that is outside the scope of this book. It is a complicated topic and there are many pitfalls. Proceed with caution!</simpara>
</warning>
<simpara>In the next few sections we will briefly describe how to install and configure a Bitcoin and Lightning node on a Linux operating system. You will need to review the installation instructions for the specific Bitcoin and Lightning node applications you decided to use. You can usually find these in a file called <emphasis>INSTALL</emphasis> or in the <emphasis>docs</emphasis> subdirectory of each project. We will only describe some of the common steps that apply to all such services, and the instructions we offer will be necessarily incomplete.</simpara>
<section id="_background_services">
<title>Background Services</title>
<simpara><indexterm>
  <primary>background services</primary>
</indexterm><indexterm>
  <primary>Lightning node operation</primary><secondary>background services</secondary>
</indexterm>
<indexterm>
  <primary>background services</primary>
</indexterm>For those accustomed to running applications on their desktop or smartphone, an application always has a graphical user interface even if it may sometimes run in the background. The Bitcoin and Lightning node applications, however, are very different. These applications do not have a graphical user interface built in. Instead, they run as <emphasis>headless</emphasis> background services, meaning they are always operating in the background and do not interact with the user directly.</simpara>
<simpara>This can create some confusion for users who are not used to running background services. How do you know if such a service is currently running? How do you start and stop it? How do you interact with it? The answers to these questions depend on the operating system you are using. For now we will assume you are using some Linux variant and answer them in that context.</simpara>
</section>
<section id="_process_isolation">
<title>Process Isolation</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>process isolation</secondary>
</indexterm>
<indexterm>
  <primary>process isolation</primary>
</indexterm>Background services usually run under a specific user account to isolate them from the operating system and each other. For example, Bitcoin Core is configured to run as user <literal>bitcoin</literal>. You will need to use the command line to create a user for each of the services you run.</simpara>
<simpara>In addition, if you have connected an external drive, you will need to tell the operating system to relocate the user&#8217;s home directory to that drive. That&#8217;s because a service like Bitcoin Core will create files under the user&#8217;s home directory. If you are setting it up to download the full Bitcoin blockchain, these files will take up several hundred gigabytes. Here, we assume you have connected the external drive and it is located on the <emphasis>/external_drive/</emphasis> path of the operating system.</simpara>
<simpara>On most Linux systems you can create a new user with the <literal>useradd</literal> command, like this:</simpara>
<screen>$ sudo useradd -m -d /external_drive/bitcoin -s /dev/null bitcoin</screen>
<simpara>The <literal>m</literal> and <literal>d</literal> flags create the user&#8217;s home directory as specified by <emphasis>/external_drive/bitcoin</emphasis> in this case. The <literal>s</literal> flag assigns the user&#8217;s interactive shell. In this case, we set it to <emphasis>/dev/null</emphasis> to disable interactive shell use. The last argument is the new user&#8217;s username <literal>bitcoin</literal>.</simpara>
</section>
<section id="_node_startup">
<title>Node Startup</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>node startup</secondary>
</indexterm>
<indexterm>
  <primary>node startup</primary>
</indexterm><indexterm>
  <primary>startup script</primary>
</indexterm>For both Bitcoin and Lightning node services, "installation" also involves creating a so-called <emphasis>startup script</emphasis> to make sure that the node starts when the computer boots. Startup and shutdown of background services is handled by an operating system process, which in Linux is called <literal>init</literal> or <literal>systemd</literal>. You can usually find a system startup script in the <literal>contrib</literal> subdirectory of each project. For example, if you are on a modern Linux OS that uses <literal>systemd</literal>, you would find a script called <emphasis>bitcoind.service</emphasis> that can start and stop the Bitcoin Core node service.</simpara>
<simpara>Here&#8217;s an example of what a Bitcoin node&#8217;s startup script looks like, taken from the Bitcoin Core code repository:</simpara>
<formalpara><title>From bitcoin/contrib/init/bitcoind.service</title><para>
<screen>[Unit]
Description=Bitcoin daemon
After=network.target

[Service]
ExecStart=/usr/bin/bitcoind -daemon \
                            -pid=/run/bitcoind/bitcoind.pid \
                            -conf=/etc/bitcoin/bitcoin.conf \
                            -datadir=/var/lib/bitcoind

# Make sure the config directory is readable by the service user
PermissionsStartOnly=true
ExecStartPre=/bin/chgrp bitcoin /etc/bitcoin

# Process management
####################

Type=forking
PIDFile=/run/bitcoind/bitcoind.pid
Restart=on-failure
TimeoutStopSec=600

# Directory creation and permissions
####################################

# Run as bitcoin:bitcoin
User=bitcoin
Group=bitcoin

# /run/bitcoind
RuntimeDirectory=bitcoind
RuntimeDirectoryMode=0710

# /etc/bitcoin
ConfigurationDirectory=bitcoin
ConfigurationDirectoryMode=0710

# /var/lib/bitcoind
StateDirectory=bitcoind
StateDirectoryMode=0710

[...]

[Install]
WantedBy=multi-user.target</screen>
</para></formalpara>
<simpara>As the root user, install the script by copying it into the <literal>systemd</literal> service folder <emphasis>/lib/systemd/system/</emphasis> and then reload <literal>systemd</literal>:</simpara>
<screen>$ sudo systemctl daemon-reload</screen>
<simpara role="pagebreak-before">Next, enable the service:</simpara>
<screen>$ sudo systemctl enable bitcoind</screen>
<simpara>You can now start and stop the service. Don&#8217;t start it yet, as we haven&#8217;t configured the Bitcoin node.</simpara>
<screen>$ sudo systemctl start bitcoind
$ sudo systemctl stop bitcoind</screen>
</section>
<section id="_node_configuration">
<title>Node Configuration</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>node configuration</secondary>
</indexterm>
<indexterm>
  <primary>node configuration</primary>
</indexterm>To configure your node, you need to create and reference a configuration file. By convention, this file is usually created in <emphasis>/etc</emphasis>, under a directory with the name of the program. For example, Bitcoin Core and LND configurations would usually be stored in <emphasis>/etc/bitcoin/bitcoin.conf</emphasis> and
<emphasis>/etc/lnd/lnd.conf</emphasis>, respectively.</simpara>
<simpara>These configuration files are text files with each line expressing one configuration option and its value. Default values are assumed for anything not defined in the configuration file. You can see what options can be set in the configuration in two ways. First, running the node application with a <literal>help</literal> argument will show the options that can be defined on the command line. These same options can be defined in the configuration file. Second, you can usually find an example configuration file, with all the default options, in the code repository of the software.</simpara>
<simpara>You can find one example of a configuration file in each of the Docker images we used in <xref linkend="set_up_a_lightning_node"/>. For example, the file <emphasis>code/docker/bitcoind/bitcoind/bitcoin.conf</emphasis>:</simpara>
<formalpara><title>Configuration file for docker bitcoind (code/docker/bitcoind/bitcoind/bitcoin.conf)</title><para>
<screen>regtest=1
server=1
debuglogfile=debug.log
debug=1
txindex=1
printtoconsole=0

[regtest]
fallbackfee=0.000001
port=18444
noconnect=1
dnsseed=0
dns=0
upnp=0
onlynet=ipv4
rpcport=18443
rpcbind=0.0.0.0
rpcallowip=0.0.0.0/0
rpcuser=regtest
rpcpassword=regtest
zmqpubrawblock=tcp://0.0.0.0:12005
zmqpubrawtx=tcp://0.0.0.0:12006</screen>
</para></formalpara>
<simpara>That particular configuration file configures Bitcoin Core for operation as a <literal>regtest</literal> node and provides a weak username and password for remote access, so you shouldn&#8217;t use it for your node configuration. However, it serves to illustrate the syntax of a configuration file and you can make adjustments to it in the Docker container to experiment with different options. See if you can use the <literal>bitcoind -help</literal> command to understand what each of the options does in the context of the Docker network we built in <xref linkend="set_up_a_lightning_node"/>.</simpara>
<simpara>Often, the defaults suffice, and with a few modifications your node software can be configured quickly. To get a Bitcoin Core node running with minimal customization, you only need four lines of configuration:</simpara>
<programlisting language="subs="quotes"" linenumbering="unnumbered">server=1
daemon=1
txindex=1
rpcuser=_USERNAME_
rpcpassword=_PASSWORD_</programlisting>
<simpara>Even the <literal>txindex</literal> option is not strictly necessary, though it will ensure your Bitcoin node creates an index of all transactions, which is required for some applications. The <literal>txindex</literal> option is not required to run a Lightning node.</simpara>
<simpara>A <literal>c-lightning</literal> Lightning node running on the same server also requires only a few lines in the configuration:</simpara>
<programlisting language="subs="quotes"" linenumbering="unnumbered">network=mainnet
bitcoin-rpcuser=_USERNAME_
bitcoin-rpcpassword=_PASSWORD_</programlisting>
<simpara>In general, it is a good idea to minimize the amount of customization of these systems. The default configuration is carefully designed to support the most common deployments. If you modify a default value, it may cause problems later on or reduce the performance of your node. In short, modify only when necessary!</simpara>
</section>
<section id="_network_configuration">
<title>Network Configuration</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>network configuration</secondary>
</indexterm>
<indexterm>
  <primary>network configuration</primary>
</indexterm><indexterm>
  <primary>network configuration</primary><secondary>Lightning node</secondary>
</indexterm>
<indexterm>
  <primary>Lightning node</primary>
</indexterm>Network configuration is normally not an issue when configuring a new application. However, peer-to-peer networks like Bitcoin and the Lightning Network present some unique challenges for network configuration.</simpara>
<simpara>In a centralized service, your computer connects to the "big servers" of some corporation, and not vice versa. Your home internet connection is actually configured on the assumption that you are simply a consumer of services provided by others. But in a peer-to-peer system, every peer both consumes from and provides services to other nodes. If you&#8217;re running a Bitcoin or Lightning node at your home, you&#8217;re providing a service to other computers on the internet. Your internet service by default is not configured to allow you to run servers and may need some additional configuration to enable others to reach your node.</simpara>
<simpara>If you want to run a Bitcoin or Lightning node, you need to make it possible for other nodes on the internet to connect to you. That means enabling incoming TCP connections to the Bitcoin port (port 8333 by default) or Lightning port (port 9735 by default). While you can run a Bitcoin node without incoming connectivity, you can&#8217;t do that with a Lightning node. A Lightning node must be accessible to others from outside your network.</simpara>
<simpara>By default, your home internet router does not expect incoming connections from the outside, and in fact incoming connections are blocked. Your internet router IP address is the only externally accessible IP address, and all the computers you run inside your home network share that single IP address. This is achieved by a mechanism called <emphasis>Network Address Translation</emphasis> (<emphasis>NAT</emphasis>), which allows your internet router to act as an intermediary for all outbound connections. <indexterm>
  <primary>port forwarding</primary><secondary>defined</secondary>
</indexterm>
<indexterm>
  <primary>defined</primary>
</indexterm>If you want to allow an inbound connection, you have to set up <emphasis>port forwarding</emphasis>, which tells your internet router that incoming connections on specific ports should be forwarded to specific computers inside the network. You can do this manually by changing your internet router configuration or,  if your router supports it, through an automatic port forwarding mechanism called <emphasis>Universal Plug and Play</emphasis> (<emphasis>UPnP</emphasis>).</simpara>
<simpara>An alternative mechanism to port forwarding is to enable The Onion Router (Tor), which provides a kind of virtual private network overlay that allows incoming connections to an <emphasis>onion address</emphasis>. If you run Tor, you don&#8217;t need to do port forwarding or enable incoming connections to Bitcoin or Lightning ports. If you run your nodes using Tor, all traffic goes through Tor and no other ports are used.</simpara>
<simpara>Let&#8217;s look at different ways you can make it possible for others to connect to your node. We&#8217;ll look at these alternatives in order, from easiest to most difficult.</simpara>
<section id="_it_just_works">
<title>It just works!</title>
<simpara>There is a possibility that your internet service provider or router is configured to support UPnP by default and everything just works automatically. Let&#8217;s try this approach first, just in case we are lucky.</simpara>
<simpara>Assuming you already have a Bitcoin or Lightning node running, we will try and see if they are accessible from the outside.</simpara>
<note>
<simpara>For this test to work, you have to have either a Bitcoin or Lightning node (or both) up and running on your home network. If your router supports UPnP, the incoming traffic will automatically be forwarded to the corresponding ports on the computer running the node.</simpara>
</note>
<simpara>You can use some very popular and useful websites to find out what is your external IP address and whether it allows and forwards incoming connections to a known port. Here are two that are reliable:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://canyouseeme.org">https://canyouseeme.org</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://www.whatismyip.com/port-scanner">https://www.whatismyip.com/port-scanner</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>By default, these services only allow you to check incoming connections to the IP address from which you are connecting. This is done to prevent you from using the service to scan other people&#8217;s networks and computers. You will see your router&#8217;s external IP address and a field for entering a port number. If you haven&#8217;t changed the default ports in your node configuration, try port 8333 (Bitcoin) and/or 9735 (Lightning).</simpara>
<simpara>In <xref linkend="ln_port_check"/> you can see the result of checking port 9735 on a server running Lightning, using the <emphasis>whatismyip.com</emphasis> port scanner tool. It shows that the server is accepting incoming connections to the Lightning port. If you see a result like this, you are all set!</simpara>
<figure id="ln_port_check"><title>Checking for incoming port 9735</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0503.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_0503.png</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_automatic_port_forwarding_using_upnp">
<title>Automatic port forwarding using UPnP</title>
<simpara><indexterm>
  <primary>network configuration</primary><secondary>automatic port forwarding using UPnP</secondary>
</indexterm>
<indexterm>
  <primary>automatic port forwarding using UPnP</primary>
</indexterm><indexterm>
  <primary>port forwarding</primary><secondary>automatic</secondary>
</indexterm>
<indexterm>
  <primary>automatic</primary>
</indexterm><indexterm>
  <primary>Universal Plug and Play (UPnP)</primary>
</indexterm>Sometimes, even if your internet router supports UPnP, it may be turned off by default. In that case you need to change your internet router configuration from its web administration interface:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Connect to your internet router&#8217;s configuration website. Usually this can be done by connecting to the <emphasis>gateway address</emphasis> of your home network using a web browser. You can find the gateway address by looking at the IP configuration of any computer on your home network. It is often the first address in one of the nonroutable networks, like 192.168.0.1 or 10.0.0.1. Check all stickers on your router as well for the <emphasis>gateway address</emphasis>. Once found, open a browser and enter the IP address into the browser URL/Search box, e.g., "192.168.0.1" or "http://192.168.0.1."
</simpara>
</listitem>
<listitem>
<simpara>
Find the administrator username and password for the web configuration panel of the router. This is often written on a sticker on the router itself and may be as simple as "admin" and "password." A quick web search for your ISP and router model can also help you find this information.
</simpara>
</listitem>
<listitem>
<simpara>
Find a setting for UPnP and turn it on.
</simpara>
</listitem>
</orderedlist>
<simpara>Restart your Bitcoin and/or Lightning node and repeat the open port test with one of the websites we used in the previous section.</simpara>
</section>
<section id="_using_tor_for_incoming_connections">
<title>Using Tor for incoming connections</title>
<simpara><indexterm>
  <primary>network configuration</primary><secondary>Tor for incoming connections</secondary>
</indexterm>
<indexterm>
  <primary>Tor for incoming connections</primary>
</indexterm><indexterm>
  <primary>The Onion Router (Tor)</primary>
</indexterm><indexterm>
  <primary>Tor (The Onion Router)</primary>
</indexterm><emphasis>The Onion Router</emphasis> (<emphasis>Tor</emphasis>) is a VPN with the special property that it encrypts communications between hops, such that any intermediary node cannot determine the origin or destination of a packet. Both Bitcoin and Lightning nodes support operation over Tor, which enables you to operate a node without revealing your IP address or location. Hence, it provides a high level of privacy to your network traffic. An added benefit of running Tor is that, because it operates as a VPN, it resolves the problem of port forwarding from your internet router. Incoming connections are received over the Tor tunnel, and your node can be found through an ad hoc generated <emphasis>onion address</emphasis> instead of an IP address.</simpara>
<simpara>Enabling Tor requires two steps. First, you must install the Tor router and proxy on your computer. Second, you must enable the use of the Tor proxy in your Bitcoin or Lightning configuration.</simpara>
<simpara>To install Tor on an Ubuntu Linux system that uses the <literal>apt</literal> package manager, run:</simpara>
<screen>sudo apt install tor</screen>
<simpara>Next, we configure our Lightning node to use Tor for its external connectivity. Here is an example configuration for LND:</simpara>
<screen>[Tor]
tor.active=true
tor.v3=true
tor.streamisolation=true
listen=localhost</screen>
<simpara>This will enable Tor (<literal>tor.active</literal>), establish a v3 onion service (<literal>tor.v3=true</literal>), use a different onion stream for each connection (<literal>tor.streamisolation</literal>), and restrict listening for connections to the local host only, to avoid leaking your IP address (<code>l&#x2060;i&#x2060;s&#x2060;t&#x2060;e&#x2060;n&#x200b;=&#x2060;l&#x2060;o&#x2060;c&#x2060;a&#x2060;l&#x2060;h&#x2060;o&#x2060;s&#x2060;t</code>).</simpara>
<simpara>You can check if Tor is correctly installed and working by running a simple one-line command. This command should work on most flavors of Linux:</simpara>
<screen>curl --socks5 localhost:9050 --socks5-hostname localhost:9050 -s https://check.torproject.org/ | cat | grep -m 1 Congratulations | xargs</screen>
<simpara>If everything is working properly, the response of this command should be <literal>"Congratulations. This browser is configured to use Tor."</literal></simpara>
<simpara>Due to the nature of Tor, you can&#8217;t easily use an external service to check if your node is reachable via an onion address. Nonetheless, you should see your Tor onion address in the logs of your Lightning node. It is a long string of letters and numbers followed by the suffix <literal>.onion</literal>. Your node should now be reachable from the internet, with the added bonus of privacy!</simpara>
</section>
<section id="_manual_port_forwarding">
<title>Manual port forwarding</title>
<simpara><indexterm>
  <primary>network configuration</primary><secondary>manual port forwarding</secondary>
</indexterm>
<indexterm>
  <primary>manual port forwarding</primary>
</indexterm><indexterm>
  <primary>port forwarding</primary><secondary>manual</secondary>
</indexterm>
<indexterm>
  <primary>manual</primary>
</indexterm>This is the most complex process and requires quite a bit of technical skill. The details depend on the type of internet router you have, your service provider settings and policies, and a lot of other context. Try UPnP or Tor first, before you try this much more difficult mechanism.</simpara>
<simpara>The basic steps are as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Find the IP address of the computer your node is on. This is usually dynamically allocated by the Dynamic Host Configuration Protocol (DHCP) and is often somewhere in the 192.168.x.x or 10.x.x.x range.
</simpara>
</listitem>
<listitem>
<simpara>
Find the media access control (MAC) address of your node&#8217;s network interface. This can be found in the internet settings of that computer.
</simpara>
</listitem>
<listitem>
<simpara>
Assign a static IP address for your node so that it is always the same one. You can use the IP address it currently has. On your internet router, look for "Static Leases" under the DHCP configuration. Map the MAC address to the IP address you selected. Now your node will always have that IP address allocated to it. Alternatively, you can look at your router&#8217;s DHCP configuration and find out what its DHCP address range is. Select an unused address <emphasis>outside</emphasis> of the DHCP address range. Then, on the server, configure the network to stop using DHCP and hardcode the selected non-DHCP IP address into the operating system network configuration.
</simpara>
</listitem>
<listitem>
<simpara>
Finally, set up "Port Forwarding" on your internet router to route incoming traffic on specific ports to the selected IP address of your server.
</simpara>
</listitem>
</orderedlist>
<simpara>Once done reconfiguring, repeat the port check using one of the websites from the previous sections<indexterm>
</indexterm><indexterm>
</indexterm>.<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
</section>
<section id="_security_of_your_node">
<title>Security of Your Node</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>security</secondary>
</indexterm>
<indexterm>
  <primary>security</primary>
</indexterm><indexterm>
  <primary>security and privacy</primary><secondary>Lightning node</secondary>
</indexterm>
<indexterm>
  <primary>Lightning node</primary>
</indexterm>A Lightning node is, by definition, a <emphasis>hot wallet</emphasis>. That means that the funds (both on-chain and off-chain) controlled by a Lightning node are directly controlled by keys that are loaded in the node&#8217;s memory or stored on the node&#8217;s hard disk. If a Lightning node is compromised, it is trivial to create on-chain or off-chain transactions to drain its funds. It is therefore critically important that you protect it from unauthorized access.</simpara>
<simpara>Security is a holistic effort, meaning that you have to secure every layer of a system. As the saying goes: the chain is only as strong as the weakest link. This is an important concept in information security, and we will apply it to our node.</simpara>
<simpara>Despite all the security measures you will take, remember that the Lightning Network is an early-stage experimental technology and there are likely to be exploitable bugs in the code of any project you use. <emphasis>Do not put more money than you are willing to risk losing on the Lightning Network.</emphasis></simpara>
<section id="_operating_system_security">
<title>Operating System Security</title>
<simpara><indexterm>
  <primary>operating system</primary><secondary>security</secondary>
</indexterm>
<indexterm>
  <primary>security</primary>
</indexterm><indexterm>
  <primary>security and privacy</primary><secondary>operating system security</secondary>
</indexterm>
<indexterm>
  <primary>operating system security</primary>
</indexterm>Securing an operating system is a vast topic that is beyond the scope of this book. However, we can establish some basic principles.</simpara>
<simpara>To secure your operating system, here are some of the top items to consider:</simpara>
<variablelist>
<varlistentry>
<term>
Provenance
</term>
<listitem>
<simpara>
Start by ensuring that you are downloading the correct operating system image, and verify any signatures or checksums before installing it. Extend this to any software that you install. Double-check any source or URL from where you download. Verify the integrity and correctness of the downloaded software via signature and checksum verification.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Maintenance
</term>
<listitem>
<simpara>
Make sure that you keep your operating system up to date. Enable automated daily or weekly installation of security updates.
Least privilege: set up users for specific processes and give them the least access needed to run a service. Do not run processes with admin privileges (e.g., <literal>root</literal>).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Process isolation
</term>
<listitem>
<simpara>
Use the operating system features to isolate processes from each other.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Filesystem permissions
</term>
<listitem>
<simpara>
Configure the filesystem carefully, on the least-privilege principle. Do not make files readable or writable by everyone.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Strong authentication
</term>
<listitem>
<simpara>
Use strong randomly generated passwords or, whenever possible, public-key authentication. For example, it is safer to use Secure Shell (SSH) with a cryptographic key pair instead of a password.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Two-factor authentication (2FA)
</term>
<listitem>
<simpara>
Use two-factor authentication wherever possible, including Universal 2nd Factor (U2F) with hardware security keys. This applies to all external services you might be using, such as your cloud service provider. You can apply this also to your own setup, such as your own SSH configuration. Use 2FA also for indirect services. For example, say you are using a cloud service. You gave your cloud service provider an email address, so you should also protect your email address with 2FA.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Backup
</term>
<listitem>
<simpara>
Make backups of your system, and make sure you protect the backups with encryption too. Perform these backups periodically. At least once, test if you can restore your backup and that your backup is complete and accessible. If possible, keep one copy of your backups on a different disk to avoid a single hard disk failure destroying <emphasis>both</emphasis> your active node as well as your backup copies.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Vulnerability and exposure management
</term>
<listitem>
<simpara>
Use remote scanning to ensure you have minimized the attack surface of your system. Close any unnecessary services or ports. Install only software and packages that you really need and use. Uninstall packages that you no longer use. It is recommended that you do <emphasis>not</emphasis> use your node computer for non-node activities that you can perform on another of your computers. Especially, if you can, do <emphasis>not</emphasis> use your node computer for browsing, surfing the internet, or reading your email.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>This is a list of the most basic security measures. It is by no means exhaustive.</simpara>
</section>
<section id="_node_access">
<title>Node Access</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>node access</secondary>
</indexterm>
<indexterm>
  <primary>node access</primary>
</indexterm><indexterm>
  <primary>remote procedure call (RPC) API</primary>
</indexterm><indexterm>
  <primary>RPC (remote procedure call) API</primary>
</indexterm>Your Lightning node will expose a remote procedure call (RPC) API. This means that your node can be controlled remotely by commands sent to a specific TCP port. Access control to that RPC API is achieved by some form of user authentication. Depending on the type of Lightning node you set up, this will either be done by <span class="keep-together">username/password</span> authentication or by a mechanism called an authentication <emphasis>macaroon</emphasis>. As the name implies, a macaroon is a more sophisticated type of cookie. Unlike a cookie, it is cryptographically signed and can express a set of access <span class="keep-together">capabilities</span>.</simpara>
<simpara>For example, LND uses macaroons to grant access to the RPC API. By default, the LND software creates three macaroons with different levels of access, called <literal>admin</literal>, <literal>invoice</literal>, and <literal>readonly</literal>. Depending on which macaroon you copy and use in your RPC client, you either have <emphasis>read-only</emphasis> access, <emphasis>invoice</emphasis> access (which includes the read-only capabilities), or <emphasis>admin</emphasis> access, which gives you full control. There is also a macaroon <literal>bakery</literal> function in LND that can construct macaroons with any combination of capabilities with very fine-grained control.</simpara>
<simpara>If you use a username/password authentication model, make sure you select a long and random password. You will not have to type this password often, because it will be stored in the configuration files. You should therefore pick one that cannot be guessed. Many of the examples you will see include poorly chosen passwords, and often people copy these into their own systems, providing easy access to anyone. Don&#8217;t do that! Use a password manager to generate a long random alphanumeric password. Since certain special characters such as <literal>$?/!*\&amp;%&#8216;"&#8217;</literal> can interfere with the command line, it is best to avoid these for passwords that will be used in a shell environment. To avoid problems, stick with long random alphanumeric passwords.</simpara>
<simpara>A plain alphanumeric sequence that is longer than 12 characters and randomly generated is usually sufficient. If you plan to store large amounts of money on your Lightning node and are concerned about remote brute-force attacks, select a password length of more than 20 characters to make such attacks practically infeasible.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_node_and_channel_backups">
<title>Node and Channel Backups</title>
<simpara><indexterm>
  <primary>backups</primary>
</indexterm><indexterm>
  <primary>Lightning Network channels</primary><secondary>backups</secondary>
</indexterm>
<indexterm>
  <primary>backups</primary>
</indexterm><indexterm>
  <primary>Lightning node operation</primary><secondary>node and channel backups</secondary>
</indexterm>
<indexterm>
  <primary>node and channel backups</primary>
</indexterm>A very important consideration when running a Lightning node is the issue of backups. Unlike a Bitcoin wallet, where a BIP-39 mnemonic phrase can recover all the state of the wallet, in Lightning this is <emphasis>not</emphasis> the case.</simpara>
<simpara>Lightning wallets do use a BIP-39 mnemonic phrase backup, but only for the on-chain wallet. However, due to the way channels are constructed, the mnemonic phrase is <emphasis>not</emphasis> sufficient to restore a Lightning node. <indexterm>
  <primary>SCB (static channel backup)</primary>
</indexterm><indexterm>
  <primary>static channel backup (SCB)</primary>
</indexterm>An additional layer of backups is needed, which is called the <emphasis>static channel backup</emphasis> (<emphasis>SCB</emphasis>). Without an SCB, a Lightning node operator may lose <emphasis>all</emphasis> the funds that are in channels if they lose the Lightning node data store.</simpara>
<warning>
<simpara>Do <emphasis>not</emphasis> fund channels until you have put a system in place to continuously back up your channel state. Your backups should be moved "offsite" to a different system and location from your node, so that they can survive a variety of system failures (power loss, data corruption, etc.) or natural disasters (flood, fire, etc.).</simpara>
</warning>
<simpara>SCBs are not a panacea. First, the state of each channel needs to be backed up every time there is a new commitment transaction. Second, restoring from a channel backup is dangerous. If you do not have the <emphasis>last</emphasis> commitment transaction and you accidentally broadcast an old (revoked) commitment, your channel peer will assume you are trying to cheat and claim the entire channel balance with a penalty transaction. To make sure you are closing the channel, you need to do a <emphasis>cooperative close</emphasis>. But a malicious peer could mislead your node into broadcasting an old, revoked commitment during that cooperative close, thereby cheating you by making your node inadvertently try to cheat.</simpara>
<simpara>Furthermore, the backups of your channels need to be encrypted to maintain your privacy and your channel security. Otherwise, anyone who finds the backups can not only see all your channels but also could use the backups to close all your channels in a way that hands over the balance to your channel peers. In other words, a malicious person that gets access to your backups can cause you to lose all your channel funds.</simpara>
<simpara>You can see that SCBs are not a foolproof safeguard. They are a weak compromise because they swap one type of risk (data corruption or loss) for another type of risk (malicious peer). To restore from an SCB, you have to interact with your channel peers and hope they don&#8217;t try to cheat you by either giving you an old commitment or by fooling your node into broadcasting a revoked commitment so they can penalize you. Despite the weaknesses of SCB, SCBs do make sense and you should perform them. If you do not perform SCBs and you lose your node data, you will lose your channel funds forever. Guaranteed! However, if you <emphasis>do</emphasis> perform SCBs and you lose your node data, then you have a reasonable chance that some of your peers are honest and that you can recover some of your channel funds. If you are lucky, you might recover all your funds. In conclusion, it is best for you to perform continuous SCBs to a disk other than the primary node hard disk.</simpara>
<simpara>Channel backup mechanisms are still a work in progress and a weakness in most Lightning implementations.</simpara>
<simpara><indexterm>
  <primary>Lightning Network Daemon (LND) node project</primary><secondary>SCBs and</secondary>
</indexterm>
<indexterm>
  <primary>SCBs and</primary>
</indexterm>At the time of writing this book, only LND offers a built-in mechanism for SCBs. Eclair has a similar mechanism deployed for server-side deployments, although Eclair Mobile does offer optional backup to a Google Drive. <literal>c-lightning</literal> recently merged the necessary interfaces for a plug-in to implement channel backups. Unfortunately, there is no consistent, agreed upon backup mechanism across different node <span class="keep-together">implementations</span>.</simpara>
<simpara>File-based backups of the Lightning node databases are at best a partial solution because you run the risk of backing up an inconsistent database state. In addition, you may not reliably catch the latest state commitments. It is much better to have a backup mechanism that is triggered every time there is a state change in a channel, thereby ensuring data consistency.</simpara>
<simpara>To set up SCBs in LND, set the <literal>backupfilepath</literal> parameter either on the command line or in the configuration file. LND will then save an SCB file in that directory path. Of course, that&#8217;s only the first step of the solution. Now, you have to set up a mechanism that monitors this file for changes. Each time the file changes, <span class="keep-together">the backup</span> mechanism must copy this file to another, preferably off-site disk. Such backup mechanisms are beyond the scope of this book. Nonetheless, any sophisticated backup solution should be able to handle this scenario. Recall, the backup files should be encrypted too.</simpara>
<section id="_hot_wallet_risk">
<title>Hot Wallet Risk</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>hot wallet risk</secondary>
</indexterm>
<indexterm>
  <primary>hot wallet risk</primary>
</indexterm>As <indexterm>
  <primary>hot wallets</primary><secondary>security issues</secondary>
</indexterm>
<indexterm>
  <primary>security issues</primary>
</indexterm><indexterm>
  <primary>security and privacy</primary><secondary>hot wallet risk</secondary>
</indexterm>
<indexterm>
  <primary>hot wallet risk</primary>
</indexterm>we&#8217;ve discussed previously, the Lightning Network consists of a network of <emphasis>hot wallets</emphasis>. The funds you store in a Lightning wallet are online all the time. This makes them vulnerable. Hence, you should not store large amounts in a Lightning wallet. Large amounts should be kept in a <emphasis>cold</emphasis> wallet that is <emphasis>not</emphasis> online and which can transact only on-chain.</simpara>
<simpara>Even if you start small, as time passes you may still find you have a significant amount of money in a Lightning wallet. This is a typical scenario for store owners. If you use a Lightning node for an ecommerce operation, your wallet will likely receive funds often, but send funds rarely. You will therefore end up having two problems simultaneously. First, your channels will be imbalanced, with large local balances outweighing small remote balances. Secondly, you will have too much money in the wallet. Fortunately, you can also solve both of these problems simultaneously.</simpara>
<simpara>Let&#8217;s look at some of the solutions you can use to reduce the funds exposed in a hot wallet.</simpara>
</section>
<section id="_sweeping_funds">
<title>Sweeping Funds</title>
<simpara><indexterm>
  <primary>hot wallets</primary><secondary>sweeping funds</secondary>
</indexterm>
<indexterm>
  <primary>sweeping funds</primary>
</indexterm><indexterm>
  <primary>sweeping funds</primary><secondary>hot wallets</secondary>
</indexterm>
<indexterm>
  <primary>hot wallets</primary>
</indexterm>If your Lightning wallet balance becomes too large for your risk tolerance, you will need to "sweep" funds out of the wallet. You can do so in three ways: on-chain, off-chain, and Loop Out. Let&#8217;s look at each of these options in the next few sections.</simpara>
<section id="_on_chain_sweep">
<title>On-chain sweep</title>
<simpara><indexterm>
  <primary>sweeping funds</primary><secondary>on-chain sweep</secondary>
</indexterm>
<indexterm>
  <primary>on-chain sweep</primary>
</indexterm>Sweeping funds on-chain is accomplished by moving the funds from the Lightning wallet to a Bitcoin wallet. You do that by closing channels. When you close a channel, all funds from your local balance are "swept" to a Bitcoin address. The Bitcoin address for on-chain funds is usually generated by your Lightning wallet, so it is still a hot wallet. You may need to do an additional on-chain transaction to move the funds to a more secure address, such as one generated on your hardware wallet.</simpara>
<simpara>Closing channels will incur an on-chain fee and will reduce your Lightning node&#8217;s capacity and connectivity. However, if you run a popular ecommerce node, you will not lack incoming capacity and can strategically close channels with large local balances, essentially "bundling" your funds for movement on-chain. You may need to use some channel rebalancing techniques (see <xref linkend="channel_rebalancing"/>) before you close channels to maximize the benefits of this strategy.</simpara>
</section>
<section id="_off_chain_sweep">
<title>Off-chain sweep</title>
<simpara><indexterm>
  <primary>sweeping funds</primary><secondary>off-chain sweep</secondary>
</indexterm>
<indexterm>
  <primary>off-chain sweep</primary>
</indexterm>Another technique you can use involves running a second Lightning node that is not advertised on the network. You can establish large capacity channels from your public node (e.g., the one running your shop) to your unadvertised (hidden) node. On a regular basis, "sweep" funds by making a Lightning payment to your hidden node.</simpara>
<simpara>The advantage of this technique lies in the fact that the Lightning node that receives payments for your shop will be publicly known. This makes it a target for hackers, as any Lightning node associated with a shop would be assumed to have a large balance. A second node that is not associated with your shop will not easily be identified as a valuable target.</simpara>
<simpara>As an additional measure of security, you can make your second node a hidden Tor service so that its IP address is not known. That further reduces the opportunity for attacks and increases your privacy.</simpara>
<simpara>You will need to set up a script that runs at regular intervals. The purpose of this script is to create an invoice on your hidden node and to pay that invoice from your shop&#8217;s node, thereby shifting funds over to your hidden node.</simpara>
<simpara>Keep in mind that this technique does not move funds into cold storage. Both Lightning nodes are hot wallets. The objective of this sweep is to move funds from a very well-known hot wallet to an obscure hot wallet.</simpara>
</section>
<section id="_submarine_swap_sweep">
<title>Submarine swap sweep</title>
<simpara><indexterm>
  <primary>submarine swaps</primary>
</indexterm><indexterm>
  <primary>sweeping funds</primary><secondary>submarine swap sweep</secondary>
</indexterm>
<indexterm>
  <primary>submarine swap sweep</primary>
</indexterm>Another way to reduce your Lightning hot-wallet balance is to use a technique called a <emphasis>submarine swap</emphasis>. Submarine swaps, conceptualized by coauthor Olaoluwa Osuntokun and Alex Bosworth, allow the exchange of on-chain bitcoin for Lightning payments and vice versa. Essentially, submarine swaps are atomic swaps between Lightning off-chain funds and Bitcoin on-chain funds.</simpara>
<simpara>A node operator can initiate a submarine swap and send all available channel balances to the other party, who will send them on-chain bitcoin in exchange.</simpara>
<simpara>In the future, this could be a paid service offered by nodes on the Lightning Network who advertise exchange rates or charge a flat fee for the conversion.</simpara>
<simpara>The advantage of a submarine swap for sweeping funds is that no channel needs to be closed. That means that we preserve our channels, only rebalancing our channels through this operation. As we send a Lightning payment out, we shift some balance from local to remote on one or more of our channels. Not only does that reduce the balance exposed in our node&#8217;s hot wallet, it also increases the balance available for future incoming payments.</simpara>
<simpara>You could do this by trusting an intermediary to act as a gateway, but this risks your coins being stolen. However, in the case of a submarine swap, the operation does not require trust. Submarine swaps are noncustodial <emphasis>atomic</emphasis> operations. That means that the counterparty in your submarine swap cannot steal your funds because the on-chain payment depends on the completion of the off-chain payment and vice versa.</simpara>
</section>
<section id="_submarine_swaps_with_loop">
<title>Submarine swaps with Loop</title>
<simpara><indexterm>
  <primary>Loop, submarine swaps with</primary>
</indexterm><indexterm>
  <primary>sweeping funds</primary><secondary>submarine swaps with Loop</secondary>
</indexterm>
<indexterm>
  <primary>submarine swaps with Loop</primary>
</indexterm>One example of a submarine swap service is <emphasis>Loop</emphasis> by Lightning Labs, the same company that builds LND. Loop comes in two variations: Loop In and Loop Out. <emphasis>Loop In</emphasis> accepts a Bitcoin on-chain payment and converts it into a Lightning off-chain payment. <emphasis>Loop Out</emphasis> converts a Lightning payment into a Bitcoin payment.</simpara>
<note>
<simpara>To use the Loop service, you must be running an LND Lightning node.</simpara>
</note>
<simpara>For the purpose of reducing the balance of your Lightning hot wallet, you would use the Loop Out service. To use the Loop service, you need to install some additional software on your node. The Loop software runs alongside your LND node and provides some command-line tools to execute submarine swaps. You can find the Loop software and installation instructions on <ulink url="https://github.com/lightninglabs/loop">GitHub</ulink>.</simpara>
<simpara>Once you have the software installed and running, a Loop Out operation is as simple as running a single command:</simpara>
<screen>loop out --amt 501000 --conf_target 400
Max swap fees for 501000 sat Loop Out: 25716 sat
Regular swap speed requested, it might take up to 30m0s for the swap to be executed.
CONTINUE SWAP? (y/n), expand fee detail (x): x

Estimated on-chain sweep fee:        149 sat
Max on-chain sweep fee:              14900 sat
Max off-chain swap routing fee:      10030 sat
Max no show penalty (prepay):        1337 sat
Max off-chain prepay routing fee:    36 sat
Max swap fee:                        750 sat
CONTINUE SWAP? (y/n): y
Swap initiated

Run `loop monitor` to monitor progress.</screen>
<simpara>Note that your maximum fee, which represents a worst-case scenario, will depend on the confirmation target that you select<indexterm>
</indexterm><indexterm>
</indexterm>.<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
</section>
<section id="_lightning_node_uptime_and_availability">
<title>Lightning Node Uptime and Availability</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>uptime and availability</secondary>
</indexterm>
<indexterm>
  <primary>uptime and availability</primary>
</indexterm>Unlike Bitcoin, Lightning nodes need to be online almost continuously. Your node needs to be online to receive payments, open channels, close channels (cooperatively), and monitor protocol violations. Node availability is such an important requirement in the Lightning Network that it is a metric used by various automatic channel management tools (e.g., <literal>autopilot</literal>) to decide which nodes to open channels with. You can also see "availability" as a node metric on popular node explorers (see <xref linkend="ln_explorer"/>) such as <ulink url="https://1ml.com">1ML</ulink>.</simpara>
<simpara>Node availability is especially important to mitigate and resolve potential protocol violations (i.e., revoked commitments). While you can afford short interruptions from an hour up to one or two days, you cannot have your node offline for longer periods of time without risking loss of funds.</simpara>
<simpara>Keeping a node online continuously is not easy, as various bugs and resource limitations can and will occasionally cause downtime. Especially if you run a busy and popular node, you will run into limitations of memory, swap space, number of open files, disk space, and so forth. A whole host of different problems will cause your node or your server to crash.</simpara>
<section id="_tolerate_faults_and_automate">
<title>Tolerate Faults and Automate</title>
<simpara><indexterm>
  <primary>automation, Lightning node</primary>
</indexterm><indexterm>
  <primary>fault tolerance, Lightning node</primary>
</indexterm><indexterm>
  <primary>Lightning node operation</primary><secondary>fault toleration and automation</secondary>
</indexterm>
<indexterm>
  <primary>fault toleration and automation</primary>
</indexterm>If you have the time and skills, you should test some basic fault scenarios on the Lightning testnet. On the testnet you will learn valuable lessons without risking any funds. Any step you perform to automate your system will improve your availability:</simpara>
<variablelist>
<varlistentry>
<term>
Automatic computer server restart
</term>
<listitem>
<simpara>
What happens when your server or the operating system crashes? What happens when there is a power outage? Simulate this fault by pressing the "reset" button on your PC or by unplugging the power cable. After a crash, reset, or power failure, the computer should automatically restart itself. Some computers have a setting in their BIOS to specify how the computer should react on power failures. Test it to make sure the computer really restarts automatically on power failure without human intervention.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Automatic node restart
</term>
<listitem>
<simpara>
What happens when your node or one of your nodes crashes? Simulate this fault by killing the corresponding node processes. If a node crashes, it should automatically restart itself. Test it to make sure the node or nodes really restart automatically on failure without human intervention. If this is not the case, most likely your node is not set up correctly as an operating system service.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Automatic network reconnection
</term>
<listitem>
<simpara>
What happens if your network goes down? What happens when your ISP goes down temporarily? What happens when your ISP assigns a new IP address to your router or your computer? When the network comes back, do the nodes you are running automatically reconnect to the network? Simulate this fault by unplugging and later replugging the Ethernet cable from the device hosting your nodes. The nodes should automatically reconnect and continue operation without human intervention.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Configure your logfiles
</term>
<listitem>
<simpara>
All of the preceding failures should leave textual entries behind in the corresponding logfiles. Turn up the verbosity of logging if needed. Find these error entries in the logfiles and use them for monitoring.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_monitoring_node_availability">
<title>Monitoring Node Availability</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>monitoring node availability</secondary>
</indexterm>
<indexterm>
  <primary>monitoring node availability</primary>
</indexterm><indexterm>
  <primary>monitoring</primary><secondary>node availability</secondary>
</indexterm>
<indexterm>
  <primary>node availability</primary>
</indexterm>Monitoring your node is an important part of keeping it running. You need to monitor not only the availability of the computer itself, but also the availability and correct operation of the Lightning node software.</simpara>
<simpara>There are a number of ways to do this, but most require some customization. You can use generic infrastructure monitoring or application monitoring tools, but you have to customize them specifically to query the Lightning node API to ensure the node is running, synchronized to the blockchain, and connected to channel peers.</simpara>
<simpara><ulink url="https://lightning.watch">Lightning.watch</ulink> provides a specialized service that offers Lightning node monitoring. It uses a Telegram bot to notify you of any interruptions in service. This is a free service, though you can pay (over Lightning, of course) to get faster alerts.</simpara>
<simpara>Over time, we expect more third-party services to provide specialized Lightning node monitoring payable via micropayments. Perhaps such services and their APIs will become standardized and will one day be directly supported by Lightning node software.</simpara>
</section>
<section id="watchtowers">
<title>Watchtowers</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>watchtowers</secondary>
</indexterm>
<indexterm>
  <primary>watchtowers</primary>
</indexterm><indexterm>
  <primary>monitoring</primary><secondary>watchtowers</secondary>
</indexterm>
<indexterm>
  <primary>watchtowers</primary>
</indexterm><indexterm>
  <primary>protocol violations, watchtowers and</primary>
</indexterm><indexterm>
  <primary>watchtowers</primary>
</indexterm><emphasis>Watchtowers</emphasis> are a mechanism for outsourcing the monitoring and penalty resolution of Lightning protocol violations.</simpara>
<simpara>As we mentioned in previous chapters, the Lightning protocol maintains security through a penalty mechanism. If one of your channel partners broadcasts an old commitment transaction, your node will need to exercise the revocation clause and broadcast a penalty transaction to avoid losing money. But if your node is down during the protocol violation, you might lose money.</simpara>
<simpara>To solve this problem, we can use one or more watchtowers to outsource the job of monitoring protocol violations and issuing penalty transactions. There are two parts to a watchtower setup: a watchtower server (or simply watchtower) that monitors the blockchain and a watchtower client that asks the watchtower server for this monitoring service.</simpara>
<simpara>Watchtower technology is still in the early stages of development and is not widely supported. However, in the following passage we list some experimental implementations that you can try.</simpara>
<simpara>LND software includes both a watchtower server and a watchtower client. You can activate the watchtower server by adding the following configuration options:</simpara>
<programlisting language="subs="quotes"" linenumbering="unnumbered">[watchtower]
watchtower.active=1
watchtower.towerdir=_/path_to_watchtower_data_directory_</programlisting>
<simpara>You can use LND&#8217;s watchtower client by activating it in the configuration and then using the command line to connect it to a watchtower server. The configuration is:</simpara>
<screen>[wtclient]
wtclient.active=1</screen>
<simpara>LND&#8217;s command-line client <literal>lncli</literal> shows the following options for managing the watchtower client:</simpara>
<screen>$ lncli wtclient

NAME:
   lncli wtclient - Interact with the watchtower client.

USAGE:
   lncli wtclient command [command options] [arguments...]

COMMANDS:
     add     Register a watchtower to use for future sessions/backups.
     remove  Remove a watchtower to prevent its use for future sessions/backups.
     towers  Display information about all registered watchtowers.
     tower   Display information about a specific registered watchtower.
     stats   Display the session stats of the watchtower client.
     policy  Display the active watchtower client policy configuration.

OPTIONS:
   --help, -h  show help</screen>
<simpara><literal>c-lightning</literal> has the API hooks necessary for a watchtower client plug-in, though no such plug-in has been implemented yet.</simpara>
<simpara>Finally, a popular standalone watchtower server is <emphasis>The Eye of Satoshi</emphasis> (TEOS). It can be found on <ulink url="https://github.com/talaia-labs/python-teos">GitHub</ulink>.<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_channel_management">
<title>Channel Management</title>
<simpara><indexterm>
  <primary>channel management</primary>
</indexterm><indexterm>
  <primary>Lightning node operation</primary><secondary>channel management</secondary>
</indexterm>
<indexterm>
  <primary>channel management</primary>
</indexterm>As a Lightning node operator, one of the recurring tasks you will need to perform is management of your channels. This means opening outbound channels from your node to other nodes, as well as getting other nodes to open inbound channels to your node. In the future, cooperative channel construction may be possible, so you can open symmetric channels that have funds committed on both ends on creation. For now, however, new channels only have funds on one end, on the originator&#8217;s side. Hence, to make your node <emphasis>balanced</emphasis> with both inbound and outbound capacity, you need to open channels to others and entice others to open channels to your node.</simpara>
<section id="_opening_outbound_channels">
<title>Opening Outbound Channels</title>
<simpara><indexterm>
  <primary>channel management</primary><secondary>opening outbound channels</secondary>
</indexterm>
<indexterm>
  <primary>opening outbound channels</primary>
</indexterm>As soon as you get your Lightning node up and running, you can fund its Bitcoin wallet and then start opening channels with those funds.</simpara>
<simpara>You must choose channel partners carefully because your node&#8217;s ability to send payments depends on who your channel partners are and how well connected they are to the rest of the Lightning Network. You also want to have more than one channel to avoid being susceptible to a single point of failure. Since Lightning now supports multipart payments, you can split your initial funds into several channels and route bigger payments by combining their capacity. At the same time, avoid making your channels too small. Since you need to pay Bitcoin transaction fees to open and close a channel, the channel balance should not be so small that the on-chain fees consume a significant portion. It&#8217;s all about balance!</simpara>
<simpara>To summarize:</simpara>
<itemizedlist>
<listitem>
<simpara>
Connect to a few well-connected nodes
</simpara>
</listitem>
<listitem>
<simpara>
Open more than one channel
</simpara>
</listitem>
<listitem>
<simpara>
Don&#8217;t open too many channels
</simpara>
</listitem>
<listitem>
<simpara>
Don&#8217;t make the channels too small
</simpara>
</listitem>
</itemizedlist>
<simpara>One way to find well-connected nodes is to open a channel to a popular merchant selling products on the Lightning Network. These nodes tend to be well funded and well connected. So, when you are ready to buy something online via Lightning, you can open a channel directly to the merchant&#8217;s node. The merchant&#8217;s node ID will be in the invoice you will receive when you try to buy something. That makes it easy.</simpara>
<simpara>Another way to find well-connected nodes is to use a Lightning Explorer (see <xref linkend="ln_explorer"/>) such as <ulink url="https://1ml.com">1ML</ulink> and browse the list of nodes sorted by channel capacity and number of channels. Don&#8217;t go for the biggest nodes, because that encourages centralization. Go for a node in the middle of the list so that you can help them grow. Another factor to consider might be the time span a node has been in operation. Nodes established for more than a year are likely to be more reputable and less risky than nodes that started operation a week ago.</simpara>
<section id="autopilot">
<title>Autopilot</title>
<simpara><indexterm>
  <primary>autopilot</primary>
</indexterm><indexterm>
  <primary>channel management</primary><secondary>autopilot for</secondary>
</indexterm>
<indexterm>
  <primary>autopilot for</primary>
</indexterm>The task of opening channels can be partially automated with the use of an <emphasis>autopilot</emphasis>, which is software that opens channels automatically based on some heuristic rules. Autopilot software is still relatively new, and it doesn&#8217;t always select the best channel partners for you. Especially in the beginning, it might be better to open channels manually.
Autopilots currently exist in three forms:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>lnd</literal> incorporates an autopilot that is fully integrated with <literal>lnd</literal> and runs constantly in the background while turned on.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>lib_autopilot.py</literal> can offer autopilot computations for any node implementation based on the gossip and channel data.
</simpara>
</listitem>
<listitem>
<simpara>
A <literal>c-lightning</literal> plug-in based on <literal>lib_autopilot.py</literal> exists that provides an easy-to-use interface for <literal>c-lightning</literal> users.
</simpara>
</listitem>
</itemizedlist>
<simpara><indexterm>
  <primary>lnd autopilot</primary>
</indexterm>Be aware that the <literal>lnd</literal> autopilot will start running in the background as soon as it is turned on via the config file. As a result it will start opening channels immediately if you have on-chain outputs in your <literal>lnd</literal> wallet.
If you want to have full control over the bitcoin transactions that you make and the channels that you open, make sure to turn the autopilot off <emphasis>before</emphasis> you load your <literal>lnd</literal> wallet with bitcoin funds.
If the autopilot was previously turned on, you might have to restart your <literal>lnd</literal> before you top up your wallet with an on-chain transaction or before you close channels, which effectively gives you on-chain funds again.
It is crucial that you set key configuration values if you want to run the autopilot.
Have a look at this example configuration:</simpara>
<screen>[lnd-autopilot]
autopilot.active=1
autopilot.maxchannels=40
autopilot.allocation=0.70
autopilot.minchansize=500000
autopilot.maxchansize=5000000
autopilot.heuristic=top_centrality:1.0</screen>
<simpara>This configuration file would activate the autopilot.
It would open channels as long as the following two conditions are met:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Your node currently has less than 40 channels open.
</simpara>
</listitem>
<listitem>
<simpara>
Less than 70% of your total funds are off-chain in payment channels.
</simpara>
</listitem>
</orderedlist>
<simpara>The numbers 40 and 0.7 are chosen completely arbitrarily here because we cannot make any recommendations that are valid for everyone about how many channels you should have open and what percentage of your funds should be off-chain.
The autopilot in <literal>lnd</literal> will not take into account on-chain fees. In other words, it will not delay opening channels to a time period when fees are low.
To reduce fees, you can manually open channels during a time period when fees are low, e.g., during the weekend.
The autopilot will make channel recommendations whenever the conditions are met and will immediately try to open a channel by using the appropriate current fees.
According to the preceding configuration file, the channels will be between 5 mBTC (<literal>minchansize</literal> = 500,000 satoshi) and 50 mBTC (<literal>maxchansize</literal> = 5,000,000 satoshi) in size.
As is common, the amounts in the configuration file are enumerated in satoshi.
Currently, channels below 1 mBTC are not very useful, and we do not recommend you open channels that are too small and below this amount.
With the wider adoption of multipart payments, smaller channels are less of a burden. But for the time being, this is our recommendation.</simpara>
<simpara><indexterm>
  <primary>c-lightning autopilot plugin</primary>
</indexterm>The <literal>c-lightning</literal> plug-in, which was originally written by René Pickhardt (a coauthor of this book), works very differently in comparison with the <literal>lnd</literal> autopilot.
First, it differs in the algorithms used to make the recommendations. We will not cover this here. Secondly, it differs in its user interface.
You will need to download the <emphasis>autopilot plug-in</emphasis> from the <literal>c-lightning</literal> plug-in <ulink url="https://github.com/lightningd/plugins/tree/master/autopilot">repository</ulink> and activate it.</simpara>
<note>
<simpara>To activate a plug-in in <literal>c-lightning</literal>, place it into the <emphasis>~/.lightning/plugins</emphasis> directory, ensure that it&#8217;s executable (e.g., <literal>chmod +x ~/.lightning/plugins/autopilot.py</literal>), then restart <literal>lightningd</literal>.</simpara>
<simpara>Alternatively, if you don&#8217;t want a plug-in to automatically activate when you start <literal>lightningd</literal>, you can place it in a different directory and manually activate it with the <literal>plugin</literal> argument to <literal>lightningd</literal>:</simpara>
<screen>   lightningd --plugin=~/lightning-plugins/autopilot.py</screen>
</note>
<simpara>The autopilot in <literal>c-lightning</literal> is controlled via three configuration values that can be set in the config file or as command-line arguments when you start <literal>lightningd</literal>:</simpara>
<screen>[c-lightning-autopilot]
autopilot-percent=75
autopilot-num-channels=10
autopilot-min-channel-size-msat=100000000msat</screen>
<simpara>These values are the actual default config, and you do not need to set them at all.</simpara>
<simpara>The autopilot will not automatically run in the background like in <literal>lnd</literal>.
Instead, you have to start a run specifically with <literal>lightning-cli autopilot-run-once</literal> if you want the autopilot to open the recommended channels.
But if you want it to just provide you with recommendations, from which you can handpick the nodes, you can append the optional <literal>dryrun</literal> argument.</simpara>
<simpara>A key difference between the <literal>lnd</literal> and the <literal>c-lightning</literal> autopilots is that the <literal>c-lightning</literal> autopilot will also make a recommendation for the channel size.
For example, if the autopilot recommends opening a channel with a small node that only has small channels, it will not recommend opening a large channel.
However, if it opens a channel with a well-connected node that also has many large channels, it will probably recommend a larger channel size.</simpara>
<simpara>As you can see, the <literal>c-lightning</literal> autopilot is not as automatic as <literal>lnd</literal>'s, but it gives you a little bit more control.
These differences reflect personal preferences and could actually be the deciding factor for you to choose one implementation over the other.</simpara>
<simpara>Keep in mind that current autopilots will primarily use public information from the gossip protocol about the current topology of the Lightning Network.
It is obvious that your personal requirements for channels can only be reflected to a certain degree.
More advanced autopilots would use historical and usage information that your node has gathered when running in the past, including information about routing successes, who you have paid in the past, and who paid you.
In the future, such improved autopilots might also use this collected data to make recommendations on closing channels and reallocating funds.<indexterm>
</indexterm></simpara>
<simpara>Overall, at the time of writing of this book, be cautious not to depend or rely too heavily on autopilots<indexterm>
</indexterm><indexterm>
</indexterm>.<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_getting_inbound_liquidity">
<title>Getting Inbound Liquidity</title>
<simpara><indexterm>
  <primary>channel management</primary><secondary>getting inbound liquidity</secondary>
</indexterm>
<indexterm>
  <primary>getting inbound liquidity</primary>
</indexterm>In the current design of the Lightning Network, it is more typical for users to obtain outbound liquidity <emphasis>before</emphasis> obtaining inbound liquidity.
They will do so by opening a channel with another node, and more often they&#8217;ll be able to spend bitcoin before they can receive it.
There are three typical ways of getting inbound liquidity:</simpara>
<itemizedlist>
<listitem>
<simpara>
Open a channel with outbound liquidity and then spend some of those funds. Now the balance is on the other end of the channel, which means that you can receive payments.
</simpara>
</listitem>
<listitem>
<simpara>
Ask someone to open a channel to your node. Offer to reciprocate, so that both of your nodes become better connected and balanced.
</simpara>
</listitem>
<listitem>
<simpara>
Use a submarine swap (e.g., Loop In) to exchange on-chain BTC for an inbound channel to your node.
</simpara>
</listitem>
<listitem>
<simpara>
Pay a third-party service to open a channel with you. Several such services exist. Some charge a fee to provide liquidity, some are free.
</simpara>
</listitem>
</itemizedlist>
<simpara role="pagebreak-before">Here is a list of currently available liquidity providers that will open a channel to your node for a fee:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://www.bitrefill.com/thor-lightning-network-channels">Bitrefill&#8217;s Thor service</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://lightningto.me">Lightning To Me</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://lnbig.com">LNBig</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://lightningconductor.net/channels">Lightning Conductor</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>Creating inbound liquidity is challenging from both practical and user experience perspectives. Inbound liquidity does not happen automatically, so you have to find ways to build it for your node. This asymmetry of payment channels is also not intuitive. In most other payment systems, you get paid first (inbound) before you pay others (outbound).</simpara>
<simpara>The challenge of creating inbound liquidity is most noticeable if you are a merchant or sell your services for Lightning payments. In that case, you need to be vigilant to ensure that you have enough inbound liquidity to be able to continue to receive payments. What if there is a surge of buyers on your store, but they can&#8217;t actually pay you because there is no more inbound capacity?</simpara>
<simpara>In the future, these challenges can be partially mitigated by the implementation of dual-funded channels, which are funded from both sides and offer balanced inbound and outbound capacity. The burden could also be mitigated by more sophisticated autopilot software, which could request and pay for inbound capacity as needed.</simpara>
<simpara>Ultimately, Lightning users need to be strategic and proactive about channel management to ensure that sufficient inbound capacity is available to meet their needs.</simpara>
</section>
<section id="_closing_channels">
<title>Closing Channels</title>
<simpara><indexterm>
  <primary>channel management</primary><secondary>closing channels</secondary>
</indexterm>
<indexterm>
  <primary>closing channels</primary>
</indexterm>As discussed earlier in the book, a <emphasis>mutual close</emphasis> is the preferred way of closing a channel. <indexterm>
  <primary>force close</primary>
</indexterm>However, there are instances where a <emphasis>force close</emphasis> is necessary.</simpara>
<simpara>Some examples:</simpara>
<itemizedlist>
<listitem>
<simpara>
Your channel partner is offline and cannot be contacted to initiate a mutual close.
</simpara>
</listitem>
<listitem>
<simpara>
Your channel partner is online, but is not responding to requests to initiate a mutual close.
</simpara>
</listitem>
<listitem>
<simpara>
Your channel partner is online and your nodes are negotiating a mutual close, but they become stuck and cannot reach a resolution.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="channel_rebalancing">
<title>Rebalancing Channels</title>
<simpara><indexterm>
  <primary>channel management</primary><secondary>rebalancing channels</secondary>
</indexterm>
<indexterm>
  <primary>rebalancing channels</primary>
</indexterm><indexterm>
  <primary>rebalancing channels</primary>
</indexterm>In the course of transacting and routing payments on Lightning, the combination of inbound and outbound capacities can become unbalanced.</simpara>
<simpara>For example, if one of your channel partners is frequently routing payments through your node, you will exhaust the inbound capacity on that channel, while also exhausting the outbound capacity on the outgoing channels. Once that happens, you can no longer route payments through that route.</simpara>
<simpara>There are many ways to rebalance channels, each with different advantages and disadvantages. One way is to use a submarine swap (e.g., Loop Out), as described previously in this chapter. Another way to rebalance is to simply wait for routed payments that flow in the opposite direction. If your node is well connected, when a specific route becomes exhausted in one direction, the same route becomes available in the opposite direction. Other nodes may "discover" that route in the opposite direction and start using it as part of their payment path, thereby rebalancing the funds again.</simpara>
<simpara><indexterm>
  <primary>circular route rebalancing</primary>
</indexterm>A third way to rebalance channels is to purposefully create a <emphasis>circular route</emphasis> that sends a payment from your node back to your node, via the Lightning Network. By sending a payment out on a channel with large local capacity and arranging the path so that it returns to your node on a channel with large remote capacity, both of those channels will become more balanced. An example of a circular route rebalancing strategy can be seen in <xref linkend="circular_rebalancing"/>.</simpara>
<figure id="circular_rebalancing"><title>Circular route rebalancing</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0504.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_0504.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>Circular rebalancing is supported by most Lightning node implementations and can be done on the command line or via one of the web management interfaces such as Ride The Lightning (see <xref linkend="rtl"/>).</simpara>
<simpara>Channel rebalancing is a complex issue that is the subject of active research and covered in more detail in <xref linkend="channel_rebalancing"/>.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_routing_fees">
<title>Routing Fees</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>routing fees</secondary>
</indexterm>
<indexterm>
  <primary>routing fees</primary>
</indexterm><indexterm>
  <primary>routing</primary><secondary>fees</secondary>
</indexterm>
<indexterm>
  <primary>fees</primary>
</indexterm>Running a Lightning node allows you to earn fees by routing payments across your channels. Routing fees are generally not a significant source of income and dwarfed by the cost of operating a node. For example, on a relatively busy node that routes a dozen payments a day, the fees amount to no more than 2,000 satoshis.</simpara>
<simpara>Nodes compete for routing fees by setting their desired fee rate on each channel. Routing fees are set by two parameters on each channel: a fixed <emphasis>base fee</emphasis> that is charged for any payment and an additional variable <emphasis>fee rate</emphasis> that is proportional to the payment amount.</simpara>
<simpara>When sending a Lightning payment, a node will select a path so as to minimize fees, minimize hops, or both. As a result, a routing fee market emerges from these interactions. There are currently many nodes that charge very low or no fees for routing, creating downward pressure on the routing fee market.</simpara>
<simpara>If you make no choices, your Lightning node will set a default base fee and fee rate for each new channel. The default values depend on the node implementation you use.
The base fee is set in the unit of <emphasis>millisatoshi</emphasis> (thousandths of a satoshi). The proportional fee rate is set in the unit of <emphasis>millionths</emphasis> and is applied to the payment amount.
The unit of millionths is often abbreviated with <emphasis>ppm</emphasis> (parts per million).
For example, a base fee of 1,000 (millisatoshi) and a fee rate of 1,000 ppm (millionths) would result in the following charges for a 100,000 satoshi payment:</simpara>
<informalequation>
<alt><![CDATA[\[\begin{equation}
\begin{aligned}
P &= 100,000 \text{ satoshi} \\
F_{base} &= 1,000 \text{ millisatoshi} = 1 \text{ satoshi} \\
F_{rate} &= 1,000 \text{ ppm} = 1,000/1,000,000 = 1/1,000 = \text{0.001} = 0.1\% \\
F_{total} &= F_{base} + ( P * F_{rate} ) \\
 \Rightarrow  F_{total} &= 1 \text{ satoshi} + ( 100,000/1,000 ) \text{ satoshi} \\
 \Rightarrow  F_{total} &= 1 \text{ satoshi} + 100 \text{ satoshi} = 101 \text{ satoshi} \\
\end{aligned}
\end{equation}\]]]></alt>
<mediaobject><textobject><phrase></phrase></textobject></mediaobject>
</informalequation>
<simpara>Broadly speaking, you can take one of two approaches to routing fees. You can route lots of payments with low fees, making up for low fees by high volume. Alternatively, you can choose to charge higher fees. If you choose to set higher fees, your node will be selected only when other cheaper routes don&#8217;t exist. Therefore, you will route less frequently but earn more per successful routing.</simpara>
<simpara>For most nodes, it is usually best to use the default routing fee values. This way, your node is competing on a mostly level playing field with other nodes that use the default values.</simpara>
<simpara>You can also use the routing fee settings to rebalance channels. If most of your channels have the default fees but you want to rebalance a particular channel, just decrease the fees on that specific channel to zero or to very low rates. Then sit back and wait for someone to route a payment over your "cheap" route and rebalance your channels for you as a side effect.</simpara>
</section>
<section id="_node_management">
<title>Node Management</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>node management</secondary>
</indexterm>
<indexterm>
  <primary>node management</primary>
</indexterm><indexterm>
  <primary>node management</primary>
</indexterm>Managing your Lightning node on the command line is obviously not easy. It gives you the full flexibility of the node&#8217;s API and the ability to write your own custom scripts to satisfy your personal requirements. But if you don&#8217;t want to deal with the complexity of the command line and only need some basic node management capabilities, you should consider installing a web-based user interface that makes node management easier.</simpara>
<simpara>There are a number of competing projects that offer web-based Lightning node management. Some of the most popular ones are described in the following section.</simpara>
<section id="rtl">
<title>Ride The Lightning</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>Ride The Lightning (RTL)</secondary>
</indexterm>
<indexterm>
  <primary>Ride The Lightning (RTL)</primary>
</indexterm><indexterm>
  <primary>node management</primary><secondary>Ride The Lightning (RTL)</secondary>
</indexterm>
<indexterm>
  <primary>Ride The Lightning (RTL)</primary>
</indexterm><indexterm>
  <primary>Ride The Lightning (RTL)</primary>
</indexterm><indexterm>
  <primary>RTL (Ride The Lightning)</primary>
</indexterm>Ride The Lightning (RTL) is a graphical web user interface to help users manage Lightning node operations for the three main Lightning node implementations (LND, <literal>c-lightning</literal>, and Eclair). RTL is an open source project developed by Shahana Farooqui and many other contributors. You can find the RTL software on <ulink url="https://github.com/Ride-The-Lightning/RTL">GitHub</ulink>.</simpara>
<simpara><xref linkend="rtl-web-interface"/> shows an example screenshot of RTL&#8217;s web interface, as provided on the project repository.</simpara>
<figure id="rtl-web-interface"><title>Example RTL web interface</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0505.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_0505.png</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_lndmon">
<title>lndmon</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>lndmon</secondary>
</indexterm>
<indexterm>
  <primary>lndmon</primary>
</indexterm><indexterm>
  <primary>lndmon</primary>
</indexterm><indexterm>
  <primary>node management</primary><secondary>lndmon</secondary>
</indexterm>
<indexterm>
  <primary>lndmon</primary>
</indexterm>Lightning Labs, the makers of LND, provide a web-based graphical user interface called <literal>lndmon</literal> to monitor the various metrics of an LND Lightning node. <literal>lndmon</literal> only works with LND nodes. It is a read-only interface for monitoring and as such does not allow you to actively manage the node. It cannot open channels or make payments. Find <literal>lndmon</literal> on <ulink url="https://github.com/lightninglabs/lndmon">GitHub</ulink>.</simpara>
</section>
<section id="_thunderhub">
<title>ThunderHub</title>
<simpara><indexterm>
  <primary>Lightning node operation</primary><secondary>ThunderHub</secondary>
</indexterm>
<indexterm>
  <primary>ThunderHub</primary>
</indexterm><indexterm>
  <primary>node management</primary><secondary>ThunderHub</secondary>
</indexterm>
<indexterm>
  <primary>ThunderHub</primary>
</indexterm><indexterm>
  <primary>ThunderHub</primary>
</indexterm><ulink url="https://thunderhub.io">ThunderHub</ulink> is a very aesthetically pleasing web-based graphical user interface similar to RTL but exclusive to LND. It can be used to make payments, rebalance channels, and manage the node through a variety of features.</simpara>
</section>
</section>
<section id="_conclusion_5">
<title>Conclusion</title>
<simpara>As you maintain your node and gain experiences, you will learn a lot about the Lightning Network. Being a node operator is a challenging but rewarding task. Mastering these skills will allow you to contribute to the growth and development of this technology and the Lightning Network itself. You will furthermore gain the ability to send and receive Lightning payments with the greatest degree of control and ease. You will play a central role in the network&#8217;s infrastructure and not just be a participant on the edges.<indexterm>
</indexterm></simpara>
</section>
</chapter>
<chapter id="_lightning_network_architecture">
<title>Lightning Network Architecture</title>
<simpara><indexterm>
  <primary>architecture, Lightning Network</primary>
</indexterm>In the first part of this book we introduced the main concepts of the Lightning Network and worked through a comprehensive example of routing a payment and setting up the tools we can use to explore further. In the second part of the book we will explore the Lightning Network in a lot more technical detail, dissecting each of the building blocks.</simpara>
<simpara>In this section we will outline the components of the Lightning Network in more detail and provide a "big picture" perspective to guide you through the following chapters.</simpara>
<section id="_the_lightning_network_protocol_suite">
<title>The Lightning Network Protocol Suite</title>
<simpara><indexterm>
  <primary>architecture, Lightning Network</primary><secondary>protocol suite</secondary>
</indexterm>
<indexterm>
  <primary>protocol suite</primary>
</indexterm><indexterm>
  <primary>protocol stack</primary>
</indexterm>The Lightning Network is composed of a complex collection of protocols that run on top of the internet. We can broadly classify these protocols into five distinct layers that make up a <emphasis>protocol stack</emphasis>, where each layer builds upon and uses the protocols in the layer below. Also, each protocol layer abstracts the underlying layers and "hides" some of the complexity.</simpara>
<simpara>The architecture diagram shown in <xref linkend="lightning_network_protocol_suite"/> provides an overview of these layers and their component protocols.</simpara>
<figure id="lightning_network_protocol_suite"><title>The Lightning Network protocol suite</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0601.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_0601.png</phrase></textobject>
</mediaobject>
</figure>
<simpara><indexterm>
  <primary>architecture, Lightning Network</primary><secondary>layers</secondary>
</indexterm>
<indexterm>
  <primary>layers</primary>
</indexterm>The five layers of the Lightning Network, from the bottom up, are:</simpara>
<variablelist>
<varlistentry>
<term>
Network connection layer
</term>
<listitem>
<simpara>
This contains the protocols that interact directly with the internet core protocols (TCP/IP), overlay protocols (Tor v2/v3), and internet services (DNS). This layer also contains the cryptographic transport protocols that protect Lightning <span class="keep-together">messages</span>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Messaging layer
</term>
<listitem>
<simpara>
This layer contains the protocols that nodes use to negotiate features, format messages, and encode message fields.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Peer-to-peer (P2P) layer
</term>
<listitem>
<simpara>
This layer is the primary protocol layer for communication between Lightning nodes and contains all the different messages exchanged between nodes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Routing layer
</term>
<listitem>
<simpara>
This layer contains the protocols used to route payments between nodes, end-to-end and atomically. This layer contains the core functionality of the Lightning Network: routed payments.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Payment layer
</term>
<listitem>
<simpara>
The highest layer of the network, which presents a reliable payment interface to applications.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_lightning_in_detail">
<title>Lightning in Detail</title>
<simpara><indexterm>
  <primary>architecture, Lightning Network</primary><secondary>outline of details</secondary>
</indexterm>
<indexterm>
  <primary>outline of details</primary>
</indexterm>Over the next 10 chapters, we will dissect the protocol suite and examine each component of the Lightning Network in detail.</simpara>
<simpara>We spent quite some time trying to decide the best order of presenting this detail. It&#8217;s not an easy choice because there is so much interdependence between different components: as you start explaining one, you find that it pulls in quite a few of the other componenents. Instead of a top-down or bottom-up approach, we ended up choosing a more meandering path that starts with the most fundamental building blocks that are unique to the Lightning Network-Payment Channels and moves outward from there. But since that path is not obvious, we will use the Lightning Protocol Suite shown in <xref linkend="lightning_network_protocol_suite"/> as a map. In each chapter will focus on one or more related components, and you will see them highlighted in the protocol suite. Kind of like a map marker saying "You are here!"</simpara>
<simpara>Here&#8217;s what we will cover:</simpara>
<variablelist>
<varlistentry>
<term>
<a data-type="xref" href="payment_channels" data-xrefstyle="chap-num-title">#payment_channels</a>
</term>
<listitem>
<simpara>
In this chapter we will look at how payment channels work, in significantly more depth than we saw in the earlier parts of the book. We will look at the structure and Bitcoin Script of the funding and commitment transactions, and the process used by nodes to negotiate each step in the protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<a data-type="xref" href="#routing" data-xrefstyle="chap-num-title">#routing</a>
</term>
<listitem>
<simpara>
Next, we will put together several payment channels in a network and route a payment from one end to the other. In that process we will dive into the hash time-locked contract (HTLC) smart contract and the Bitcoin Script that we use to construct it.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<a data-type="xref" href="#channel_operation" data-xrefstyle="chap-num-title">#channel_operation</a>
</term>
<listitem>
<simpara>
Putting together the concepts of a simple payment channel and a routed payment using HTLCs, we will now look at how HTLCs are part of each channel&#8217;s commitment transaction. We will also look at the protocol for adding, settling, failing, and removing HTLCs from the commitments.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<a data-type="xref" href="#onion_routing" data-xrefstyle="chap-num-title">#onion_routing</a>
</term>
<listitem>
<simpara>
Next, we will look at how the HTLC information is propagated across the network inside the onion routing protocol. We will look at the mechanism for layered encryption and decryption that gives the Lightning Network some of its privacy characteristics.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<a data-type="xref" href="#gossip" data-xrefstyle="chap-num-title">#gossip</a>
</term>
<listitem>
<simpara>
In this chapter we will look at how Lightning nodes find each other and learn about published channels to construct a channel graph that they can use to find paths across the network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<a data-type="xref" href="#path_finding" data-xrefstyle="chap-num-title">>#path_finding</a>
</term>
<listitem>
<simpara>
Next, we will see how the information from the gossip protocol is used by each node to build a "map" of the entire network, which it can use to find paths from one point to another to route payments. We&#8217;ll also look at the exiting innovations in pathfinding, such as multipart payments.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<a data-type="xref" href="#wire_protocol" data-xrefstyle="chap-num-title">#wire_protocol</a>
</term>
<listitem>
<simpara>
Underpinning the Lightning Network is the peer-to-peer protocol that nodes use to exchange messages about the network and about their channels. In this chapter we look at how those messages are constructed and the extension capabilities built into messages with feature bits and Type-Length-Value (TLV) encoding.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<a data-type="xref" href="#encrypted_message_transport" data-xrefstyle="chap-num-title">#encrypted_message_transport</a>
</term>
<listitem>
<simpara>
Moving down to the lower-level part of the network, we will look at the underlying encrypted transport system that ensures the secrecy and integrity of all communications between nodes.<indexterm>
</indexterm>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<a data-type="xref" href="#invoices" data-xrefstyle="chap-num-title">#invoices</a>
</term>
<listitem>
<simpara>
A key part of the Lightning Network is payment requests, also known as Lightning invoices. In this chapter we dissect the structure and encoding of an invoice.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Let&#8217;s dive in!</simpara>
</section>
</chapter>
<chapter id="payment_channels">
<title>Payment Channels</title>
<simpara><indexterm>
  <primary>payment channel</primary>
</indexterm>In this chapter we will dive into payment channels and see how they are constructed. We will start with Alice&#8217;s node opening a channel to Bob&#8217;s node, building on the examples presented in the beginning of this book.</simpara>
<simpara role="pagebreak-after">The messages exchanged by Alice and Bob&#8217;s nodes are defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md">"BOLT #2: Peer Protocol for Channel Management"</ulink>. The transactions created by Alice and Bob&#8217;s nodes are defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md">"BOLT #3: Bitcoin Transaction and Script Formats"</ulink>. In this chapter we are focusing on the "Channel open and close" and "Channel state machine" parts of the Lightning protocol architecture, highlighted by an outline in the center (peer-to-peer layer) of <xref linkend="LN_protocol_channel_highlight"/>.</simpara>
<figure id="LN_protocol_channel_highlight"><title>Payment channels in the Lightning protocol suite</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0701.png"/>
  </imageobject>
  <textobject><phrase>Payment channels in the Lightning protocol suite</phrase></textobject>
</mediaobject>
</figure>
<section id="_a_different_way_of_using_the_bitcoin_system">
<title>A Different Way of Using the Bitcoin System</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>Lightning Network as different way of using Bitcoin system</secondary>
</indexterm>
<indexterm>
  <primary>Lightning Network as different way of using Bitcoin system</primary>
</indexterm>The Lightning Network is often described as a "Layer 2 Bitcoin Protocol," which makes it sound distinct from Bitcoin. Another way to describe Lightning is as a "smarter way to use Bitcoin" or just as an "application on top of Bitcoin." Let&#8217;s explore that.</simpara>
<simpara>Historically, Bitcoin transactions are broadcast to everyone and recorded on the Bitcoin blockchain to be considered valid. As we will see, however, if someone holds a presigned Bitcoin transaction that spends a 2-of-2 multisig output that gives them the exclusive ability to spend that Bitcoin, they effectively own that Bitcoin even if they don&#8217;t broadcast the transaction.</simpara>
<simpara>You can think of the presigned Bitcoin transaction like a postdated check (or cheque), one that can be cashed at any time. Unlike the traditional banking system, however, this transaction is not a "promise" of payment (also known as an IOU), but a verifiable bearer instrument that is equivalent to cash. So long as the bitcoin referenced in the transaction has not already been spent at the time of redemption (or at the time you try to "cash" the check), the Bitcoin system guarantees that this presigned transaction can be broadcast and recorded at any time. This is only true, of course, if this is the only presigned transaction. Within the Lightning Network two or more such presigned transactions exist at the same time; therefore, we need a more sophisticated mechanism to still have the functionality of such a verifiable bearer instrument, as you will also learn in this chapter.</simpara>
<simpara>The Lightning Network is simply a different and creative way of using Bitcoin. In the Lightning Network a combination of recorded (on-chain) and presigned but withheld (off-chain) transactions form a "layer" of payments that is a faster, cheaper, and more private way to use Bitcoin. You can see this relationship between on-chain and off-chain Bitcoin transactions in <xref linkend="on_off_chain"/>.</simpara>
<figure id="on_off_chain"><title>Lightning payment channel made of on-chain and off-chain transactions</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0702.png"/>
  </imageobject>
  <textobject><phrase>Lightning payment channel made of on-chain and off-chain transactions</phrase></textobject>
</mediaobject>
</figure>
<simpara>Lightning is Bitcoin. It&#8217;s just a different way of using the Bitcoin system.</simpara>
</section>
<section id="_bitcoin_ownership_and_control">
<title>Bitcoin Ownership and Control</title>
<simpara><indexterm>
  <primary>bitcoin (currency)</primary><secondary>ownership and control in payment channels</secondary>
</indexterm>
<indexterm>
  <primary>ownership and control in payment channels</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>bitcoin ownership and control</secondary>
</indexterm>
<indexterm>
  <primary>bitcoin ownership and control</primary>
</indexterm>Before we understand payment channels, we have to take a small step back and understand how ownership and control work in Bitcoin.</simpara>
<simpara><indexterm>
  <primary>private keys</primary><secondary>Bitcoin ownership and</secondary>
</indexterm>
<indexterm>
  <primary>Bitcoin ownership and</primary>
</indexterm>When someone says they "own" bitcoin, they typically mean that they know the private key of a Bitcoin address that has some unspent transaction outputs (see <xref linkend="bitcoin_fundamentals_review"/>). The private key allows them to sign a transaction to spend that bitcoin by transferring it to a different address. In Bitcoin "ownership" of bitcoin can be defined as the <emphasis>ability to spend</emphasis> that bitcoin.</simpara>
<simpara>Keep in mind that the term "ownership" as used in Bitcoin is distinct from the term "ownership" used in a legal sense. A thief who has the private keys and can spend Bitcoin is a <emphasis>de facto owner</emphasis> of that Bitcoin even though they are not a lawful owner.</simpara>
<tip>
<simpara>Bitcoin ownership is only about control of keys and the ability to spend the Bitcoin with those keys. As the popular Bitcoin saying goes: "Your keys, your coins—not your keys, not your coins."</simpara>
</tip>
<section id="_diversity_of_independent_ownership_and_multisig">
<title>Diversity of (Independent) Ownership and Multisig</title>
<simpara><indexterm>
  <primary>bitcoin (currency)</primary><secondary>diversity of independent ownership and multisig</secondary>
</indexterm>
<indexterm>
  <primary>diversity of independent ownership and multisig</primary>
</indexterm>Ownership and control of private keys is not always in the hands of one person. That&#8217;s where things get interesting and complicated. We know that more than one person can come to know the same private key, either through theft or because the original holder of the key makes a copy and gives it to someone else. Are all these people owners? In a practical sense, they are, because any one of the people who know the private key can spend the bitcoin without the approval of any other.</simpara>
<simpara>Bitcoin also has multisignature addresses where multiple private keys are needed to sign before spending (see <xref linkend="multisig"/>). From a practical perspective, ownership in a multisignature address depends on the quorum (<emphasis>K</emphasis>) and total (<emphasis>N</emphasis>) defined in the <emphasis>K</emphasis>-of-<emphasis>N</emphasis> scheme. A 1-of-10 multisignature scheme would allow any 1 (<emphasis>K</emphasis>) of 10 (<emphasis>N</emphasis>) signers to spend a bitcoin amount locked in that address. This is similar to the scenario where 10 people have a copy of the same private key and any of them can independently spend it.</simpara>
</section>
<section id="_joint_ownership_without_independent_control">
<title>Joint Ownership Without Independent Control</title>
<simpara><indexterm>
  <primary>bitcoin (currency)</primary><secondary>joint ownership without independent control</secondary>
</indexterm>
<indexterm>
  <primary>joint ownership without independent control</primary>
</indexterm>There is also the scenario where <emphasis>no one</emphasis> has quorum. In a 2-of-2 scheme like that used in the Lightning Network, neither signer can spend the bitcoin without obtaining a signature from the other party. Who owns the bitcoin in that case? No one really has ownership because no one has control. They each own the equivalent of a voting share in the decision, but both votes are needed. A key problem (pun intended) with a 2-of-2 scheme, in both Bitcoin and the law, is what happens if one of the parties is unavailable, or if there is a vote deadlock and any one party refuses to cooperate.</simpara>
</section>
<section id="_preventing_locked_and_un_spendable_bitcoin">
<title>Preventing "Locked" and Un-Spendable Bitcoin</title>
<simpara><indexterm>
  <primary>bitcoin (currency)</primary><secondary>preventing locked and un-spendable bitcoin</secondary>
</indexterm>
<indexterm>
  <primary>preventing locked and un-spendable bitcoin</primary>
</indexterm>If one of the two signers of a 2-of-2 multisig cannot or will not sign, the funds become un-spendable. Not only can this scenario occur accidentally (loss of keys), but it can be used as a form of blackmail by either party: "I won&#8217;t sign unless you pay me a part of the funds."</simpara>
<simpara>Payment channels in Lightning are based on a 2-of-2 multisig address, with the two channel partners as signers in the multisig. At this time, channels are funded only by one of the two channel partners: when you choose to "open" a channel, you deposit funds into the 2-of-2 multisig address with a transaction. Once that transaction is mined and the funds are in the multisig, you can&#8217;t get them back without cooperation from your channel partner, because you need their signature (also) to spend the bitcoin.</simpara>
<simpara>In the next section, as we look at how to open (create) a Lightning channel, we will see how we can prevent loss of funds or any blackmail scenario between the two partners by implementing a fairness protocol for the channel construction with the help of presigned transactions that spend the multisig output in a way that gives the peers in the channel exclusive ability to spend one of the outputs which encodes the amount of bitcoin they own in the channel.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_constructing_a_payment_channel">
<title>Constructing a Payment Channel</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>elements</secondary>
</indexterm>
<indexterm>
  <primary>elements</primary>
</indexterm>In <xref linkend="what_is_payment_channel"/>, we described payment channels as a <emphasis>financial relationship</emphasis> between two Lightning nodes, which is established by funding a 2-of-2 multisignature address from the two channel partners.</simpara>
<simpara>Let&#8217;s assume that Alice wants to construct a payment channel allowing her to connect to Bob&#8217;s store directly. First, the two nodes (Alice&#8217;s and Bob&#8217;s) have to establish an internet connection to each other, so that they can negotiate a payment channel.</simpara>
<section id="_node_private_and_public_keys">
<title>Node Private and Public Keys</title>
<simpara><indexterm>
  <primary>node public key</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>node private/public keys</secondary>
</indexterm>
<indexterm>
  <primary>node private/public keys</primary>
</indexterm>Every node on the Lightning Network is identified by a <emphasis>node public key</emphasis>. The public key uniquely identifies the specific node and is usually presented as a hexadecimal encoding. For example, René Pickhardt currently runs a Lightning Node (<literal>ln.rene-pickhardt.de</literal>) that is identified by the following node public key:</simpara>
<screen>02a1cebfacb2674143b5ad0df3c22c609e935f7bc0ebe801f37b8e9023d45ea7b8</screen>
<simpara><indexterm>
  <primary>private keys</primary><secondary>generation of</secondary>
</indexterm>
<indexterm>
  <primary>generation of</primary>
</indexterm><indexterm>
  <primary>root private key generation</primary>
</indexterm>Each node generates a root private key when first initialized. The private key is kept private at all times (never shared) and securely stored in the node&#8217;s wallet. From that private key, the node derives a public key that is the node identifier and shared with the network. Since the key space is enormous, as long as each node generates the private key randomly, it will have a unique public key, which can therefore uniquely identify it on the network.</simpara>
</section>
<section id="_node_network_address">
<title>Node Network Address</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>node network address</secondary>
</indexterm>
<indexterm>
  <primary>node network address</primary>
</indexterm>Additionally, every node also advertises a network address where it can be reached, in one of several possible formats:</simpara>
<variablelist>
<varlistentry>
<term>
TCP/IP
</term>
<listitem>
<simpara>
An IPv4 or IPv6 address and TCP port number
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
TCP/Tor
</term>
<listitem>
<simpara>
A Tor "onion" address and TCP port number
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The network address identifier is written as <literal>Address:Port</literal>, which is consistent with international standards for network identifiers, as used, for example, on the web.</simpara>
<simpara>For example, René&#8217;s node with node public key <literal>02a1ceb&#8230;45ea7b8</literal> currently advertises its network address as the TCP/IP address:</simpara>
<screen>172.16.235.20:9735</screen>
<tip>
<simpara>The default TCP port for the Lightning Network is 9735, but a node can choose to listen on any TCP port.</simpara>
</tip>
</section>
<section id="_node_identifiers">
<title>Node Identifiers</title>
<simpara><indexterm>
  <primary>node identifiers</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>node identifiers</secondary>
</indexterm>
<indexterm>
  <primary>node identifiers</primary>
</indexterm>Together, the node public key and network address are written in the following format, separated by an <literal>@</literal> sign, as <emphasis><literal>NodeID@Address:Port</literal></emphasis>.</simpara>
<simpara>So the full identifier for René&#8217;s node would be:</simpara>
<screen>02a1cebfacb2674143b5ad0df3c22c609e935f7bc0ebe801f37b8e9023d45ea7b8
@172.16.235.20:9735</screen>
<tip>
<simpara>The alias of René&#8217;s node is <literal>ln.rene-pickhardt.de</literal>; however, this name exists just for better readability. Every node operator can announce whatever alias they want, and there is no mechanism that prevents node operators from selecting an alias that is already being used. Thus to refer to a node, one must use the <emphasis><literal>NodeID@Address:Port</literal></emphasis> schema.</simpara>
</tip>
<simpara>The preceding identifier is often encoded in a QR code, making it easier for users to scan if they want to connect their own node to the specific node identified by that address.</simpara>
<simpara>Much like Bitcoin nodes, Lightning nodes advertise their presence on the Lightning Network by "gossiping" their node public key and network address. That way, other nodes can find them and keep an inventory (database) of all the known nodes that they can connect to and exchange the messages that are defined in the Lightning P2P message protocol.</simpara>
</section>
<section id="_connecting_nodes_as_direct_peers">
<title>Connecting Nodes as Direct Peers</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>connecting nodes as direct peers</secondary>
</indexterm>
<indexterm>
  <primary>connecting nodes as direct peers</primary>
</indexterm>In order for Alice&#8217;s node to connect to Bob&#8217;s node, she will need Bob&#8217;s node public key, or the full address containing the public key, IP or Tor address, and port. Because Bob runs a store, Bob&#8217;s node address can be retrieved from an invoice or a store payment page on the web. Alice can scan a QR code that contains the address and instruct her node to connect to Bob&#8217;s node.</simpara>
<simpara>Once Alice has connected to Bob&#8217;s node, their nodes are now directly connected peers.</simpara>
<tip>
<simpara>To open a payment channel, two nodes must first be connected as direct peers by opening a connection over the internet (or Tor).<indexterm>
</indexterm></simpara>
</tip>
</section>
</section>
<section id="_constructing_the_channel">
<title>Constructing the Channel</title>
<simpara><indexterm>
  <primary>Lightning Peer Protocol for Channel Management</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>construction of</secondary>
</indexterm>
<indexterm>
  <primary>construction of</primary>
</indexterm>Now that Alice&#8217;s and Bob&#8217;s Lightning nodes are connected, they can begin the process of constructing a payment channel. In this section we will review the communications between their nodes, known as the <emphasis>Lightning Peer Protocol for Channel Management</emphasis>, and the cryptographic protocol that they use to build Bitcoin transactions.</simpara>
<tip>
<simpara>We describe two different protocols in this scenario. First, there is a <emphasis>message protocol</emphasis>, which establishes how the Lightning nodes communicate over the internet and what messages they exchange with each other. Second, there is the <emphasis>cryptographic protocol</emphasis>, which establishes how the two nodes construct and sign Bitcoin <span class="keep-together">transactions</span>.</simpara>
</tip>
<section id="peer_protocol_channel_management">
<title>Peer Protocol for Channel Management</title>
<simpara>The Lightning Peer Protocol for Channel Management is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md">BOLT #2: Peer Protocol for Channel Management</ulink>. In this chapter we will be reviewing the "Channel Establishment" and "Channel Closing" sections of BOLT #2 in more detail.</simpara>
</section>
<section id="_channel_establishment_message_flow">
<title>Channel Establishment Message Flow</title>
<simpara><indexterm>
  <primary>channel establishment message flow</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>channel establishment message flow</secondary>
</indexterm>
<indexterm>
  <primary>channel establishment message flow</primary>
</indexterm>Channel establishment is achieved by the exchange of six messages between Alice and Bob&#8217;s nodes (three from each peer): <literal>open_channel</literal>, <literal>accept_channel</literal>, <literal>funding_created</literal>, <literal>funding_signed</literal>, <literal>funding_locked</literal>, and <literal>funding_locked</literal>. The six messages are shown as a time-sequence diagram in <xref linkend="funding_message_flow"/>.</simpara>
<figure id="funding_message_flow"><title>The channel establishment message flow</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0703.png"/>
  </imageobject>
  <textobject><phrase>The channel establishment message flow</phrase></textobject>
</mediaobject>
</figure>
<simpara>In <xref linkend="funding_message_flow"/>, Alice and Bob&#8217;s nodes are represented by the vertical lines "A" and "B" on either side of the diagram. A time-sequence diagram like this shows time flowing downward, and messages flowing from one side to the other between the two communication peers. The lines are sloped down to represent the elapsed time needed to transmit each message, and the direction of the message is shown by an arrow at the end of each line.</simpara>
<simpara>The channel establishment involves three parts. First, the two peers communicate their capabilities and expectations, with Alice initiating a request through <literal>open_channel</literal> and Bob accepting the channel request through <literal>accept_channel</literal>.</simpara>
<simpara>Second, Alice constructs the funding and refund transactions (as we will see later in this section) and sends <literal>funding_created</literal> to Bob. Another name for the "refund" transaction is a "commitment" transaction, as it commits to the current distribution of balances in the channel. Bob responds by sending back the necessary signatures with <literal>funding_signed</literal>. This interaction is the basis for the <emphasis>cryptographic protocol</emphasis> to secure the channel and prevent theft. Alice will now broadcast the funding transaction (on-chain) to establish and anchor the payment channel. The transaction will need to be confirmed on the Bitcoin blockchain.</simpara>
<tip>
<simpara>The name of the <literal>funding_signed</literal> message can be a bit confusing. This message does not contain a signature for the funding transaction, but rather it contains Bob&#8217;s signature for the refund transaction that allows Alice to claim her bitcoin back from the multisig.</simpara>
</tip>
<simpara>Once the transaction has sufficient confirmations (as defined by the <literal>minimum_depth</literal> field in the <literal>accept_channel</literal> message), Alice and Bob exchange <literal>funding_locked</literal> messages, and the channel enters normal operating mode.</simpara>
<section id="_the_open_channel_message">
<title>The open_channel message</title>
<simpara><indexterm>
  <primary>channel establishment message flow</primary><secondary>open_channel message</secondary>
</indexterm>
<indexterm>
  <primary>open_channel message</primary>
</indexterm><indexterm>
  <primary>open_channel message</primary>
</indexterm>Alice&#8217;s node requests a payment channel with Bob&#8217;s node by sending an <literal>open_channel</literal> message. The message contains information about Alice&#8217;s <emphasis>expectations</emphasis> for the channel setup, which Bob may accept or decline.</simpara>
<simpara>The structure of the <literal>open_channel</literal> message (taken from BOLT #2) is shown in <xref linkend="open_channel_message"/>.</simpara>
<example id="open_channel_message">
<title>The <literal>open_channel</literal> message</title>
<screen>[chain_hash:chain_hash]
[32*byte:temporary_channel_id]
[u64:funding_satoshis]
[u64:push_msat]
[u64:dust_limit_satoshis]
[u64:max_htlc_value_in_flight_msat]
[u64:channel_reserve_satoshis]
[u64:htlc_minimum_msat]
[u32:feerate_per_kw]
[u16:to_self_delay]
[u16:max_accepted_htlcs]
[point:funding_pubkey]
[point:revocation_basepoint]
[point:payment_basepoint]
[point:delayed_payment_basepoint]
[point:htlc_basepoint]
[point:first_per_commitment_point]
[byte:channel_flags]
[open_channel_tlvs:tlvs]</screen>
</example>
<simpara>The fields contained in this message specify the channel parameters that Alice wants, as well as various configuration settings from Alice&#8217;s nodes that reflect the security expectations for the operation of the channel.</simpara>
<simpara role="pagebreak-before">Some of the channel construction parameters are listed here:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>chain_hash</literal>
</term>
<listitem>
<simpara>
This identifies which blockchain (e.g., Bitcoin mainnet) will be used for this channel. It is usually the hash of the genesis block of that blockchain.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>funding_satoshis</literal>
</term>
<listitem>
<simpara>
The amount Alice will use to fund the channel, which is the total channel capacity.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>channel_reserve_satoshis</literal>
</term>
<listitem>
<simpara>
The minimum balance, in satoshis, that is reserved on each side of a channel. We will come back to this when we talk about penalties.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>push_msat</literal>
</term>
<listitem>
<simpara>
An optional amount that Alice will immediately "push" to Bob as a payment upon channel funding. <emphasis>Setting this value to anything but 0 means effectively gifting money to your channel partner and should be used with caution.</emphasis>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>to_self_delay</literal>
</term>
<listitem>
<simpara>
A very important security parameter for the protocol. The value in the <literal>open_channel</literal> message is used in the responder&#8217;s commitment transaction, and the <literal>accept_channel</literal> in the initiator&#8217;s. This asymmetry exists to allow each side to express how long the other side needs to wait to unilaterally claim the funds in a commitment transaction. If Bob at any time unilaterally closes the channel against the will of Alice, he commits to not accessing his own funds for the delay defined here. The higher this value, the more security Alice has, but the longer Bob might have his funds locked.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>funding_pubkey</literal>
</term>
<listitem>
<simpara>
The public key that Alice will contribute to the 2-of-2 multisig that anchors this channel.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>X_basepoint</literal>
</term>
<listitem>
<simpara>
Master keys, used to derive child keys for various parts of the commitment, revocation, routed payment (HTLCs), and closing transactions. These will be used and explained in subsequent chapters.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>If you want to understand the other fields and Lightning peer protocol messages that we do not discuss in this book, we suggest you look them up in the BOLT specifications. These messages and fields are important, but cannot be covered in enough detail in the scope of this book. We want you to understand the fundamental principles well enough that you can fill in the details by reading the actual protocol specification (BOLTs).</simpara>
</tip>
</section>
<section id="_the_accept_channel_message">
<title>The accept_channel message</title>
<simpara><indexterm>
  <primary>accept_channel message</primary>
</indexterm><indexterm>
  <primary>channel establishment message flow</primary><secondary>accept_channel message</secondary>
</indexterm>
<indexterm>
  <primary>accept_channel message</primary>
</indexterm>In response to Alice&#8217;s <literal>open_channel</literal> message, Bob sends back the <literal>accept_channel</literal> message shown in <xref linkend="accept_channel_message"/>.</simpara>
<example id="accept_channel_message">
<title>The <literal>accept_channel</literal> message</title>
<screen>[32*byte:temporary_channel_id]
[u64:dust_limit_satoshis]
[u64:max_htlc_value_in_flight_msat]
[u64:channel_reserve_satoshis]
[u64:htlc_minimum_msat]
[u32:minimum_depth]
[u16:to_self_delay]
[u16:max_accepted_htlcs]
[point:funding_pubkey]
[point:revocation_basepoint]
[point:payment_basepoint]
[point:delayed_payment_basepoint]
[point:htlc_basepoint]
[point:first_per_commitment_point]
[accept_channel_tlvs:tlvs]</screen>
</example>
<simpara>As you can see, this is similar to the <literal>open_channel</literal> message and contains Bob&#8217;s node expectations and configuration values.</simpara>
<simpara>The two most important fields in <literal>accept_channel</literal> that Alice will use to construct the payment channel are:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>funding_pubkey</literal>
</term>
<listitem>
<simpara>
The public key Bob&#8217;s node contributes for the 2-of-2 multisig address that anchors the channel.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>minimum_depth</literal>
</term>
<listitem>
<simpara>
The number of confirmations that Bob&#8217;s node expects for the funding transaction before it considers the channel "open" and ready to use.<indexterm>
</indexterm><indexterm>
</indexterm>
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="_the_funding_transaction">
<title>The Funding Transaction</title>
<simpara><indexterm>
  <primary>funding transaction</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>funding transaction</secondary>
</indexterm>
<indexterm>
  <primary>funding transaction</primary>
</indexterm>Once Alice&#8217;s node receives Bob&#8217;s <literal>accept_channel</literal> message, it has the information necessary to construct the <emphasis>funding transaction</emphasis> that anchors the channel to the Bitcoin blockchain. As we discussed in earlier chapters, a Lightning payment channel is anchored by a 2-of-2 multisignature address. First, we need to generate that multisignature address to allow us to construct the funding transaction (and the refund transaction as described subsequently).</simpara>
</section>
<section id="_generating_a_multisignature_address">
<title>Generating a Multisignature Address</title>
<simpara><indexterm>
  <primary>multisignature addresses</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>multisignature addresses</secondary>
</indexterm>
<indexterm>
  <primary>multisignature addresses</primary>
</indexterm>The funding transaction sends some amount of bitcoin (<literal>funding_satoshis</literal> from the <literal>open_channel</literal> message) to a 2-of-2 multisignature output that is constructed from Alice and Bob&#8217;s <literal>funding_pubkey</literal> public keys.</simpara>
<simpara>Alice&#8217;s node constructs a multisignature script as shown here:</simpara>
<pre data-type="programlisting">2 &lt;<em>Alice_funding_pubkey</em>&gt; &lt;<em>Bob_funding_pubkey</em>&gt; 2 CHECKMULTISIG
</pre>
<simpara>Note that, in practice, the funding keys are deterministically <emphasis>sorted</emphasis> (using lexicographical order of the serialized compressed form of the public keys) before being placed in the witness script. By agreeing to this sorted order ahead of time, we ensure that both parties will construct an identical funding transaction output, which is signed by the exchanged commitment transaction signature.</simpara>
<simpara>This script is encoded as a Pay-to-Witness-Script-Hash (P2WSH) Bitcoin address, which looks something like this:</simpara>
<screen>bc1q89ju02heg32yrqdrnqghe6132wek25p6sv6e564znvrvez7tq5zqt4dn02</screen>
</section>
<section id="_constructing_the_funding_transaction">
<title>Constructing the Funding Transaction</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>constructing the funding transaction</secondary>
</indexterm>
<indexterm>
  <primary>constructing the funding transaction</primary>
</indexterm>Alice&#8217;s node can now construct a funding transaction, sending the amount agreed on with Bob (<literal>funding_satoshis</literal>) to the 2-of-2 multisig address. Let&#8217;s assume that funding_satoshis was 140,000 and Alice is spending a 200,000 satoshi output and creating 60,000 satoshi change. The transaction will look something like <xref linkend="A_B_funding_Tx"/>.</simpara>
<figure id="A_B_funding_Tx"><title>Alice constructs the funding transaction</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0704.png"/>
  </imageobject>
  <textobject><phrase>Alice constructs the funding transaction</phrase></textobject>
</mediaobject>
</figure>
<simpara>Alice <emphasis>does not broadcast</emphasis> this transaction because doing so would put her 140,000 satoshi at risk. Once spent to the 2-of-2 multisig, there is no way for Alice to recover her money without Bob&#8217;s signature.</simpara>
<sidebar role="pagebreak-before less_space">
<title>Dual-Funded Payment Channels</title>
<simpara><indexterm>
  <primary>dual-funded payment channels</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>dual-funded</secondary>
</indexterm>
<indexterm>
  <primary>dual-funded</primary>
</indexterm>In the current implementation of Lightning, channels are funded only by the node initiating the channel (Alice in our example). Dual-funded channels have been proposed, but not yet implemented. In a dual-funded channel, both Alice and Bob would contribute inputs to the funding transaction. Dual-funded channels require a slightly more complicated message flow and cryptographic protocol, so they have not been implemented yet but are planned for a future update to the Lightning BOLTs. The <literal>c-lightning</literal> implementation includes an experimental version of a variant on dual-funded channels.</simpara>
</sidebar>
</section>
<section id="_holding_signed_transactions_without_broadcasting">
<title>Holding Signed Transactions Without Broadcasting</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>holding signed transactions without broadcasting</secondary>
</indexterm>
<indexterm>
  <primary>holding signed transactions without broadcasting</primary>
</indexterm>An important Bitcoin feature that makes Lightning possible is the ability to construct and sign transactions, but not broadcast them. The transaction is <emphasis>valid</emphasis> in every way, but until it is broadcast and confirmed on the Bitcoin blockchain it is not recognized and its outputs are not spendable because they have not been created on the blockchain. We will use this capability many times in the Lightning Network, and Alice&#8217;s node uses the capability when constructing the funding transaction: holding it and not broadcasting it yet.</simpara>
</section>
<section id="_refund_before_funding">
<title>Refund Before Funding</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>refund before funding</secondary>
</indexterm>
<indexterm>
  <primary>refund before funding</primary>
</indexterm>To prevent loss of funds, Alice cannot put her bitcoin into a 2-of-2 until she has a way to get a refund if things go wrong. Essentially, she must plan the "exit" from the channel before she enters into this arrangement.</simpara>
<simpara>Consider the legal construct of a prenuptial agreement, also known as a "prenup." When two people enter into a marriage their money is bound together by law (depending on jurisdiction). Prior to entering into the marriage, they can sign an agreement that specifies how to separate their assets if they dissolve their marriage through divorce.</simpara>
<simpara>We can create a similar agreement in Bitcoin. For example, we can create a refund transaction, which functions like a prenup, allowing the parties decide how the funds in their channel will be divided before their funds are actually locked into the multisignature funding address.</simpara>
</section>
<section id="_constructing_the_presigned_refund_transaction">
<title>Constructing the Presigned Refund Transaction</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>constructing the presigned refund transaction</secondary>
</indexterm>
<indexterm>
  <primary>constructing the presigned refund transaction</primary>
</indexterm><indexterm>
  <primary>refund transactions</primary>
</indexterm>Alice will construct the refund transaction immediately after constructing (but not broadcasting) the funding transaction. The refund transaction spends the 2-of-2 <span class="keep-together">multisig</span> back to Alice&#8217;s wallet. <indexterm>
  <primary>commitment transactions</primary><secondary>refund transactions and</secondary>
</indexterm>
<indexterm>
  <primary>refund transactions and</primary>
</indexterm>We call this refund transaction a <emphasis>commitment transaction</emphasis> because it commits both channel partners to distributing the channel balance fairly. Since Alice funded the channel on her own, she gets the entire balance, and both Alice and Bob commit to refunding Alice  with this transaction.</simpara>
<simpara>In practice, it is a bit more complicated as we will see in subsequent chapters, but for now let&#8217;s keep things simple and assume it looks like <xref linkend="A_B_fund_refund_Tx"/>.</simpara>
<figure id="A_B_fund_refund_Tx"><title>Alice also constructs the refund transaction</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0705.png"/>
  </imageobject>
  <textobject><phrase>Alice also constructs the refund transaction</phrase></textobject>
</mediaobject>
</figure>
<simpara>Later in this chapter we will see how more commitment transactions can be made to distribute the balance of the channel in different amounts.</simpara>
</section>
<section id="_chaining_transactions_without_broadcasting">
<title>Chaining Transactions Without Broadcasting</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>chaining transactions without broadcasting</secondary>
</indexterm>
<indexterm>
  <primary>chaining transactions without broadcasting</primary>
</indexterm>So now, Alice has constructed the two transactions shown in <xref linkend="A_B_fund_refund_Tx"/>. But you might be wondering how this is possible.  Alice hasn&#8217;t broadcast the funding transaction to the Bitcoin blockchain. As far as everyone on the network is concerned, that transaction doesn&#8217;t exist. The refund transaction is constructed so as to <emphasis>spend</emphasis> one of the outputs of the funding transaction, even though that output doesn&#8217;t exist yet either. How can you spend an output that hasn&#8217;t been confirmed on the Bitcoin blockchain?</simpara>
<simpara>The refund transaction is not yet a valid transaction. For it to become a valid transaction two things must happen:</simpara>
<itemizedlist>
<listitem>
<simpara>
The funding transaction must be broadcast to the Bitcoin network. (To ensure the security of the Lightning Network, we will also require it to be confirmed by the Bitcoin blockchain, though this is not strictly necessary to chain <span class="keep-together">transactions</span>.)
</simpara>
</listitem>
<listitem>
<simpara>
The refund transaction&#8217;s input needs Alice&#8217;s and Bob&#8217;s signatures.
</simpara>
</listitem>
</itemizedlist>
<simpara role="pagebreak-before">But even though these two things haven&#8217;t happened, and even though Alice&#8217;s node hasn&#8217;t broadcast the funding transaction, she can still construct the refund transaction. She can do so because she can calculate the funding transaction&#8217;s hash and reference it as an input in the refund transaction.</simpara>
<simpara>Notice how Alice has calculated <literal>6da3c2&#8230;387710</literal> as the funding transaction hash? If and when the funding transaction is broadcast, that hash will be recorded as the transaction ID of the funding transaction. Therefore, the <literal>0</literal> output of the funding transaction (the 2-of-2 address output) will then be referenced as output ID <literal>6da3c2&#8230;387710:0</literal>. The refund transaction can be constructed to spend that funding transaction output even though it doesn&#8217;t exist yet, because Alice knows what its identifier will be once confirmed.</simpara>
<simpara>This means that Alice can create a chained transaction by referencing an output that doesn&#8217;t yet exist, knowing that the reference will be valid if the funding transaction is confirmed, making the refund transaction valid too. As we will see in the next section, this "trick" of chaining transactions before they are broadcast requires a very important feature of Bitcoin that was introduced in August of 2017: <emphasis>Segregated Witness</emphasis>.</simpara>
</section>
<section id="_solving_malleability_segregated_witness">
<title>Solving Malleability (Segregated Witness)</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>Transaction Malleability and Segregated Witness</secondary>
</indexterm>
<indexterm>
  <primary>Transaction Malleability and Segregated Witness</primary>
</indexterm><indexterm>
  <primary>Segregated Witness (SegWit) protocol</primary>
</indexterm><indexterm>
  <primary>Transaction Malleability</primary>
</indexterm>Alice has to depend on the transaction ID of the funding transaction being known before confirmation. But before the introduction of  Segregated Witness (SegWit) in August 2017, this was not sufficient to protect Alice. Because of the way transactions were constructed with the signatures (witnesses) included in the transaction ID, it was possible for a third party (e.g., Bob) to broadcast an alternative version of a transaction with a <emphasis>malleated</emphasis> (modified) transaction ID. This is known as <emphasis>transaction malleability</emphasis>, and prior to SegWit, this problem made it difficult to implement indefinite lifetime payment channels securely.</simpara>
<simpara>If Bob could modify Alice&#8217;s funding transaction before it was confirmed, and produce a replica that had a different transaction ID, Bob could make Alice&#8217;s refund transaction invalid and hijack her bitcoin. Alice would be at Bob&#8217;s mercy to get a signature to release her funds and could easily be blackmailed. Bob couldn&#8217;t steal the funds, but he could prevent Alice from getting them back.</simpara>
<simpara>The introduction of SegWit made unconfirmed transaction IDs immutable from the point of view of third parties, meaning that Alice could be sure that the transaction ID of the funding transaction would not change. As a result, Alice can be confident that if she gets Bob&#8217;s signature on the refund transaction, she has a way to recover her money. She now has a way to implement the Bitcoin equivalent of a "prenup" before locking her funds into the multisig.</simpara>
<tip>
<simpara>You might have wondered how Bob would be able to alter (malleate) a transaction created and signed by Alice. Bob certainly does not have Alice&#8217;s private keys. However ECDSA signatures for a message are not unique. Knowing a signature (which is included in a valid transaction) allows one to produce many different-looking signatures that are still valid. Before SegWit removed signatures from the transaction digest algorithm, Bob could replace the signature with an equivalent valid signature that produced a different transaction ID, breaking the chain between the funding transaction and the refund transaction.</simpara>
</tip>
<section id="_the_funding_created_message">
<title>The funding_created message</title>
<simpara><indexterm>
  <primary>funding_created message</primary>
</indexterm><indexterm>
  <primary>Segregated Witness (SegWit) protocol</primary><secondary>funding_created message and</secondary>
</indexterm>
<indexterm>
  <primary>funding_created message and</primary>
</indexterm>Now that Alice has constructed the necessary transactions, the channel construction message flow continues. Alice transmits the <literal>funding_created</literal> message to Bob. You can see the contents of this message here:</simpara>
<formalpara id="funding_created_message"><title>The funding_created message</title><para>
<screen>[32*byte:temporary_channel_id]
[sha256:funding_txid]
[u16:funding_output_index]
[signature:signature]</screen>
</para></formalpara>
<simpara>With this message, Alice gives Bob the important information about the funding transaction that anchors the payment channel:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>funding_txid</literal>
</term>
<listitem>
<simpara>
This is the transaction ID (TxID) of the funding transaction, and is used to create the channel ID once the channel is established.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>funding_output_index</literal>
</term>
<listitem>
<simpara>
This is the output index, so Bob knows which output of the transaction (e.g., output <literal>0</literal>) is the 2-of-2 multisig output funded by Alice. This is also used to form the channel ID.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Finally, Alice also sends the <literal>signature</literal> corresponding to Alice&#8217;s <literal>funding_pubkey</literal> and used to spend from the 2-of-2 multisig. This is needed by Bob because he will also need to create his own version of a commitment transaction. That commitment transaction needs a signature from Alice, which she provides to him. Note that the commitment transactions of Alice and Bob look slightly different, thus the signatures will be different. Knowing what the commitment transaction of the other party looks like is crucial and part of the protocol to provide the valid signature.</simpara>
<tip>
<simpara>In the Lightning protocol we often see nodes sending signatures instead of entire signed transactions. That&#8217;s because either side can reconstruct the same transaction and therefore only the signature is needed to make it valid. Sending only the signature and not the entire transaction saves a lot of network bandwidth.</simpara>
</tip>
</section>
<section id="_the_funding_signed_message">
<title>The funding_signed message</title>
<simpara><indexterm>
  <primary>funding_signed message</primary>
</indexterm><indexterm>
  <primary>Segregated Witness (SegWit) protocol</primary><secondary>funding_signed message and</secondary>
</indexterm>
<indexterm>
  <primary>funding_signed message and</primary>
</indexterm>After receiving the <literal>funding_created</literal> message from Alice, Bob now  knows the funding transaction ID and output index. The channel ID is made by a bitwise "exclusive or" (XOR) of the funding transaction ID and output index:</simpara>
<screen>channel_id = funding_txid XOR funding_output_index</screen>
<simpara>More precisely, a <literal>channel_id</literal>, which is the 32-byte representation of a funding UTXO, is generated by XORing the lower 2 bytes of the funding TxID with the index of the funding output.</simpara>
<simpara>Bob will also need to send Alice his signature for the refund transaction, based on Bob&#8217;s <literal>funding_pubkey</literal> that formed the 2-of-2 multisig. Although Bob already has his local refund transaction, this will allow Alice to complete the refund transaction with all necessary signatures and be sure her money is refundable in case something goes wrong.</simpara>
<simpara>Bob constructs a <literal>funding_signed</literal> message and sends it to Alice. Here we see the contents of this message:<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
<formalpara id="funding_signed_message"><title>The funding_signed message</title><para>
<screen>[channel_id:channel_id]
[signature:signature]</screen>
</para></formalpara>
</section>
</section>
<section id="_broadcasting_the_funding_transaction">
<title>Broadcasting the Funding Transaction</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>broadcasting the funding transaction</secondary>
</indexterm>
<indexterm>
  <primary>broadcasting the funding transaction</primary>
</indexterm>Upon receiving the <literal>funding_signed</literal> message from Bob, Alice now has both signatures needed to sign the refund transaction. Her "exit plan" is now secure, and therefore she can broadcast the funding transaction without fear of having her funds locked. If anything goes wrong, Alice can simply broadcast the refund transaction and get her money back, without any further help from Bob.</simpara>
<simpara>Alice now sends the funding transaction to the Bitcoin network so that it can be mined into the blockchain. Both Alice and Bob will be watching for this transaction and waiting for <literal>minimum_depth</literal> confirmations (e.g., six confirmations) on the Bitcoin blockchain.</simpara>
<tip>
<simpara>Of course Alice will use the Bitcoin Protocol to verify that the signature that Bob sent her is indeed valid. This step is very crucial. If for some reason Bob was sending wrongful data to Alice, her "exit plan" would be sabotaged.</simpara>
</tip>
<section id="_the_funding_locked_message">
<title>The funding_locked message</title>
<simpara><indexterm>
  <primary>funding_locked message</primary>
</indexterm>As soon as the funding transaction has reached the required number of confirmations, both Alice and Bob send the <literal>funding_locked</literal> message to each other and the channel is ready for use.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
</section>
<section id="_sending_payments_across_the_channel">
<title>Sending Payments Across the Channel</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>sending payments across</secondary>
</indexterm>
<indexterm>
  <primary>sending payments across</primary>
</indexterm>The channel has been set up, but in its initial state, all the capacity (140,000 satoshis) is on Alice&#8217;s side. This means that Alice can send payments to Bob across the channel, but Bob has no funds to send to Alice yet.</simpara>
<simpara>In the next few sections we will show how payments are made across the payment channel and how the <emphasis>channel state</emphasis> is updated.</simpara>
<simpara>Let&#8217;s assume that Alice wants to send 70,000 satoshis to Bob to pay her bill at Bob&#8217;s coffee shop.</simpara>
<section id="_splitting_the_balance">
<title>Splitting the Balance</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>splitting the payment balance</secondary>
</indexterm>
<indexterm>
  <primary>splitting the payment balance</primary>
</indexterm>In principle, sending a payment from Alice to Bob is simply a matter of redistributing the balance of the channel. Before the payment is sent, Alice has 140,000 satoshis and Bob has none. After the 70,000 satoshi payment is sent, Alice has 70,000 satoshis <span class="keep-together">and Bob</span> has 70,000 satoshis.</simpara>
<simpara><indexterm>
  <primary>commitment transactions</primary><secondary>splitting balances with</secondary>
</indexterm>
<indexterm>
  <primary>splitting balances with</primary>
</indexterm>Therefore, all Alice and Bob have to do is create and sign a transaction that spends the 2-of-2 multisig to two outputs paying Alice and Bob their corresponding balances. We call this updated transaction a <emphasis>commitment transaction</emphasis>.</simpara>
<simpara>Alice and Bob operate the payment channel by <emphasis>advancing the channel state</emphasis> through a series of commitments. Each commitment updates the balances to reflect payments that have flowed across the channel. Both Alice and Bob can initiate a new commitment to update the channel.</simpara>
<simpara>In <xref linkend="competing_commitments_1"/> we see several commitment transactions.</simpara>
<simpara>The first commitment transaction shown in <xref linkend="competing_commitments_1"/> is the refund transaction that Alice constructed before funding the channel. In the diagram, this is Commitment #0. After Alice pays Bob 70,000 satoshis, the new commitment transaction (Commitment #1) has two outputs paying Alice and Bob their respective balances. We have included two subsequent commitment transactions (Commitment #2 and Commitment #3) which represent Alice paying Bob an additional 10,000 satoshis and then 20,000 satoshis, respectively.</simpara>
<simpara>Each signed and valid commitment transaction can be used by either channel partner at any time to close the channel by broadcasting it to the Bitcoin network. Since they both have the most recent commitment transaction and can use it at any time, they can also just hold it and not broadcast it. It&#8217;s their guarantee of a fair exit from the channel.</simpara>
<figure id="competing_commitments_1"><title>Multiple commitment transactions</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0706.png"/>
  </imageobject>
  <textobject><phrase>Multiple commitment transactions</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_competing_commitments">
<title>Competing Commitments</title>
<simpara><indexterm>
  <primary>commitment transactions</primary><secondary>completing commitments</secondary>
</indexterm>
<indexterm>
  <primary>completing commitments</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>completing commitments</secondary>
</indexterm>
<indexterm>
  <primary>completing commitments</primary>
</indexterm>You may be wondering how it is possible for Alice and Bob to have multiple commitment transactions, all of them attempting to spend the same 2-of-2 output from the funding transaction. Aren&#8217;t these commitment transactions conflicting? <indexterm>
  <primary>double-spending</primary>
</indexterm>Isn&#8217;t this a "double-spend" that the Bitcoin system is meant to prevent?</simpara>
<simpara>It is indeed! In fact, we rely on Bitcoin&#8217;s ability to <emphasis>prevent</emphasis> a double-spend to make Lightning work. No matter how many commitment transactions Alice and Bob construct and sign, only one of them can actually get confirmed.</simpara>
<simpara>As long as Alice and Bob hold these transactions and don&#8217;t broadcast them, the funding output is unspent. But if a commitment transaction is broadcast and confirmed, it will spend the funding output. If Alice or Bob attempts to broadcast more than one commitment transaction, only one of them will be confirmed and the others will be rejected as attempted (and failed) double-spends.</simpara>
<simpara>If more than one commitment transaction is broadcast, there are many factors that will determine which one gets confirmed first: the amount of fees included, the speed of propagation of these competing transactions, network topology, etc. Essentially it becomes a race without a predictable outcome. That doesn&#8217;t sound very secure. It sounds like someone could cheat.</simpara>
</section>
<section id="_cheating_with_old_commitment_transactions">
<title>Cheating with Old Commitment Transactions</title>
<simpara><indexterm>
  <primary>cheating</primary><secondary>with old transactions</secondary>
</indexterm>
<indexterm>
  <primary>with old transactions</primary>
</indexterm><indexterm>
  <primary>commitment transactions</primary><secondary>cheating with old transactions</secondary>
</indexterm>
<indexterm>
  <primary>cheating with old transactions</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>cheating with old commitment transactions</secondary>
</indexterm>
<indexterm>
  <primary>cheating with old commitment transactions</primary>
</indexterm>Let&#8217;s look more carefully at the commitment transactions in <xref linkend="competing_commitments_1"/>. All four commitment transactions are signed and valid. But only the last one accurately reflects the most recent channel balances. In this particular scenario, Alice has an opportunity to cheat by broadcasting an older commitment and getting it confirmed on the Bitcoin blockchain. Let&#8217;s say Alice transmits Commitment #0 and gets it confirmed: she will effectively close the channel and take all 140,000 satoshis herself. In fact, in this particular example any commitment but Commitment #3 improves Alice&#8217;s position and allows her to "cancel" at least part of the payments reflected in the channel.</simpara>
<simpara>In the next section we will see how the Lightning Network resolves this problem—preventing older commitment transactions from being used by the channel partners by a mechanism of revocation and penalties. There are other ways to prevent the transmission of older commitment transactions, such as eltoo channels, but they require an upgrade to Bitcoin called input rebinding (see <xref linkend="bitcoin_prot_17"/>).</simpara>
</section>
<section id="_revoking_old_commitment_transactions">
<title>Revoking Old Commitment Transactions</title>
<simpara><indexterm>
  <primary>commitment transactions</primary><secondary>revoking old transactions</secondary>
</indexterm>
<indexterm>
  <primary>revoking old transactions</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>revoking old commitment transactions</secondary>
</indexterm>
<indexterm>
  <primary>revoking old commitment transactions</primary>
</indexterm>Bitcoin transactions do not expire and cannot be "canceled." Neither can they be stopped or censored once they have been broadcast. So how do we "revoke" a transaction that another person holds that has already been signed?</simpara>
<simpara>The solution used in Lightning is another example of a fairness protocol. <indexterm>
  <primary>penalty mechanisms</primary>
</indexterm>Instead of trying to control the ability to broadcast a transaction, there is a built-in <emphasis>penalty mechanism</emphasis> that ensures it is not in the best interest of a would-be cheater to transmit an old commitment transaction. They can always broadcast it, but they will most likely lose money if they do so.</simpara>
<tip>
<simpara>The word "revoke" is a misnomer because it implies that older commitments are somehow made invalid and cannot be broadcast and confirmed. But this is not the case, since valid Bitcoin transactions cannot be revoked. Instead, the Lightning protocol uses a penalty mechanism to punish the channel partner who broadcasts an old commitment.</simpara>
</tip>
<simpara>There are three elements that make up the Lightning protocol&#8217;s revocation and penalty mechanism:</simpara>
<variablelist>
<varlistentry>
<term>
Asymmetric commitment transactions
</term>
<listitem>
<simpara>
Alice&#8217;s commitment transactions are slightly different from those held by Bob.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Delayed spending
</term>
<listitem>
<simpara>
The payment to the party holding the commitment transaction is delayed (timelocked), whereas the payment to the other party can be claimed immediately.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Revocation keys
</term>
<listitem>
<simpara>
Used to unlock a penalty option for old commitments.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Let&#8217;s look at these three elements in turn.</simpara>
</section>
<section id="_asymmetric_commitment_transactions">
<title>Asymmetric Commitment Transactions</title>
<simpara><indexterm>
  <primary>commitment transactions</primary><secondary>asymmetric</secondary>
</indexterm>
<indexterm>
  <primary>asymmetric</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>asymmetric commitment transactions</secondary>
</indexterm>
<indexterm>
  <primary>asymmetric commitment transactions</primary>
</indexterm>Alice and Bob hold slightly different commitment transactions. Let&#8217;s look specifically at Commitment #2 from <xref linkend="competing_commitments_1"/>, in more detail in <xref linkend="commitment_2"/>.</simpara>
<figure id="commitment_2"><title>Commitment transaction #2</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0707.png"/>
  </imageobject>
  <textobject><phrase>Commitment transaction #2</phrase></textobject>
</mediaobject>
</figure>
<simpara>Alice and Bob hold two different variations of this transaction, as illustrated in <xref linkend="asymmetric_1"/>.</simpara>
<figure id="asymmetric_1"><title>Asymmetric commitment transactions</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0708.png"/>
  </imageobject>
  <textobject><phrase>Asymmetric commitment transactions</phrase></textobject>
</mediaobject>
</figure>
<simpara>By convention, within the Lightning protocol, we refer to the two channel partners as <literal>self</literal> (also known as <literal>local</literal>) and <literal>remote</literal>, depending on which side we&#8217;re looking at. The outputs that pay each channel partner are called <literal>to_local</literal> and <literal>to_remote</literal>, respectively.</simpara>
<simpara>In <xref linkend="asymmetric_1"/> we see that Alice holds a transaction that pays 60,000 satoshis <literal>to_self</literal> (can be spent by Alice&#8217;s keys), and 80,000 satoshis <literal>to_remote</literal> (can be spent by Bob&#8217;s keys).</simpara>
<simpara>Bob holds the mirror image of that transaction, where the first output is 80,000 satoshis <literal>to_self</literal> (can be spent by Bob&#8217;s keys), and 60,000 satoshis <literal>to_remote</literal> (can be spent by Alice&#8217;s keys).</simpara>
</section>
<section id="_delayed_timelocked_spending_to_self">
<title>Delayed (Timelocked) Spending to_self</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>delayed spending to_self</secondary>
</indexterm>
<indexterm>
  <primary>delayed spending to_self</primary>
</indexterm>Using asymmetric transactions allows the protocol to easily ascribe <emphasis>blame</emphasis> to the cheating party. An invariant that the <emphasis>broadcasting</emphasis> party must always wait ensures that the "honest" party has time to refute the claim and revoke their funds. This asymmetry is manifested in the form of differing outputs for each side: the <literal>to_local</literal> output is always timelocked and can&#8217;t be spent immediately, whereas the <literal>to_remote</literal> output is not timelocked and can be spent immediately.</simpara>
<simpara>In the commitment transaction held by Alice, for example, the <literal>to_local</literal> output that pays her is timelocked for 432 blocks, whereas the <literal>to_remote</literal> output that pays Bob can be spent immediately (see <xref linkend="asymmetric_delayed_1"/>). Bob&#8217;s commitment transaction for Commitment #2 is the mirror image: his own (<literal>to_local</literal>) output is timelocked and Alice&#8217;s <literal>to_remote</literal> output can be spent immediately.</simpara>
<figure id="asymmetric_delayed_1"><title>Asymmetric and delayed commitment transactions</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0709.png"/>
  </imageobject>
  <textobject><phrase>Asymmetric and delayed commitment transactions</phrase></textobject>
</mediaobject>
</figure>
<simpara role="pagebreak-before">That means that if Alice closes the channel by broadcasting and confirming the commitment transaction she holds, she cannot spend her balance for 432 blocks, but Bob can claim his balance immediately. If Bob closes the channel using the commitment transaction he holds, he cannot spend his output for 432 blocks while Alice can immediately spend hers.</simpara>
<simpara>The delay is there for one reason: to allow the <emphasis>remote</emphasis> party to exercise a penalty option if an old (revoked) commitment should be broadcast by the other channel partner. Let&#8217;s look at the revocation keys and penalty option next.</simpara>
<simpara>The delay is negotiated by Alice and Bob, during the initial channel construction message flow, as a field called <literal>to_self_delay</literal>. To ensure the security of the channel, the delay is scaled to the capacity of the channel—meaning a channel with more funds has longer delays in the <literal>to_self</literal> outputs in commitments. Alice&#8217;s node includes a desired <literal>to_self_delay</literal> in the <literal>open_channel</literal> message. If Bob finds this acceptable, his node includes the same value for <literal>to_self_delay</literal> in the <literal>accept_channel</literal> message. If they do not agree, then the channel is rejected (see <xref linkend="theShutdownmessage"/>).</simpara>
</section>
<section id="_revocation_keys">
<title>Revocation Keys</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>revocation keys</secondary>
</indexterm>
<indexterm>
  <primary>revocation keys</primary>
</indexterm><indexterm>
  <primary>revocation keys</primary>
</indexterm>As we discussed previously, the word "revocation" is a bit misleading because it implies that the "revoked" transaction cannot be used.</simpara>
<simpara>In fact, the revoked transaction can be used, but if it is used, and it has been revoked, then one of the channel partners can take all of the channel funds by creating a penalty transaction.</simpara>
<simpara>The way this works is that the <literal>to_local</literal> output is not only timelocked, but it also has two spending conditions in the script: it can be spent by <emphasis>self</emphasis> after the timelock delay <emphasis>or</emphasis> it can be spent by <emphasis>remote</emphasis> immediately with a revocation key for this commitment.</simpara>
<simpara>So, in our example, each side holds a commitment transaction that includes a revocation option in the <literal>to_local</literal> output, as shown in <xref linkend="asymmetric_delayed_revocable_1"/>.<indexterm>
</indexterm></simpara>
<figure id="asymmetric_delayed_revocable_1"><title>Asymmetric, delayed, and revocable commitments</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0710.png"/>
  </imageobject>
  <textobject><phrase>Asymmetric, delayed and revocable commitments</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section id="commitment_transaction">
<title>The Commitment Transaction</title>
<simpara><indexterm>
  <primary>commitment transactions</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>commitment transaction</secondary>
</indexterm>
<indexterm>
  <primary>commitment transaction</primary>
</indexterm>Now that we understand the structure of commitment transactions and why we need asymmetric, delayed, revocable commitments, let&#8217;s look at the Bitcoin Script that implements this.</simpara>
<simpara>The first (<literal>to_local</literal>) output of a commitment transaction is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#to_local-output">BOLT #3: Commitment Transaction, <literal>to_local</literal> Output</ulink>, as follows:</simpara>
<screen>OP_IF
    # Penalty transaction
    &lt;revocationpubkey&gt;
OP_ELSE
    &lt;to_self_delay&gt;
    OP_CHECKSEQUENCEVERIFY
    OP_DROP
    &lt;local_delayedpubkey&gt;
OP_ENDIF
OP_CHECKSIG</screen>
<simpara>This is a conditional script (see <xref linkend="conditional_scripts"/>), which means the output can be spent if <emphasis>either</emphasis> of the two conditions is met. The first clause allows the output to be spent by anyone who can sign for <literal>&lt;revocationpubkey&gt;</literal>. The second clause is timelocked by <literal>&lt;to_self_delay&gt;</literal> blocks and can only be spent after that many blocks by anyone who can sign for <literal>&lt;local_delayedpubkey&gt;</literal>. In our example, we had set the <literal>&lt;to_self_delay&gt;</literal> timelock to 432 blocks, but this is a configurable delay that is negotiated by the two channel partners. The <literal>to_self_delay</literal> timelock duration is usually chosen in proportion to the channel capacity, meaning that larger capacity channels (more funds), have longer <literal>to_self_delay</literal> timelocks to protect the parties.</simpara>
<simpara>The first clause allows the output to be spent by anyone who can sign for <literal>&lt;revocationpubkey&gt;</literal>. A critical requirement to the security of this script is that the remote party <emphasis>cannot</emphasis> unilaterally sign with the <literal>revocationpubkey</literal>. To see why this is important, consider the scenario in which the remote party breaches a previously revoked commitment. If they can sign with this key, then they can simply take the revocation clause <emphasis>themselves</emphasis> and steal all the funds in the channel. Instead, we derive the <literal>revocationpubkey</literal> for <emphasis>each</emphasis> state based on information from <emphasis>both</emphasis> the self (local) and remote party. A clever use of symmetric and asymmetric cryptography is used to allow both sides to compute the <literal>revocationpubkey</literal> public key, but only allow the honest self party to compute the private key given their secret information, as detailed in <xref linkend="revocation_sidebar"/>.</simpara>
<sidebar id="revocation_sidebar">
<title>Revocation and Commitment Secret Derivations</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>revocation and commitment secret derivations</secondary>
</indexterm>
<indexterm>
  <primary>revocation and commitment secret derivations</primary>
</indexterm>Each side sends a <literal>revocation_basepoint</literal> during the initial channel negotiation messages as well as a <literal>first_per_commitment_point</literal>. The <literal>revocation_basepoint</literal> is static for the lifetime of the channel, while each new channel state will be based off a new <literal>first_per_commitment_point</literal>.</simpara>
<simpara>Given this information, the <literal>revocationpubkey</literal> for each channel state is derived via the following series of elliptic curve and hashing operations:</simpara>
<screen>revocationpubkey = revocation_basepoint * sha256(revocation_basepoint || per_commitment_point) + per_commitment_point * sha256(per_commitment_point || revocation_basepoint)</screen>
<simpara>Due to the commutative property of the abelian groups that elliptic curves are defined over, once the <literal>per_commitment_secret</literal> (the private key for the <literal>per_commitment_point</literal>) is revealed by the remote party, self can derive the private key for the <literal>revocationpubkey</literal> with the following operation:</simpara>
<screen>revocation_priv = (revocationbase_priv * sha256(revocation_basepoint || per_commitment_point)) + (per_commitment_secret * sha256(per_commitment_point || revocation_basepoint)) mod N</screen>
<simpara>To see why this works in practice, notice that we can <emphasis>reorder</emphasis> (commute) and expand the public key computation of the original formula for <literal>revocationpubkey</literal>:
```
revocationpubkey = G*(revocationbase_priv * sha256(revocation_basepoint || per_commitment_point) + G*(per_commitment_secret * sha256(per_commitment_point || revocation_basepoint))
                 = revocation_basepoint * sha256(revocation_basepoint || per_commitment_point) + per_commitment_point * sha256(per_commitment_point || revocation_basepoint))
```</simpara>
<simpara>In other words, the <literal>revocationbase_priv</literal> can only be derived (and used to sign for the <literal>revocationpubkey</literal>) by the party that knows <emphasis>both</emphasis> the <literal>revocationbase_priv</literal> <emphasis>and</emphasis> the <literal>per_commitment_secret</literal>. This little trick is what makes the public-key-based revocation system used in the Lightning Network secure.</simpara>
</sidebar>
<tip>
<simpara><indexterm>
  <primary>relative timelock</primary>
</indexterm>The timelock used in the commitment transaction with <literal>CHECK&#x200b;SE&#x2060;QUENCEVERIFY</literal> is a <emphasis>relative timelock</emphasis>. It counts elapsed blocks from the confirmation of this output. That means it will not be spendable until the <literal>to_self_delay</literal> block <emphasis>after</emphasis> this commitment transaction is broadcast and confirmed.</simpara>
</tip>
<simpara>The second output (to_remote) output of the commitment transaction is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#to_remote-output">BOLT #3: Commitment Transaction,  <literal>to_remote</literal> Output</ulink>, and in the simplest form is a Pay-to-Witness-Public-Key-Hash (P2WPKH) for <literal>&lt;remote_pubkey&gt;</literal>, meaning that it simply pays the owner who can sign for <literal>&lt;remote_pubkey&gt;</literal>.</simpara>
<simpara>Now that we&#8217;ve defined the commitment transactions in detail, let&#8217;s see how Alice and Bob advance the state of the channel, create and sign new commitment transactions, and revoke old commitment transactions.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
<section id="_advancing_the_channel_state">
<title>Advancing the Channel State</title>
<simpara><indexterm>
  <primary>channel state</primary><secondary>advancing</secondary>
</indexterm>
<indexterm>
  <primary>advancing</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>advancing the channel state</secondary>
</indexterm>
<indexterm>
  <primary>advancing the channel state</primary>
</indexterm>To advance the state of the channel, Alice and Bob exchange two messages: <literal>commitment_signed</literal> and <literal>revoke_and_ack</literal> messages. The <literal>commitment_signed</literal> message can be sent by either channel partner when they have an update to the channel state. The other channel partner then may respond with <literal>revoke_and_ack</literal> to <emphasis>revoke</emphasis> the old commitment and <emphasis>acknowledge</emphasis> the new commitment.</simpara>
<simpara>In <xref linkend="commitment_message_flow"/> we see Alice and Bob exchanging two pairs of <literal>commitment_signed</literal> and <literal>revoke_and_ack</literal>. The first flow shows a state update initiated by Alice (left to right <literal>commitment_signed</literal>), to which Bob responds (right to left <literal>revoke_and_ack</literal>). The second flow shows a state update initiated by Bob and responded to by Alice.</simpara>
<figure id="commitment_message_flow"><title>Commitment and revocation message flow</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0711.png"/>
  </imageobject>
  <textobject><phrase>Commitment and revocation message flow</phrase></textobject>
</mediaobject>
</figure>
<section id="_the_commitment_signed_message">
<title>The commitment_signed Message</title>
<simpara><indexterm>
  <primary>channel state</primary><secondary>commitment_signed message</secondary>
</indexterm>
<indexterm>
  <primary>commitment_signed message</primary>
</indexterm><indexterm>
  <primary>commitment_signed message</primary>
</indexterm>The structure of the <literal>commitment_signed</literal> message is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#committing-updates-so-far-commitment_signed">BOLT #2: Peer Protocol, <literal>commitment_signed</literal></ulink>, and shown here:</simpara>
<formalpara id="commitment_signed_message"><title>The commitment_signed message</title><para>
<screen>[channel_id:channel_id]
[signature:signature]
[u16:num_htlcs]
[num_htlcs*signature:htlc_signature]</screen>
</para></formalpara>
<variablelist>
<varlistentry>
<term>
<literal>channel_id</literal>
</term>
<listitem>
<simpara>
The identifier of the channel
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>signature</literal>
</term>
<listitem>
<simpara>
The signature for the new remote commitment
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>num_htlcs</literal>
</term>
<listitem>
<simpara>
The number of updated HTLCs in this commitment
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>htlc_signature</literal>
</term>
<listitem>
<simpara>
The signatures for the updates
</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>The use of HTLCs to commit updates will be explained in detail in <xref linkend="htlcs"/> and in <xref linkend="channel_operation"/>.</simpara>
</note>
<simpara>Alice&#8217;s <literal>commitment_signed</literal> message gives Bob the signature needed (Alice&#8217;s part of the 2-of-2) for a new commitment transaction.</simpara>
</section>
<section id="_the_revoke_and_ack_message">
<title>The revoke_and_ack Message</title>
<simpara><indexterm>
  <primary>channel state</primary><secondary>revoke_and_ack message</secondary>
</indexterm>
<indexterm>
  <primary>revoke_and_ack message</primary>
</indexterm><indexterm>
  <primary>revoke_and_ack message</primary>
</indexterm>Now that Bob has a new commitment transaction, he can revoke the previous commitment by giving Alice a revocation key, and construct the new commitment with Alice&#8217;s signature.</simpara>
<simpara>The <literal>revoke_and_ack</literal> message is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#completing-the-transition-to-the-updated-state-revoke_and_ack">BOLT #2: Peer Protocol, <literal>revoke_and_ack</literal></ulink>, and shown here:</simpara>
<formalpara id="revoke_and_ack_message"><title>The revoke_and_ack message</title><para>
<screen>[channel_id:channel_id]
[32*byte:per_commitment_secret]
[point:next_per_commitment_point]</screen>
</para></formalpara>
<variablelist>
<varlistentry>
<term>
<literal>channel_id</literal>
</term>
<listitem>
<simpara>
This is the identifier of the channel.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>per_commitment_secret</literal>
</term>
<listitem>
<simpara>
Used to generate a revocation key for the previous (old) commitment, effectively revoking it.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>next_per_commitment_point</literal>
</term>
<listitem>
<simpara>
Used to build a <literal>revocation_pubkey</literal> for the new commitment, so that it can later be revoked.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="revocation">
<title>Revoking and Recommitting</title>
<simpara><indexterm>
  <primary>channel state</primary><secondary>revoking and recommitting</secondary>
</indexterm>
<indexterm>
  <primary>revoking and recommitting</primary>
</indexterm>Let&#8217;s look at this interaction between Alice and Bob more closely.</simpara>
<simpara>Alice is giving Bob the means to create a new commitment. In return, Bob is revoking the old commitment to assure Alice that he won&#8217;t use it. Alice can only trust the new commitment if she has the revocation key to punish Bob for publishing the old commitment. From Bob&#8217;s perspective, he can safely revoke the old commitment by giving Alice the keys to penalize him, because he has a signature for a new commitment.</simpara>
<simpara>When Bob responds with <literal>revoke_and_ack</literal>, he gives Alice a <literal>per_commitment_secret</literal>. This secret can be used to construct the revocation signing key for the old commitment, which allows Alice to seize all channel funds by exercising a penalty.</simpara>
<simpara>As soon as Bob has given this secret to Alice, he <emphasis>must not</emphasis> ever broadcast that old commitment. If he does, he will give Alice the opportunity to penalize him by taking the funds. Essentially, Bob is giving Alice the ability to hold him accountable for broadcasting an old commitment, and in effect he has revoked his ability to use that old commitment.</simpara>
<simpara>Once Alice has received the <literal>revoke_and_ack</literal> from Bob, she can be sure that Bob cannot broadcast the old commitment without being penalized. She now has the keys necessary to create a penalty transaction if Bob broadcasts an old commitment.</simpara>
</section>
<section id="revocation_secret_derivation">
<title>Cheating and Penalty in Practice</title>
<simpara><indexterm>
  <primary>channel state</primary><secondary>cheating and penalty in practice</secondary>
</indexterm>
<indexterm>
  <primary>cheating and penalty in practice</primary>
</indexterm><indexterm>
  <primary>cheating</primary><secondary>monitoring for</secondary>
</indexterm>
<indexterm>
  <primary>monitoring for</primary>
</indexterm>In practice, both Alice and Bob have to monitor for cheating. They are monitoring the Bitcoin blockchain for any commitment transactions related to any of the channels they are operating. If they see a commitment transaction confirmed on-chain, they will check to see if it is the most recent commitment. If it is an "old" commitment, they must immediately construct and broadcast a penalty transaction. The penalty transaction spends <emphasis>both</emphasis> the <literal>to_local</literal> and <literal>to_remote</literal> outputs, closing the channel and sending both balances to the cheated channel partner.</simpara>
<simpara>To more easily allow both sides to keep track of the commitment numbers of the passed revoke commitments, each commitment actually <emphasis>encodes</emphasis> the number of the commitment within the lock time and sequence fields in a transition. Within the <indexterm>
  <primary>state hints</primary>
</indexterm>protocol, this special encoding is referred to as <emphasis>state hints</emphasis>. Assuming a party knows the current commitment number, they&#8217;re able to use the state hints to easily recognize if a broadcasted commitment was a revoked one, and if so, which commitment number was breached, as that number is used to easily look up which revocation secret should be used in the revocation secret tree (shachain).</simpara>
<simpara><indexterm>
  <primary>obfuscated state hints</primary>
</indexterm>Rather than encode the state hint in plain sight, an <emphasis>obfuscated</emphasis> state hint is used in its place. This obfuscation is achieved by first XORing the current commitment number with a set of random bytes generated deterministically using the funding public keys of both sides of the channel. A total of 6 bytes across the lock time and sequence (24 bits of the locktime and 24 bits of the sequence) are used to encode the state hint within the commitment transaction, so 6 random bytes are needed to use for XORing. To obtain these 6 bytes, both sides obtain the SHA-256 hash of the initiator&#8217;s funding key concatenated to the responder&#8217;s funding key. Before encoding the current commitment height, the integer is XORed with this state hint obfuscator, and then encoded in the lower 24 bits of the locktime, and the upper 64 bits of the sequence.</simpara>
<simpara>Let&#8217;s review our channel between Alice and Bob and show a specific example of a penalty transaction. In <xref linkend="competing_commitments_2"/> we see the four commitments on Alice and Bob&#8217;s channel. Alice has made three payments to Bob:</simpara>
<itemizedlist>
<listitem>
<simpara>
70,000 satoshis paid and committed to Bob with Commitment #1
</simpara>
</listitem>
<listitem>
<simpara>
10,000 satoshis paid and committed to Bob with Commitment #2
</simpara>
</listitem>
<listitem>
<simpara>
20,000 satoshis paid and committed to Bob with Commitment #3
</simpara>
</listitem>
</itemizedlist>
<figure id="competing_commitments_2"><title>Revoked and current commitments</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0712.png"/>
  </imageobject>
  <textobject><phrase>Revoked and current commitments</phrase></textobject>
</mediaobject>
</figure>
<simpara>With each commitment, Alice has revoked the previous (older) commitment. The current state of the channel and the correct balance is represented by Commitment #3. All previous commitments have been revoked, and Bob has the keys necessary to issue penalty transactions against them, in case Alice tries to broadcast one of them.</simpara>
<simpara>Alice might have an incentive to cheat because all the previous commitment transactions would give her a higher proportion of the channel balance than she is entitled to. Let&#8217;s say for example that Alice tried to broadcast Commitment #1. That commitment transaction would pay Alice 70,000 satoshis and Bob 70,000 satoshis. If Alice was able to broadcast and spend her <literal>to_local</literal> output, she would effectively be stealing 30,000 satoshis from Bob by rolling back her last two payments to Bob.</simpara>
<simpara>Alice decides to take a huge risk and broadcast the revoked Commitment #1, to steal 30,000 satoshis from Bob. In <xref linkend="cheating_commitment"/> we see Alice&#8217;s old commitment that she broadcasts to the Bitcoin blockchain.</simpara>
<figure id="cheating_commitment"><title>Alice cheating</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0713.png"/>
  </imageobject>
  <textobject><phrase>Alice cheating</phrase></textobject>
</mediaobject>
</figure>
<simpara>As you can see, Alice&#8217;s old commitment has two outputs, one paying herself 70,000 satoshis (<literal>to_local</literal> output) and one paying Bob 70,000 satoshis. Alice can&#8217;t yet spend her 70,000 <literal>to_local</literal> output because it has a 432 block (3 day) timelock. She is now hoping that Bob doesn&#8217;t notice for three days.</simpara>
<simpara>Unfortunately for Alice, Bob&#8217;s node is diligently monitoring the Bitcoin blockchain and sees an old commitment transaction broadcast and (eventually) confirmed on-chain.</simpara>
<simpara>Bob&#8217;s node will immediately broadcast a penalty transaction. Since this old commitment was revoked by Alice, Bob has the <literal>per_commitment_secret</literal> that Alice sent him. He uses that secret to construct a signature for the <literal>revocation_pubkey</literal>. While Alice has to wait for 432 blocks, Bob can spend <emphasis>both</emphasis> outputs immediately. He can spend the <literal>to_remote</literal> output with his private keys because it was meant to pay him anyway. He can also spend the output meant for Alice with a signature from the revocation key. His node broadcasts the penalty transaction shown in <xref linkend="penalty_transaction"/>.</simpara>
<figure id="penalty_transaction"><title>Cheating and penalty</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0714.png"/>
  </imageobject>
  <textobject><phrase>Cheating and penalty</phrase></textobject>
</mediaobject>
</figure>
<simpara>Bob&#8217;s penalty transaction pays 140,000 satoshis to his own wallet, taking the entire channel capacity. Alice has not only failed to cheat, she has lost everything in the attempt!<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
<section id="_the_channel_reserve_ensuring_skin_in_the_game">
<title>The Channel Reserve: Ensuring Skin in the Game</title>
<simpara><indexterm>
  <primary>channel reserve</primary>
</indexterm><indexterm>
  <primary>channel state</primary><secondary>channel reserve</secondary>
</indexterm>
<indexterm>
  <primary>channel reserve</primary>
</indexterm>You may have noticed there is a special situation that needs to be dealt with. If Alice could keep spending her balance until it is zero, she would be in a position to close the channel by broadcasting an old commitment transaction without risking a penalty: either the revoked commitment transaction succeeds after the delay, or the cheater gets caught but there&#8217;s no consequence because the penalty is zero. From a game theory perspective, it is free money to attempt to cheat in this situation. This is why the channel reserve is in play, so a prospective cheater always faces the risk of a penalty.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_closing_the_channel_cooperative_close">
<title>Closing the Channel (Cooperative Close)</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>closing the channel</secondary>
</indexterm>
<indexterm>
  <primary>closing the channel</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>cooperative close</secondary>
</indexterm>
<indexterm>
  <primary>cooperative close</primary>
</indexterm>So far we&#8217;ve looked at the commitment transactions as one possible way to close a channel, unilaterally. This type of channel closure is not ideal because it forces a timelock on the channel partner that uses it.</simpara>
<simpara>A better way to close a channel is a cooperative close. In a cooperative close, the two <indexterm>
  <primary>closing transactions</primary>
</indexterm>channel partners negotiate a final commitment transaction called the <emphasis>closing transaction</emphasis> that pays each party their balance immediately to the destination wallet of their choice. Then, the partner that initiated the channel closing flow will broadcast the closing transaction.</simpara>
<simpara>The closing message flow is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#channel-close">BOLT #2: Peer Protocol, Channel Close</ulink>, and is shown in <xref linkend="closing_message_flow"/>.</simpara>
<figure id="closing_message_flow"><title>The channel close message flow</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0715.png"/>
  </imageobject>
  <textobject><phrase>The channel close message flow</phrase></textobject>
</mediaobject>
</figure>
<section id="theShutdownmessage">
<title>The Shutdown Message</title>
<simpara><indexterm>
  <primary>closing the channel</primary><secondary>shutdown message</secondary>
</indexterm>
<indexterm>
  <primary>shutdown message</primary>
</indexterm><indexterm>
  <primary>shutdown message</primary>
</indexterm>Channel closing starts with one of the two channel partners sending the <literal>shutdown</literal> message. The contents of this message are shown here:</simpara>
<formalpara id="shutdown_message"><title>The shutdown message</title><para>
<screen>[channel_id:channel_id]
[u16:len]
[len*byte:scriptpubkey]</screen>
</para></formalpara>
<variablelist>
<varlistentry>
<term>
<literal>channel_id</literal>
</term>
<listitem>
<simpara>
The channel identifier for the channel we want to close
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>len</literal>
</term>
<listitem>
<simpara>
The length of the script of the destination wallet that this channel partner wants to receive their balance
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>scriptpubkey</literal>
</term>
<listitem>
<simpara>
A Bitcoin script of the destination wallet, in one of the "standard" Bitcoin address formats (P2PKH, P2SH, P2WPKH, P2WSH, etc.; see the <xref linkend="glossary"/>)
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Let&#8217;s say Alice sends the <literal>shutdown</literal> message to Bob to close their channel. Alice will specify a Bitcoin script that corresponds to the Bitcoin address of her wallet. She&#8217;s telling Bob: let&#8217;s make a closing transaction that pays my balance to this wallet.</simpara>
<simpara>Bob will respond with his own <literal>shutdown</literal> message indicating that he agrees to cooperatively close the channel. His <literal>shutdown</literal> message includes the script for his wallet address.</simpara>
<simpara>Now both Alice and Bob have each other&#8217;s preferred wallet address, and they can construct identical closing transactions to settle the channel balance.</simpara>
</section>
<section id="_the_closing_signed_message">
<title>The closing_signed Message</title>
<simpara><indexterm>
  <primary>closing the channel</primary><secondary>closing_signed message</secondary>
</indexterm>
<indexterm>
  <primary>closing_signed message</primary>
</indexterm><indexterm>
  <primary>closing_signed message</primary>
</indexterm>Assuming the channel has no outstanding commitments or updates and the channel partners have exchanged the <literal>shutdown</literal> messages shown in the previous section, they can now finish this cooperative close.</simpara>
<simpara>The <emphasis>funder</emphasis> of the channel (Alice in our example) starts by sending a <literal>closing_signed</literal> message to Bob. This message proposes a transaction fee for the on-chain transaction, and Alice&#8217;s signature (the 2-of-2 multisig) for the closing transaction. The <literal>closing_signed</literal> message is shown here:</simpara>
<formalpara id="closing_signed_message"><title>The closing_signed message</title><para>
<screen>[channel_id:channel_id]
[u64:fee_satoshis]
[signature:signature]</screen>
</para></formalpara>
<variablelist>
<varlistentry>
<term>
<literal>channel_id</literal>
</term>
<listitem>
<simpara>
The channel identifier
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>fee_satoshis</literal>
</term>
<listitem>
<simpara>
The proposed on-chain transaction fee, in satoshis
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>signature</literal>
</term>
<listitem>
<simpara>
The sender&#8217;s signature for the closing transaction
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>When Bob receives this, he can reply with a <literal>closing_signed</literal> message of his own. If he agrees with the fee, he simply returns the same proposed fee and his own signature. If he disagrees, he must propose a different <literal>fee_satoshis</literal> fee.</simpara>
<simpara>This negotiation may continue with back-and-forth <literal>closing_signed</literal> messages until the two channel partners agree on a fee.</simpara>
<simpara>Once Alice receives a <literal>closing_signed</literal> message with the same fee as the one she proposed in her last message, the negotiation is complete. Alice signs and broadcasts the closing transaction and the channel is closed.</simpara>
</section>
<section id="_the_cooperative_close_transaction">
<title>The Cooperative Close Transaction</title>
<simpara><indexterm>
  <primary>closing the channel</primary><secondary>cooperative close transaction</secondary>
</indexterm>
<indexterm>
  <primary>cooperative close transaction</primary>
</indexterm><indexterm>
  <primary>cooperative close transaction</primary>
</indexterm>The cooperative close transaction looks similar to the last commitment transaction that Alice and Bob had agreed on. However, unlike the last commitment transaction, it does not have timelocks or penalty revocation keys in the outputs. Since both parties cooperate to produce this transaction and they won&#8217;t be making any further commitments, there is no need for the asymmetric, delayed, and revocable elements in this transaction.</simpara>
<simpara>Typically the addresses used in this cooperative close transaction are generated freshly for each channel being closed. However, it&#8217;s also possible for both sides to <emphasis>lock in</emphasis> a "delivery" address to be used to send their cooperatively settled funds to. Within the TLV namespace of both the <literal>open_channel</literal> and <literal>accept_channel</literal> messages, both sides are free to specify an "up-front shutdown script." Commonly, this address is derived from keys that reside in cold storage. This practice serves to increase the security of channels: if a channel partner is somehow hacked, then the hacker isn&#8217;t able to cooperatively close the channel using an address they control. Instead, the uncompromised honest channel partner will refuse to cooperate on a channel closure if the specified up-front shutdown address isn&#8217;t used. This feature effectively creates a "closed loop," restricting the flow of funds out of a given channel.</simpara>
<simpara>Alice broadcasts a transaction shown in <xref linkend="closing_transaction"/> to close the channel.</simpara>
<figure id="closing_transaction"><title>The cooperative close transaction</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0716.png"/>
  </imageobject>
  <textobject><phrase>The cooperative close transaction</phrase></textobject>
</mediaobject>
</figure>
<simpara>As soon as this closing transaction is confirmed on the Bitcoin blockchain, the channel is closed. Now, Alice and Bob can spend their outputs as they please.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_conclusion_6">
<title>Conclusion</title>
<simpara>In this section we looked at payment channels in much more detail. We examined three message flows used by Alice and Bob to negotiate funding, commitments, and closing of the channel. We also showed the structure of the funding, commitment, and closing transactions, and looked at the revocation and penalty mechanisms.</simpara>
<simpara>As we will see in the next few chapters, HTLCs are used even for local payments between channel partners. They are not necessary, but the protocol is much simpler if local (one channel) and routed (many channels) payments are done in the same way.</simpara>
<simpara>In a single payment channel, the number of payments per second is only bound by the network capacity between Alice and Bob. As long as the channel partners are able to send a few bytes of data back and forth to agree to a new channel balance, they have effectively made a payment. This is why we can achieve a much greater throughput of payments on the Lightning Network (off-chain) than the transaction throughput that can be handled by the Bitcoin blockchain (on-chain).<indexterm>
</indexterm></simpara>
<simpara>In the next few chapters we will discuss routing, HTLCs, and their use in channel operations.</simpara>
</section>
</chapter>
<chapter id="routing">
<title>Routing on a Network of <span class="keep-together">Payment Channels</span></title>
<simpara><indexterm>
  <primary>routing</primary>
</indexterm>In this chapter we will finally unpack how payment channels can be connected to form a network of payment channels via a process called <emphasis>routing</emphasis>. Specifically, we will look at the first part of the routing layer, the "Atomic and trustless multihop contracts" protocol. This is highlighted by an outline in the protocol suite, shown in <xref linkend="LN_protocol_routing_highlight"/>.</simpara>
<figure id="LN_protocol_routing_highlight"><title>Atomic payment routing in the Lightning protocol suite</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0801.png"/>
  </imageobject>
  <textobject><phrase>Atomic payment routing in the Lightning protocol suite</phrase></textobject>
</mediaobject>
</figure>
<section id="_routing_a_payment">
<title>Routing a Payment</title>
<simpara><indexterm>
  <primary>routing</primary><secondary>routing a payment</secondary>
</indexterm>
<indexterm>
  <primary>routing a payment</primary>
</indexterm>In this section we will examine routing from the perspective of Dina, a gamer who receives donations from her fans while she streams her game sessions.</simpara>
<simpara>The innovation of routed payment channels allows Dina to receive tips without maintaining a separate channel with every one of her fans who want to tip her.
As long as there exists a path of well-funded channels from that viewer to Dina, she will be able to receive payment from that fan.</simpara>
<simpara>In <xref linkend="dina_routing_diagram"/> we see a possible network layout created by various payment channels between Lightning nodes. Everyone in this diagram can send Dina a payment by constructing a path. Imagine that Fan 4 wants to send Dina a payment. Do you see the path that could allow that to happen? Fan 4 could route a payment to Dina via Fan 3, Bob, and Chan. Similarly, Alice could route a payment to Dina via Bob and Chan.</simpara>
<figure id="dina_routing_diagram"><title>Fans connected (in)directly to Dina on the Lightning Network</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0802.png"/>
  </imageobject>
  <textobject><phrase>Fans connected (in)directly to Dina on the Lightning Network</phrase></textobject>
</mediaobject>
</figure>
<simpara><indexterm>
  <primary>routing nodes</primary>
</indexterm>The nodes along the path from the fan to Dina are intermediaries called <emphasis>routing nodes</emphasis> in the context of routing a payment. There is no functional difference between the routing nodes and the nodes operated by Dina&#8217;s fans. Any Lightning node is capable of routing payments across its payment channels.</simpara>
<simpara>Importantly, the routing nodes are unable to steal the funds while routing a payment from a fan to Dina.
Furthermore, routing nodes cannot lose money while participating in the routing process.
Routing nodes can charge a routing fee for acting as an intermediary, although they don&#8217;t have to and may choose to route payments for free.</simpara>
<simpara>Another important detail is that due to the use of onion routing, intermediary nodes are only explicitly aware of the one node preceding them and the one node following them in the route.
They will not necessarily know who is the sender and recipient of the payment.
This enables fans to use intermediary nodes to pay Dina, without leaking private information and without risking theft.</simpara>
<simpara>This process of connecting a series of payment channels with end-to-end security, and the incentive structure for nodes to <emphasis>forward</emphasis> payments, is one of the key innovations of the Lightning Network.</simpara>
<simpara>In this chapter, we&#8217;ll dive into the mechanism of routing in the Lightning Network, detailing the precise manner in which payments flow through the network. First, we will clarify the concept of routing and compare it to that of pathfinding, because these are often confused and used interchangeably. Next, we will construct the fairness protocol: an atomic, trustless, multihop protocol used to route payments. To demonstrate how this fairness protocol works, we will be using a physical equivalent of transferring gold coins between four people. Finally, we will look at the atomic, trustless, multihop protocol implementation currently used in the Lightning Network, which is called a hash time-locked contract (HTLC).</simpara>
</section>
<section id="_routing_versus_pathfinding">
<title>Routing Versus Pathfinding</title>
<simpara><indexterm>
  <primary>pathfinding</primary><secondary>routing versus</secondary>
</indexterm>
<indexterm>
  <primary>routing versus</primary>
</indexterm><indexterm>
  <primary>routing</primary><secondary>pathfinding versus</secondary>
</indexterm>
<indexterm>
  <primary>pathfinding versus</primary>
</indexterm>It&#8217;s important to note that we separate the concept of <emphasis>routing</emphasis> from the concept of <emphasis>pathfinding</emphasis>. These two concepts are often confused, and the term <emphasis>routing</emphasis> is often used to describe both concepts. Let&#8217;s remove the ambiguity before we proceed any further.</simpara>
<simpara>Pathfinding, which is covered in <xref linkend="path_finding"/>, is the process of finding and choosing a contiguous path made of payment channels that connects sender A to recipient B. The sender of a payment does the pathfinding by examining the <emphasis>channel graph</emphasis> that they have assembled from channel announcements gossiped by other nodes.</simpara>
<simpara>Routing refers to the series of interactions across the network that attempt to forward a payment from some point A to another point B, across the path previously selected by pathfinding. Routing is the active process of sending a payment on a path, which involves the cooperation of all the intermediary nodes along that path.</simpara>
<simpara>An important rule of thumb is that it&#8217;s possible for a <emphasis>path</emphasis> to exist between Alice and Bob (perhaps even more than one), yet there may not be an active <emphasis>route</emphasis> on which to send the payment. One example is the scenario in which all the nodes connecting Alice and Bob are currently offline. In this example, one can examine the channel graph and connect a series of payment channels from Alice to Bob, hence a <emphasis>path</emphasis> exists. However, because the intermediary nodes are offline, the payment cannot be sent and so no <emphasis>route</emphasis> exists.</simpara>
</section>
<section id="_creating_a_network_of_payment_channels">
<title>Creating a Network of Payment Channels</title>
<simpara><indexterm>
  <primary>routing</primary><secondary>creating a network of payment channels</secondary>
</indexterm>
<indexterm>
  <primary>creating a network of payment channels</primary>
</indexterm>Before we dive into the concept of an atomic trustless multihop payment, let&#8217;s work through an example.
Let&#8217;s return to Alice who, in previous chapters, purchased a coffee from Bob with whom she has an open channel.
Now Alice is watching a live stream from Dina, the gamer, and wants to send Dina a tip of 50,000 satoshis via the Lightning Network. But Alice has no direct channel with Dina. What can Alice do?</simpara>
<simpara>Alice could open a direct channel with Dina; however, that would require liquidity and on-chain fees which could be more than the value of the tip itself. Instead, Alice can use her existing open channels to send a tip to Dina <emphasis>without</emphasis> the need to open a channel directly with Dina. This is possible, as long as there exists some path of channels from Alice to Dina with sufficient capacity to route the tip.</simpara>
<simpara>As you can see in <xref linkend="routing_network"/>, Alice has an open channel with Bob, the coffee shop owner. Bob, in turn, has an open channel with the software developer Chan who helps him with the point of sale system he uses in his coffee shop. Chan is also the owner of a large software company which develops the game that Dina plays, and they already have an open channel which Dina uses to pay for the game&#8217;s license and in-game items.</simpara>
<figure id="routing_network"><title>A network of payment channels between Alice and Dina</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0803.png"/>
  </imageobject>
  <textobject><phrase>A network of payment channels between Alice and Dina</phrase></textobject>
</mediaobject>
</figure>
<simpara>It&#8217;s possible to trace a <emphasis>path</emphasis> from Alice to Dina that uses Bob and Chan as intermediary routing nodes.
Alice can then craft a <emphasis>route</emphasis> from this outlined path and use it to send a tip of a few thousand satoshis to Dina, with the payment being <emphasis>forwarded</emphasis> by Bob and Chan.
Essentially, Alice will pay Bob, who will pay Chan, who will pay Dina. No direct channel from Alice to Dina is required.</simpara>
<simpara>The main challenge is to do this in a way that prevents Bob and Chan from stealing the money that Alice wants delivered to Dina.</simpara>
</section>
<section id="_a_physical_example_of_routing">
<title>A Physical Example of "Routing"</title>
<simpara><indexterm>
  <primary>routing</primary><secondary>real-world physical example</secondary>
</indexterm>
<indexterm>
  <primary>real-world physical example</primary>
</indexterm>To understand how the Lightning Network protects the payment while being routed, we can compare it to an example of routing physical payments with gold coins in the real world.</simpara>
<simpara>Assume Alice wants to give 10 gold coins to Dina, but does not have direct access to Dina. However, Alice knows Bob, who knows Chan, who knows Dina, so she decides to ask Bob and Chan for help. This is shown in <xref linkend="alice_dina_routing_1"/>.</simpara>
<figure id="alice_dina_routing_1"><title>Alice wants to pay Dina 10 gold coins</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0804.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_0804.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>Alice can pay Bob to pay Chan to pay Dina, but how does she make sure that Bob or Chan don&#8217;t run off with the coins after receiving them?
In the physical world, contracts could be used for safely carrying out a series of payments.</simpara>
<simpara>Alice could negotiate a contract with Bob, which reads:</simpara>
<blockquote>
<simpara><emphasis>I, Alice, will give you, Bob, 10 gold coins if you pass them on to Chan.</emphasis></simpara>
</blockquote>
<simpara>While this contract is nice in the abstract, in the real world, Alice runs the risk that Bob might breach the contract and hope not to get caught.
Even if Bob is caught and prosecuted, Alice faces the risk that he might be bankrupt and be unable to return her 10 gold coins.
Assuming these issues are magically solved, it&#8217;s still unclear how to leverage such a contract to achieve our desired outcome: getting the coins delivered to Dina.</simpara>
<simpara>Let&#8217;s improve our contract to incorporate these considerations:</simpara>
<blockquote>
<simpara><emphasis>I, Alice, will reimburse you, Bob, with 10 gold coins if you can prove to me (for example, via a receipt) that you have delivered 10 gold coins to Chan.</emphasis></simpara>
</blockquote>
<simpara>You might ask yourself why should Bob sign such a contract.
He has to pay Chan but ultimately gets nothing out of the exchange, and he runs the risk that Alice might not reimburse him. Bob could offer Chan a similar contract to pay Dina, but similarly Chan has no reason to accept it either.</simpara>
<simpara>Even putting aside the risk, Bob and Chan must <emphasis>already</emphasis> have 10 gold coins to send; otherwise, they wouldn&#8217;t be able to participate in the contract.</simpara>
<simpara>Thus Bob and Chan face both risk and opportunity cost for agreeing to this contract, and they would need to be compensated to accept it.</simpara>
<simpara>Alice can then make this attractive to both Bob and Chan by offering them fees of one gold coin each, if they transmit her payment to Dina.</simpara>
<simpara>The contract would then read:</simpara>
<blockquote>
<simpara><emphasis>I, Alice, will reimburse you, Bob, with 12 gold coins if you can prove to me (for example, via a receipt) that you have delivered 11 gold coins to Chan.</emphasis></simpara>
</blockquote>
<simpara>Alice now promises Bob 12 gold coins. There are 10 to be delivered to Dina and 2 for the fees. She promises 12 to Bob if he can prove that he has forwarded 11 to Chan.
The difference of one gold coin is the fee that Bob will earn for helping out with this particular payment. In <xref linkend="alice_dina_routing_2"/> we see how this arrangement would get 10 gold coins to Dina via Bob and Chan.</simpara>
<figure id="alice_dina_routing_2"><title>Alice pays Bob, Bob pays Chan, Chan pays Dina</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0805.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_0805.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>Because there is still the issue of trust and the risk that either Alice or Bob won&#8217;t honor the contract, all parties decide to use an escrow service.
At the start of the exchange, Alice could "lock up" these 12 gold coins in escrow that will only be paid to Bob once he proves that he&#8217;s paid 11 gold coins to Chan.</simpara>
<simpara>This escrow service is an idealized one, which does not introduce other risks (e.g., counterparty risk). Later we will see how we can replace the escrow with a Bitcoin smart contract. Let&#8217;s assume for now that everyone trusts this escrow service.</simpara>
<simpara>In the Lightning Network, the receipt (proof of payment) could take the form of a secret that only Dina knows.
In practice, this secret would be a random number that is large enough to prevent others from guessing it (typically a <emphasis>very, very</emphasis> large number, encoded using 256 bits!).</simpara>
<simpara>Dina generates this secret value <literal>R</literal> from a random number generator.</simpara>
<simpara>The secret could then be committed to the contract by including the SHA-256 hash of the secret in the contract itself, as follows:</simpara>
<ul class="simplelist">
<li><em>H</em> = SHA-256(<em>R</em>)</li>
</ul>
<simpara><indexterm>
  <primary>payment hash</primary>
</indexterm><indexterm>
  <primary>payment secret (preimage)</primary>
</indexterm><indexterm>
  <primary>preimage (payment secret)</primary>
</indexterm>We call this hash of the payment&#8217;s secret the <emphasis>payment hash</emphasis>.
The secret that "unlocks" the payment is called the <emphasis>payment secret</emphasis>.</simpara>
<simpara>For now, we keep things simple and assume that Dina&#8217;s secret is simply the text line: <literal>Dinas secret</literal>. This secret message is called the <emphasis>payment secret</emphasis> or <emphasis>payment preimage</emphasis>.</simpara>
<simpara>To "commit" to this secret, Dina computes the SHA-256 hash, which when encoded in hexadecimal, can be displayed as follows:</simpara>
<screen>0575965b3b44be51e8057d551c4016d83cb1fba9ea8d6e986447ba33fe69f6b3</screen>
<simpara>To facilitate Alice&#8217;s payment, Dina will create the payment secret and the payment hash, and send the payment hash to Alice. In <xref linkend="alice_dina_routing_3"/> we see that Dina sends the payment hash to Alice via some external channel (dashed line), such as an email or text message.</simpara>
<figure id="alice_dina_routing_3"><title>Dina sends the hashed secret to Alice</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0806.png"/>
  </imageobject>
  <textobject><phrase>Dina sends the hashed secret to Alice</phrase></textobject>
</mediaobject>
</figure>
<simpara>Alice doesn&#8217;t know the secret, but she can rewrite her contract to use the hash of the secret as a proof of payment:</simpara>
<blockquote>
<simpara><emphasis>I, Alice, will reimburse you, Bob, with 12 gold coins if you can show me a valid message that hashes to:<literal>057596</literal>&#8230;.
You can acquire this message by setting up a similar contract with Chan who has to set up a similar contract with Dina.
To assure you that you will be reimbursed, I will provide the 12 gold coins to a trusted escrow before you set up your next contract.</emphasis></simpara>
</blockquote>
<simpara>This new contract now protects Alice from Bob not forwarding to Chan, protects Bob from not being reimbursed by Alice, and ensures that there will be proof that Dina was ultimately paid via the hash of Dina&#8217;s secret.</simpara>
<simpara>After Bob and Alice agree to the contract, and Bob receives the message from the escrow that Alice has deposited the 12 gold coins, Bob can now negotiate a similar contract with Chan.</simpara>
<simpara>Note that since Bob is taking a service fee of 1 coin, he will only forward 11 gold coins to Chan once Chan shows proof that he has paid Dina.
Similarly, Chan will also demand a fee and will expect to receive 11 gold coins once he has proved that he has paid Dina the promised 10 gold coins.</simpara>
<simpara>Bob&#8217;s contract with Chan will read:</simpara>
<blockquote>
<simpara><emphasis>I, Bob, will reimburse you, Chan, with 11 gold coins if you can show me a valid message that hashes to:<literal>057596</literal>&#8230;.
You can acquire this message by setting up a similar contract with Dina.
To assure you that you will be reimbursed, I will provide the 11 gold coins to a trusted escrow before you set up your next contract.</emphasis></simpara>
</blockquote>
<simpara>Once Chan gets the message from the escrow that Bob has deposited the 11 gold coins, Chan sets up a similar contract with Dina:</simpara>
<blockquote>
<simpara><emphasis>I, Chan, will reimburse you, Dina, with 10 gold coins if you can show me a valid message that hashes to:<literal>057596</literal>&#8230;.
To assure you that you will be reimbursed after revealing the secret, I will provide the 10 gold coins to a trusted escrow.</emphasis></simpara>
</blockquote>
<simpara>Everything is now in place.
Alice has a contract with Bob and has placed 12 gold coins in escrow.
Bob has a contract with Chan and has placed 11 gold coins in escrow.
Chan has a contract with Dina and has placed 10 gold coins in escrow.
It is now up to Dina to reveal the secret, which is the preimage to the hash she has established as proof of payment.</simpara>
<simpara>Dina now sends <literal>Dinas secret</literal> to Chan.</simpara>
<simpara>Chan checks that <literal>Dinas secret</literal> hashes to <literal>057596</literal>&#8230;. Chan now has proof of payment and so instructs the escrow service to release the 10 gold coins to Dina.</simpara>
<simpara>Chan now provides the secret to Bob. Bob checks it and instructs the escrow service to release the 11 gold coins to Chan.</simpara>
<simpara>Bob now provides the secret to Alice.
Alice checks it and instructs the escrow to release 12 gold coins to Bob.</simpara>
<simpara>All the contracts are now settled.
Alice has paid a total of 12 gold coins, 1 of which was received by Bob, 1 of which was received by Chan, and 10 of which were received by Dina.
With a chain of contracts like this in place, Bob and Chan could not run away with the money because they deposited it in escrow first.</simpara>
<simpara>However, one issue still remains.
If Dina refused to release her secret preimage, then Chan, Bob, and Alice would all have their coins stuck in escrow but wouldn&#8217;t be reimbursed.
And similarly if anyone else along the chain failed to pass on the secret, the same thing would happen.
So while no one can steal money from Alice, everyone would still have their money stuck in escrow permanently.</simpara>
<simpara>Luckily, this can be resolved by adding a deadline to the contract.</simpara>
<simpara>We could amend the contract so that if it is not fulfilled by a certain deadline, then the contract expires and the escrow service returns the money to the person who made the original deposit.
We call this deadline a <emphasis>timelock</emphasis>.</simpara>
<simpara>The deposit is locked with the escrow service for a certain amount of time and is eventually released even if no proof of payment was provided.</simpara>
<simpara>To factor this in, the contract between Alice and Bob is once again amended with a new clause:</simpara>
<blockquote>
<simpara><emphasis>Bob has 24 hours to show the secret after the contract was signed.
If Bob does not provide the secret by this time, Alice&#8217;s deposit will be refunded by the escrow service and the contract becomes invalid.</emphasis></simpara>
</blockquote>
<simpara>Bob, of course, now has to make sure he receives the proof of payment within 24 hours.
Even if he successfully pays Chan, if he receives the proof of payment later than 24 hours, he will not be reimbursed. To remove that risk, Bob must give Chan an even shorter deadline.</simpara>
<simpara>In turn, Bob will alter his contract with Chan as follows:</simpara>
<blockquote>
<simpara><emphasis>Chan has 22 hours to show the secret after the contract was signed.
If he does not provide the secret by this time, Bob&#8217;s deposit will be refunded by the escrow service and the contract becomes invalid.</emphasis></simpara>
</blockquote>
<simpara>As you might have guessed, Chan will also alter his contract with Dina:</simpara>
<blockquote>
<simpara><emphasis>Dina has 20 hours to show the secret after the contract was signed.
If she does not provide the secret by this time, Chan&#8217;s deposit will be refunded by the escrow service and the contract becomes invalid.</emphasis></simpara>
</blockquote>
<simpara>With such a chain of contracts we can ensure that, after 24 hours, the payment will successfully go from Alice to Bob to Chan to Dina, or it will fail and everyone will be refunded.
Either the contract fails or succeeds, there&#8217;s no middle ground.</simpara>
<simpara>In the context of the Lightning Network, we call this "all or nothing" property <emphasis>atomicity</emphasis>.</simpara>
<simpara>As long as the escrow is trustworthy and faithfully performs its duty, no party will have their coins stolen in the process.</simpara>
<simpara>The precondition to this <emphasis>route</emphasis> working at all is that all parties in the path have enough money to satisfy the required series of deposits.</simpara>
<simpara>While this seems like a minor detail, we will see later in this chapter that this requirement is actually one of the more difficult issues for LN nodes.
It becomes progressively more difficult as the size of the payment increases.
Furthermore, the parties cannot use their money while it is locked in escrow.</simpara>
<simpara>Thus, users forwarding payments face an opportunity cost for locking the money, which is ultimately reimbursed through routing fees, as we saw in the preceding example.</simpara>
<simpara>Now that we&#8217;ve seen a physical payment routing example, we will see how this can be implemented on the Bitcoin blockchain, without any need for third-party escrow. To do this we will be setting up the contracts between the participants using Bitcoin Script. We replace the third-party escrow with <emphasis>smart contracts</emphasis> that implement a fairness protocol. Let&#8217;s break that concept down and implement it!<indexterm>
</indexterm></simpara>
</section>
<section id="_fairness_protocol">
<title>Fairness Protocol</title>
<simpara><indexterm>
  <primary>fairness protocol</primary><secondary>routing and</secondary>
</indexterm>
<indexterm>
  <primary>routing and</primary>
</indexterm><indexterm>
  <primary>routing</primary><secondary>fairness protocol</secondary>
</indexterm>
<indexterm>
  <primary>fairness protocol</primary>
</indexterm>As we saw in the first chapter of this book, the innovation of Bitcoin is the ability to use cryptographic primitives to implement a fairness protocol that substitutes trust in third parties (intermediaries) with a trusted protocol.</simpara>
<simpara>In our gold coin example, we needed an escrow service to prevent any one of the parties from reneging on their obligations. The innovation of cryptographic fairness protocols allows us to replace the escrow service with a protocol.</simpara>
<simpara><indexterm>
  <primary>fairness protocol</primary><secondary>properties</secondary>
</indexterm>
<indexterm>
  <primary>properties</primary>
</indexterm>The properties of the fairness protocol we want to create are:</simpara>
<variablelist>
<varlistentry>
<term>
Trustless operation
</term>
<listitem>
<simpara>
The participants in a routed payment do not need to trust each other, or any intermediary or third party. Instead, they trust the protocol to protect them from cheating.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Atomicity
</term>
<listitem>
<simpara>
Either the payment is fully executed, or it fails and everyone is refunded. There is no possibility of an intermediary collecting a routed payment and not forwarding it to the next hop. Thus, the intermediaries can&#8217;t cheat or steal.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Multihop
</term>
<listitem>
<simpara>
The security of the system extends end to end for payments routed through multiple payment channels, just as it is for a payment between the two ends of a single payment channel.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>An optional, additional property is the ability to split payments into multiple parts while maintaining atomicity for the entire payment. These are called <emphasis>multipart payments</emphasis> (<emphasis>MPP</emphasis>) and are explored further in <xref linkend="mpp"/>.</simpara>
<section id="_implementing_atomic_trustless_multihop_payments">
<title>Implementing Atomic Trustless Multihop Payments</title>
<simpara><indexterm>
  <primary>fairness protocol</primary><secondary>implementing atomic trustless multihop payments</secondary>
</indexterm>
<indexterm>
  <primary>implementing atomic trustless multihop payments</primary>
</indexterm><indexterm>
  <primary>routing</primary><secondary>implementing atomic trustless multihop payments</secondary>
</indexterm>
<indexterm>
  <primary>implementing atomic trustless multihop payments</primary>
</indexterm>Bitcoin Script is flexible enough that there are dozens of ways to implement a fairness protocol that has the properties of atomicity, trustless operation, and multihop security. Choosing a specific implementation is dependent on certain trade-offs among privacy, efficiency, and complexity.</simpara>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>fairness protocol</secondary>
</indexterm>
<indexterm>
  <primary>fairness protocol</primary>
</indexterm>The fairness protocol for routing used in the Lightning Network today is called a hash time-locked contract (HTLC). HTLCs use a hash preimage as the secret that unlocks a payment, as we saw in the gold coin example in this chapter. The recipient of a payment generates a random secret number and calculates its hash. The hash becomes the condition of payment, and once the secret is revealed, all the participants can redeem their incoming payments. HTLCs offer atomicity, trustless operation, and multihop security.</simpara>
<simpara><indexterm>
  <primary>Point Time-Locked Contract (PTLC)</primary>
</indexterm><indexterm>
  <primary>PTLC (Point Time-Locked Contract)</primary>
</indexterm>Another proposed mechanism for implementing routing is a <emphasis>Point Time-Locked Contract</emphasis> (<emphasis>PTLC</emphasis>). PTLCs also achieve atomicity, trustless operation, and multihop security, but do so with increased efficiency and better privacy.  Efficient implementation of PTLCs depends on a new digital signature algorithm called <emphasis>Schnorr signatures</emphasis>, which is expected to be activated in Bitcoin in 2021.</simpara>
</section>
</section>
<section id="_revisiting_the_tipping_example">
<title>Revisiting the Tipping Example</title>
<simpara><indexterm>
  <primary>routing</primary><secondary>real-world physical example</secondary>
</indexterm>
<indexterm>
  <primary>real-world physical example</primary>
</indexterm>Let&#8217;s revisit our example from the first part of this chapter. Alice wants to tip Dina with a Lightning payment. Let&#8217;s say Alice wants to send Dina 50,000 satoshis as a tip.</simpara>
<simpara>For Alice to pay Dina, Alice will need Dina&#8217;s node to generate a Lightning invoice. We will discuss this in more detail in <xref linkend="invoices"/>. For now, let&#8217;s assume that Dina has a website that can produce a Lightning invoice for tips.</simpara>
<tip>
<simpara>Lightning payments can be sent without an invoice using a feature called <emphasis>keysend</emphasis>, which we will discuss in more detail in <xref linkend="keysend"/>. For now, we will explain the simpler payment flow using an invoice.</simpara>
</tip>
<simpara>Alice visits Dina&#8217;s site, enters the amount of 50,000 satoshis in a form, and in response, Dina&#8217;s Lightning node generates a payment request for 50,000 satoshis in the form of a Lightning invoice. This interaction takes place over the web and outside the Lightning Network, as shown in <xref linkend="alice_dina_invoice_1"/>.</simpara>
<figure id="alice_dina_invoice_1"><title>Alice requests an invoice from Dina&#8217;s website</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0807.png"/>
  </imageobject>
  <textobject><phrase>Alice requests an invoice from Dina's website</phrase></textobject>
</mediaobject>
</figure>
<simpara>As we saw in previous examples, we assume that Alice does not have a direct payment channel to Dina. Instead, Alice has a channel to Bob, Bob has a channel to Chan, and Chan has a channel to Dina. To pay Dina, Alice must find a path that connects her to Dina. We will discuss that step in more detail in <xref linkend="path_finding"/>. For now, let&#8217;s assume that Alice is able to gather information about available channels and sees that there is a path from her to Dina, via Bob and Chan.</simpara>
<note>
<simpara>Remember how Bob and Chan might expect a small compensation for routing the payment through their nodes? Alice wants to pay Dina 50,000 satoshis, but as you will see in the following sections she will send Bob 50,200 satoshis. The extra 200 satoshis will pay Bob and Chan 100 satoshis each, as a routing fee.</simpara>
</note>
<simpara>Now, Alice&#8217;s node can construct a Lightning payment. In the next few sections, we will see how Alice&#8217;s node constructs an HTLC to pay Dina and how that HTLC is forwarded along the path from Alice to Dina.</simpara>
<section id="_on_chain_versus_off_chain_settlement_of_htlcs">
<title>On-Chain Versus Off-Chain Settlement of HTLCs</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>on-chain versus off-chain settlement of</secondary>
</indexterm>
<indexterm>
  <primary>on-chain versus off-chain settlement of</primary>
</indexterm><indexterm>
  <primary>off-chain settlement, on-chain payment versus</primary>
</indexterm><indexterm>
  <primary>on-chain payment</primary><secondary>off-chain settlement versus</secondary>
</indexterm>
<indexterm>
  <primary>off-chain settlement versus</primary>
</indexterm><indexterm>
  <primary>routing</primary><secondary>on-chain versus off-chain settlement of HTLCs</secondary>
</indexterm>
<indexterm>
  <primary>on-chain versus off-chain settlement of HTLCs</primary>
</indexterm>The purpose of the Lightning Network is to enable <emphasis>off-chain</emphasis> transactions that are trusted just the same as on-chain transactions because no one can cheat. The reason no one can cheat is because at any time, any of the participants can take their off-chain transactions on-chain. Each off-chain transaction is ready to be submitted to the Bitcoin blockchain at any time. Thus, the Bitcoin blockchain acts as a dispute-resolution and final settlement mechanism if necessary.</simpara>
<simpara>The mere fact that any transaction can be taken on-chain at any time is precisely the reason that all those transactions can be kept off-chain. If you know you have recourse, you can continue to cooperate with the other participants and avoid the need for on-chain settlement and extra fees.</simpara>
<simpara>In all the examples that follow, we will assume that any of these transactions can be made on-chain at any time. The participants will choose to keep them off-chain, but there is no difference in the functionality of the system other than the higher fees and delay imposed by on-chain mining of the transactions. The example works the same if all the transactions are on-chain or off-chain.</simpara>
</section>
</section>
<section id="htlcs">
<title>Hash Time-Locked Contracts</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>mechanism of operation</secondary>
</indexterm>
<indexterm>
  <primary>mechanism of operation</primary>
</indexterm><indexterm>
  <primary>routing</primary><secondary>hash time-locked contracts mechanism of operation</secondary>
</indexterm>
<indexterm>
  <primary>hash time-locked contracts mechanism of operation</primary>
</indexterm>In this section we explain how HTLCs work.</simpara>
<simpara>The first part of an HTLC is the <emphasis>hash</emphasis>. This refers to the use of a cryptographic hash algorithm to commit to a randomly generated secret. Knowledge of the secret allows redemption of the payment. The cryptographic hash function guarantees that while it&#8217;s infeasible for anyone to guess the secret preimage, it&#8217;s easy for anyone to verify the hash, and there&#8217;s only one possible preimage that resolves the payment condition.</simpara>
<simpara>In <xref linkend="alice_dina_invoice_2"/> we see Alice getting a Lightning invoice from Dina. Inside that invoice <indexterm>
  <primary>payment hash</primary>
</indexterm>Dina has encoded a <emphasis>payment hash</emphasis>, which is the cryptographic hash of a secret that Dina&#8217;s node produced. <indexterm>
  <primary>payment secret (preimage)</primary>
</indexterm><indexterm>
  <primary>preimage (payment secret)</primary>
</indexterm>Dina&#8217;s secret is called the <emphasis>payment preimage</emphasis>. The payment hash acts as an identifier that can be used to route the payment to Dina. The payment preimage acts as a receipt and proof of payment once the payment is complete.</simpara>
<figure id="alice_dina_invoice_2"><title>Alice gets a payment hash from Dina</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0808.png"/>
  </imageobject>
  <textobject><phrase>Alice gets a payment hash from Dina</phrase></textobject>
</mediaobject>
</figure>
<simpara>In the Lightning Network, Dina&#8217;s payment preimage won&#8217;t be a phrase like <literal>Dinas secret</literal> but a random number generated by Dina&#8217;s node. Let&#8217;s call that random number <emphasis>R</emphasis>.</simpara>
<simpara>Dina&#8217;s node will calculate a cryptographic hash of <emphasis>R</emphasis>, such that:</simpara>
<ul class="simplelist">
<li><em>H</em> = SHA-256(<em>R</em>)</li>
</ul>
<simpara>In this equation, <emphasis>H</emphasis> is the hash, or <emphasis>payment hash</emphasis> and <emphasis>R</emphasis> is the secret or <emphasis>payment preimage</emphasis>.</simpara>
<simpara>The use of a cryptographic hash function is one element that guarantees <emphasis>trustless operation</emphasis>. The payment intermediaries do not need to trust each other because they know that no one can guess the secret or fake it.</simpara>
<section id="_htlcs_in_bitcoin_script">
<title>HTLCs in Bitcoin Script</title>
<simpara><indexterm>
  <primary>Bitcoin script</primary><secondary>HTLCs in</secondary>
</indexterm>
<indexterm>
  <primary>HTLCs in</primary>
</indexterm><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>Bitcoin Script and</secondary>
</indexterm>
<indexterm>
  <primary>Bitcoin Script and</primary>
</indexterm>In our gold coin example, Alice had a contract enforced by escrow like this:</simpara>
<blockquote>
<simpara><emphasis>Alice will reimburse Bob with 12 gold coins if you can show a valid message that hashes to:</emphasis> <literal>0575&#8230;f6b3</literal>. <emphasis>Bob has 24 hours to show the secret after the contract was signed. If Bob does not provide the secret by this time, Alice&#8217;s deposit will be refunded by the escrow service and the contract becomes invalid.</emphasis></simpara>
</blockquote>
<simpara role="pagebreak-before">Let&#8217;s see how we would implement this as an HTLC in Bitcoin Script. In <xref linkend="received_htlc"/> we see an HTLC Bitcoin Script as currently used in the Lightning Network. You can find this definition in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#offered-htlc-outputs">BOLT #3, Transactions</ulink>.</simpara>
<example id="received_htlc">
<title>HTLC implemented in Bitcoin Script (BOLT #3)</title>
<screen># To remote node with revocation key
OP_DUP OP_HASH160 &lt;RIPEMD160(SHA256(revocationpubkey))&gt; OP_EQUAL
OP_IF
    OP_CHECKSIG
OP_ELSE
    &lt;remote_htlcpubkey&gt; OP_SWAP OP_SIZE 32 OP_EQUAL
    OP_IF
        # To local node via HTLC-success transaction.
        OP_HASH160 &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY
        2 OP_SWAP &lt;local_htlcpubkey&gt; 2 OP_CHECKMULTISIG
    OP_ELSE
        # To remote node after timeout.
        OP_DROP &lt;cltv_expiry&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP
        OP_CHECKSIG
    OP_ENDIF
OP_ENDIF</screen>
</example>
<simpara>Wow, that looks complicated! Don&#8217;t worry though, we will take it one step at a time and simplify it.</simpara>
<simpara>The Bitcoin Script currently used in the Lightning Network is quite complex because it is optimized for on-chain space efficiency, which makes it very compact but difficult to read.</simpara>
<simpara>In the following sections, we will focus on the main elements of the script and present simplified scripts that are slightly different from what is actually used in Lightning.</simpara>
<simpara>The main part of the HTLC is in line 10 of <xref linkend="received_htlc"/>. Let&#8217;s build it up from scratch!</simpara>
</section>
<section id="_payment_preimage_and_hash_verification">
<title>Payment Preimage and Hash Verification</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>payment preimage and hash verification</secondary>
</indexterm>
<indexterm>
  <primary>payment preimage and hash verification</primary>
</indexterm><indexterm>
  <primary>hash verification</primary>
</indexterm><indexterm>
  <primary>payment secret (preimage)</primary>
</indexterm><indexterm>
  <primary>preimage (payment secret)</primary>
</indexterm>The core of an HTLC is the hash, where payment can be made if the recipient knows the payment preimage. Alice locks the payment to a specific payment hash, and Bob has to present a payment preimage to claim the funds. The Bitcoin system can verify that Bob&#8217;s payment preimage is correct by hashing it and comparing the result to the payment hash that Alice used to lock the funds.</simpara>
<simpara>This part of an HTLC can be implemented in Bitcoin Script as follows:</simpara>
<screen>OP_SHA256 &lt;H&gt; OP_EQUAL</screen>
<simpara>Alice can create a transaction output that pays, 50,200 satoshi with a locking script above, replacing <literal>&lt;H&gt;</literal> with the hash value <literal>0575&#8230;f6b3</literal> provided by Dina. Then, Alice can sign this transaction and offer it to Bob:</simpara>
<formalpara><title>Alice&#8217;s offers a 50,200 satoshi HTLC to Bob</title><para>
<screen>OP_SHA256 0575...f6b3 OP_EQUAL</screen>
</para></formalpara>
<simpara>Bob can&#8217;t spend this HTLC until he knows Dina&#8217;s secret, so spending the HTLC is conditional on Bob&#8217;s fulfillment of the payment all the way to Dina.</simpara>
<simpara>Once Bob has Dina&#8217;s secret, Bob can spend this output with an unlocking script containing the secret preimage value <emphasis>R</emphasis>.</simpara>
<simpara>The unlocking script combined with the locking script would produce:</simpara>
<screen>&lt;R&gt; OP_SHA256 &lt;H&gt; OP_EQUAL</screen>
<simpara>The Bitcoin Script engine would evaluate this script as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<literal>R</literal> is pushed to the stack.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>OP_SHA256</literal> operator takes the value <literal>R</literal> off the stack and hashes it, pushing the result <literal>H<subscript>R</subscript></literal> to the stack.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>H</literal> is pushed to the stack.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>OP_EQUAL</literal> operator compares <literal>H</literal> and <literal>H<subscript>R</subscript></literal>. If they are equal, the result is <literal>TRUE</literal>, the script is complete, and the payment is verified.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="_extending_htlcs_from_alice_to_dina">
<title>Extending HTLCs from Alice to Dina</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>extending across a network</secondary>
</indexterm>
<indexterm>
  <primary>extending across a network</primary>
</indexterm>Alice will now extend the HTLC across the network so that it reaches Dina.</simpara>
<simpara>In <xref linkend="alice_dina_htlc_1"/>, we see the HTLC propagated across the network from Alice to Dina. Alice has given Bob an HTLC for 50,200 satoshi. Bob can now create an HTLC for 50,100 satoshi and give it to Chan.</simpara>
<simpara>Bob knows that Chan can&#8217;t redeem Bob&#8217;s HTLC without broadcasting the secret, at which point Bob can also use the secret to redeem Alice&#8217;s HTLC. This is a really important point because it ensures end-to-end <emphasis>atomicity</emphasis> of the HTLC. To spend the HTLC, one needs to reveal the secret, which then makes it possible for others to spend their HTLC also. Either all the HTLCs are spendable, or none of the HTLCs are spendable: atomicity!</simpara>
<simpara>Because Alice&#8217;s HTLC is 100 satoshi more than the HTLC Bob gave to Chan, Bob will earn 100 satoshi as a routing fee if this payment completes.</simpara>
<simpara>Bob isn&#8217;t taking a risk and isn&#8217;t trusting Alice or Chan. Instead, Bob is trusting that a signed transaction together with the secret will be redeemable on the Bitcoin blockchain.</simpara>
<figure id="alice_dina_htlc_1"><title>Propagating the HTLC across the network</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0809.png"/>
  </imageobject>
  <textobject><phrase>Propagating the HTLC across the network</phrase></textobject>
</mediaobject>
</figure>
<simpara>Similarly, Chan can extend a 50,000 HTLC to Dina. He isn&#8217;t risking anything or trusting Bob or Dina. To redeem the HTLC, Dina would have to broadcast the secret, which Chan could use to redeem Bob&#8217;s HTLC. Chan would also earn 100 satoshis as a routing fee.</simpara>
</section>
<section id="_back_propagating_the_secret">
<title>Back-Propagating the Secret</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>back-propagating the secret</secondary>
</indexterm>
<indexterm>
  <primary>back-propagating the secret</primary>
</indexterm>Once Dina receives a 50,000 HTLC from Chan, she can now get paid. Dina could simply commit this HTLC on-chain and spend it by revealing the secret in the spending transaction. Or, instead, Dina can update the channel balance with Chan by giving him the secret. There&#8217;s no reason to incur a transaction fee and go on-chain. So, instead, Dina sends the secret to Chan, and they agree to update their channel balances to reflect a 50,000 satoshi Lightning payment to Dina. In <xref linkend="alice_dina_htlc_redeem_1"/> we see Dina giving the secret to Chan, thereby fulfilling the HTLC.</simpara>
<figure id="alice_dina_htlc_redeem_1"><title>Dina settles Chan&#8217;s HTLC off-chain</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0810.png"/>
  </imageobject>
  <textobject><phrase>Dina settles Chan's HTLC off-chain</phrase></textobject>
</mediaobject>
</figure>
<simpara>Notice that Dina&#8217;s channel balance goes from 50,000 satoshi to 100,000 satoshi. Chan&#8217;s channel balance is reduced from 200,000 satoshi to 150,000 satoshi. The channel capacity hasn&#8217;t changed, but 50,000 has moved from Chan&#8217;s side of the channel to Dina&#8217;s side of the channel.</simpara>
<simpara>Chan now has the secret and has paid Dina 50,000 satoshi. He can do this without any risk, because the secret allows Chan to redeem the 50,100 HTLC from Bob. Chan has the option to commit that HTLC on-chain and spend it by revealing the secret on the Bitcoin blockchain. But, like Dina, he&#8217;d rather avoid transaction fees. So instead, he sends the secret to Bob so they can update their channel balances to reflect a 50,100 satoshi Lightning payment from Bob to Chan. In <xref linkend="alice_dina_htlc_redeem_2"/> we see Chan sending the secret to Bob and receiving a payment in return.</simpara>
<figure id="alice_dina_htlc_redeem_2"><title>Chan settles Bob&#8217;s HTLC off-chain</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0811.png"/>
  </imageobject>
  <textobject><phrase>Chan settles Bob's HTLC off-chain</phrase></textobject>
</mediaobject>
</figure>
<simpara>Chan has paid Dina 50,000 satoshi, and received 50,100 satoshi from Bob. So Chan has 100 satoshi more in his channel balances, which he earned as a routing fee.</simpara>
<simpara>Bob now has the secret too. He can use it to spend Alice&#8217;s HTLC on-chain. Or, he can avoid transaction fees by settling the HTLC in the channel with Alice. In <xref linkend="alice_dina_htlc_redeem_3"/> we see that Bob sends the secret to Alice and they update the channel balance to reflect a 50,200 satoshi Lightning payment from Alice to Bob.</simpara>
<figure id="alice_dina_htlc_redeem_3"><title>Bob settles Alice&#8217;s HTLC off-chain</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0812.png"/>
  </imageobject>
  <textobject><phrase>Bob settles Alice's HTLC off-chain</phrase></textobject>
</mediaobject>
</figure>
<simpara>Bob has received 50,200 satoshi from Alice and paid 50,100 satoshi to Chan, so he has an extra 100 satoshi in his channel balances from routing fees.</simpara>
<simpara>Alice receives the secret and has settled the 50,200  satoshi HTLC. The secret can be used as a <emphasis>receipt</emphasis> to prove that Dina got paid for that specific payment hash.</simpara>
<simpara>The final channel balances reflect Alice&#8217;s payment to Dina and the routing fees paid at each hop, as shown in <xref linkend="alice_dina_htlc_redeem_4"/>.<indexterm>
</indexterm></simpara>
<figure id="alice_dina_htlc_redeem_4"><title>Channel balances after the payment</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0813.png"/>
  </imageobject>
  <textobject><phrase>Channel balances after the payment</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="preventing_theft">
<title>Signature Binding: Preventing Theft of HTLCs</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>signature binding to prevent theft of</secondary>
</indexterm>
<indexterm>
  <primary>signature binding to prevent theft of</primary>
</indexterm><indexterm>
  <primary>signature binding</primary>
</indexterm>There&#8217;s a catch. Did you notice it?</simpara>
<simpara>If Alice, Bob, and Chan create the HTLCs as shown in <xref linkend="alice_dina_htlc_redeem_4"/>, they face a small but not insignificant risk of loss. Any of those HTLCs can be redeemed (spent) by anyone who knows the secret. At first only Dina knows the secret. Dina is supposed to only spend the HTLC from Chan. But Dina could spend all three HTLCs at the same time, or even in a single spending transaction! After all, Dina knows the secret before anyone else. Similarly, once Chan knows the secret, he is only supposed to spend the HTLC offered by Bob. But what if Chan also spends Alice&#8217;s offered HTLC?</simpara>
<simpara>This is not <emphasis>trustless</emphasis>! It fails the most important security feature. We need to fix this.</simpara>
<simpara>The HTLC script must have an additional condition that binds each HTLC to a specific recipient. We do this by requiring a digital signature that matches the public key of each recipient, thereby preventing anyone else from spending that HTLC. Since only the designated recipient has the ability to produce a digital signature matching that public key, only the designated recipient can spend that HTLC.</simpara>
<simpara>Let&#8217;s look at the scripts again with this modification in mind. Alice&#8217;s HTLC for Bob is modified to include Bob&#8217;s public key and the <literal>OP_CHECKSIG</literal> operator.</simpara>
<simpara>Here&#8217;s the modified HTLC script:</simpara>
<screen>OP_SHA256 &lt;H&gt; OP_EQUALVERIFY &lt;Bob's Pub&gt; OP_CHECKSIG</screen>
<tip>
<simpara>Notice that we also changed <literal>OP_EQUAL</literal> to <literal>OP_EQUALVERIFY</literal>. When an operator has the suffix <literal>VERIFY</literal>, it does not return <literal>TRUE</literal> or <literal>FALSE</literal> on the stack. Instead, it <emphasis>halts</emphasis> execution and fails the script if the result is false and continues without any stack output if it is true.</simpara>
</tip>
<simpara>To redeem this HTLC, Bob has to present an unlocking script that includes a signature from Bob&#8217;s private key as well as the secret payment preimage, like this:</simpara>
<screen>&lt;Bob's Signature&gt; &lt;R&gt;</screen>
<simpara>The unlocking and locking scripts are combined and evaluated by the scripting engine, as follows:</simpara>
<screen>&lt;Bob's Sig&gt; &lt;R&gt; OP_SHA256 &lt;H&gt; OP_EQUALVERIFY &lt;Bob's Pub&gt; OP_CHECKSIG</screen>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<literal>&lt;Bob&#8217;s Sig&gt;</literal> is pushed to the stack.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>R</literal> is pushed to the stack.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>OP_SHA256</literal> pops and hashes <literal>R</literal> from the top of the stack and pushes <literal>H<subscript>R</subscript></literal> to the stack.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>H</literal> is pushed to the stack.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>OP_EQUALVERIFY</literal> pops <literal>H</literal> and <literal>H<subscript>R</subscript></literal> and compares them. If they are not the same, execution halts. Otherwise, we continue without output to the stack.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&lt;Bob&#8217;s Pub&gt;</literal> key is pushed to the stack.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>OP_CHECKSIG</literal> pops <literal>&lt;Bob&#8217;s Sig&gt;</literal> and <literal>&lt;Bob&#8217;s Pub&gt;</literal> and verifies the signature. The result (<literal>TRUE/FALSE</literal>) is pushed to the stack.
</simpara>
</listitem>
</orderedlist>
<simpara>As you can see, this is slightly more complicated, but now we have fixed the HTLC and made sure only the intended recipient can spend it.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
<section id="_hash_optimization">
<title>Hash Optimization</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>hash optimization</secondary>
</indexterm>
<indexterm>
  <primary>hash optimization</primary>
</indexterm>Let&#8217;s look at the first part of the HTLC script so far:</simpara>
<screen>OP_SHA256 &lt;H&gt; OP_EQUALVERIFY</screen>
<simpara>If we look at this in the preceding symbolic representation, it looks like the <literal>OP_</literal> operators take up the most space. But that&#8217;s not the case. Bitcoin Script is encoded in binary, with each operator representing one byte. Meanwhile, the <literal>&lt;H&gt;</literal> value we use as a placeholder for the payment hash is a 32-byte (256-bit) value. You can find a listing of all the Bitcoin Script operators and their binary and hex encoding in <ulink url="https://en.bitcoin.it/wiki/Script">Bitcoin Wiki: Script</ulink>, or in <ulink url="https://github.com/bitcoinbook/bitcoinbook/blob/develop/appdx-scriptops.asciidoc">Appendix D, "Transaction Script Language Operators, Constants, and Symbols," in <emphasis>Mastering Bitcoin</emphasis></ulink>.</simpara>
<simpara>Represented in hexadecimal, our HTLC script would look like this:</simpara>
<screen>a8 0575965b3b44be51e8057d551c4016d83cb1fba9ea8d6e986447ba33fe69f6b3 88</screen>
<simpara>In hexadecimal encoding, <literal>OP_SHA256</literal> is <literal>a8</literal> and <literal>OP_EQUALVERIFY</literal> is <literal>88</literal>. The total length of this script is 34 bytes, of which 32 bytes are the hash.</simpara>
<simpara>As we&#8217;ve mentioned previously, any participant in the Lightning Network should be able to take an off-chain transaction they hold and put it on-chain if they need to enforce their claim to funds. To take a transaction on-chain, they&#8217;d have to pay transaction fees to the miners, and these fees are proportional to the size, in bytes, of the transaction.</simpara>
<simpara>Therefore, we want to find ways to minimize the on-chain "weight" of transactions by optimizing the script as much as possible. One way to do that is to add another hash function on top of the SHA-256 algorithm, one that produces smaller hashes. The Bitcoin Script language provides the <literal>OP_HASH160</literal> operator that "double hashes" a preimage: first the preimage is hashed with SHA-256, and then the resulting hash is hashed again with the RIPEMD160 hash algorithm. The hash resulting from RIPEMD160 is 160 bits or 20 bytes&#8212;much more compact. In Bitcoin Script this is a very common optimization that is used in many of the common address formats.</simpara>
<simpara>So, let&#8217;s use that optimization instead. Our SHA-256 hash is <literal>057596&#8230;69f6b3</literal>. Putting that through another round of hashing with RIPEMD160 gives us the result:</simpara>
<screen>R = "Dinas secret"
H256 = SHA256(R)
H256 = 0575965b3b44be51e8057d551c4016d83cb1fba9ea8d6e986447ba33fe69f6b3
H160 = RIPEMD160(H256)
H160 = 9e017f6767971ed7cea17f98528d5f5c0ccb2c71</screen>
<simpara>Alice can calculate the RIPEMD160 hash of the payment hash that Dina provides and use the shorter hash in her HTLC, as can Bob and Chan!</simpara>
<simpara role="pagebreak-before">The "optimized" HTLC script would look like this:</simpara>
<screen>OP_HASH160 &lt;H160&gt; OP_EQUALVERIFY</screen>
<simpara>Encoded in hex, this is:</simpara>
<screen>a9 9e017f6767971ed7cea17f98528d5f5c0ccb2c71 88</screen>
<simpara>Where <literal>OP_HASH160</literal> is <literal>a9</literal> and <literal>OP_EQUALVERIFY</literal> is <literal>88</literal>. This script is only 22 bytes long! We&#8217;ve saved 12 bytes from every transaction that redeems an HTLC on-chain.</simpara>
<simpara>With that optimization, you now see how we arrive at the HTLC script shown in line 10 of <xref linkend="received_htlc"/>:</simpara>
<screen>...
    # To local node via HTLC-success transaction.
    OP_HASH160 &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY...</screen>
</section>
<section id="_htlc_cooperative_and_timeout_failure">
<title>HTLC Cooperative and Timeout Failure</title>
<simpara><indexterm>
  <primary>cooperative failure</primary>
</indexterm><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>cooperative/timeout failure</secondary>
</indexterm>
<indexterm>
  <primary>cooperative/timeout failure</primary>
</indexterm><indexterm>
  <primary>timeout failure</primary>
</indexterm>So far we looked at the "hash" part of HTLC and how it would work if everyone cooperated and was online at the time of payment.</simpara>
<simpara>What happens if someone goes offline or fails to cooperate? What happens if the payment cannot succeed?</simpara>
<simpara>We need to ensure a way to "fail gracefully," because occasional routing failures are inevitable. There are two ways to fail: cooperatively and with a time-locked refund.</simpara>
<simpara>Cooperative failure is relatively simple: the HTLC is unwound by every participant in the route, removing the HTLC output from their commitment transactions without changing the balance. We&#8217;ll look at how that works in detail in <xref linkend="channel_operation"/>.</simpara>
<simpara>Let&#8217;s look at how we can reverse an HTLC without the cooperation of one or more participants. We need to make sure that if one of the participants does not cooperate, the funds are not simply locked in the HTLC <emphasis>forever</emphasis>. This would give someone the opportunity to ransom the funds of another participant: "I&#8217;ll leave your funds tied up forever if you don&#8217;t pay me ransom."</simpara>
<simpara>To prevent this, every HTLC script includes a refund clause that is connected to a timelock. Remember our original escrow contract? "Bob has 24 hours to show the secret after the contract is signed. If Bob does not provide the secret by this time, Alice&#8217;s deposit will be refunded."</simpara>
<simpara>The time-locked refund is an important part of the script that ensures <emphasis>atomicity</emphasis>, so that the entire end-to-end payment either succeeds or fails gracefully. There is no "half paid" state to worry about. If there is a failure, every participant can either unwind the HTLC cooperatively with their channel partner or put the time-locked refund transaction on-chain unilaterally to get their money back.</simpara>
<simpara>To implement this refund in Bitcoin Script, we use a special operator <code>O&#x2060;P&#x2060;_&#x2060;C&#x2060;H&#x2060;E&#x2060;C&#x2060;K&#x2060;L&#x2060;O&#x2060;C&#x2060;K&#x2060;T&#x2060;I&#x2060;M&#x2060;E&#x200b;V&#x2060;E&#x2060;R&#x2060;I&#x2060;F&#x2060;Y</code> also known <literal>OP_CLTV</literal> for short. Here&#8217;s the script, as seen previously in line 13 of <xref linkend="received_htlc"/>:</simpara>
<screen>...
        OP_DROP &lt;cltv_expiry&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP
        OP_CHECKSIG
...</screen>
<simpara>The <literal>OP_CLTV</literal> operator takes an expiry time defined as the block height after which this transaction is valid. If the transaction timelock is not set the same as <literal>&lt;cltv_expiry&gt;</literal>, the evaluation of the script fails and the transaction is invalid. Otherwise, the script continues without any output to the stack. Remember, the <literal>VERIFY</literal> suffix means this operator does not output <literal>TRUE</literal> or <literal>FALSE</literal> but instead either halts/fails or continues without stack output.</simpara>
<simpara>Essentially, the <literal>OP_CLTV</literal> acts as a "gatekeeper" preventing the script from proceeding any further if the <literal>&lt;cltv_expiry&gt;</literal> block height has not been reached on the Bitcoin blockchain.</simpara>
<simpara>The <literal>OP_DROP</literal> operator simply drops the topmost item on the script stack. This is necessary in the beginning because there is a "leftover" item from the previous script lines. It is necessary <emphasis>after</emphasis> <literal>OP_CLTV</literal> to remove the <literal>&lt;cltv_expiry&gt;</literal> item from the top of the stack because it is no longer necessary.</simpara>
<simpara>Finally, once the stack has been cleaned up, there should be a public key and signature left behind that <literal>OP_CHECKSIG</literal> can verify. As we saw in <xref linkend="preventing_theft"/>, this is necessary to ensure that only the rightful owner of the funds can claim them, by binding this output to their public key and requiring a signature.</simpara>
</section>
<section id="_decrementing_timelocks">
<title>Decrementing Timelocks</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>decrementing timelocks</secondary>
</indexterm>
<indexterm>
  <primary>decrementing timelocks</primary>
</indexterm>As the HTLCs are extended from Alice to Dina, the time-locked refund clause in each HTLC has a <emphasis>different</emphasis> <literal>cltv_expiry</literal> value. We will see this in more detail in <xref linkend="onion_routing"/>. But suffice it to say that to ensure an orderly unwinding of a payment that fails, each hop needs to wait a bit less for their refund. The difference between timelocks for each hop is called the <literal>cltv_expiry_delta</literal>, and is set by each node and advertised to the network, as we will see in <xref linkend="gossip"/>.</simpara>
<simpara>For example, Alice sets the refund timelock on the first HTLC to a block height of current + 500 blocks ("current" being the current block height). Bob would then set the timelock <literal>cltv_expiry</literal> on the HTLC to Chan to current + 450 blocks. Chan would set the timelock to current + 400 blocks from the current block height. This way, Chan can get a refund on the HTLC he offered to Dina <emphasis>before</emphasis> Bob gets a refund on the HTLC he offered to Chan. Bob can get a refund of the HTLC he offered to Chan before Alice can get a refund for the HTLC she offered to Bob. The decrementing timelock prevents race conditions and ensures the HTLC chain is unwound backward, from the destination toward the origin.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_conclusion_7">
<title>Conclusion</title>
<simpara>In this chapter we saw how Alice can pay Dina even if she doesn&#8217;t have a direct payment channel. Alice can find a path that connects her to Dina and route a payment across several payment channels so that it reaches Dina.</simpara>
<simpara>To ensure that the payment is atomic and trustless across multiple hops, Alice must implement a fairness protocol in cooperation with all the intermediary nodes in the path. The fairness protocol is currently implemented as an HTLC, which commits funds to a payment hash derived from a secret payment preimage.</simpara>
<simpara>Each of the participants in the payment route can extend an HTLC to the next participant, without worrying about theft or stuck funds. The HTLC can be redeemed by revealing the secret payment preimage. Once an HTLC reaches Dina, she reveals the preimage, which flows backward, resolving all the HTLCs offered.</simpara>
<simpara>Finally, we saw how a time-locked refund clause completes the HTLC, ensuring that every participant can get a refund if the payment fails but for whatever reason one of the participants doesn&#8217;t cooperate in unwinding the HTLCs. By always having the option to go on-chain for a refund, the HTLC achieves the fairness goal of atomicity and trustless operation.<indexterm>
</indexterm></simpara>
</section>
</chapter>
<chapter id="channel_operation">
<title>Channel Operation and <span class="keep-together">Payment Forwarding</span></title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>operation</secondary>
</indexterm>
<indexterm>
  <primary>operation</primary>
</indexterm>In this chapter we will bring together payment channels and hash time-locked contracts (HTLCs). In <xref linkend="payment_channels"/>, we explained the way Alice and Bob construct a payment channel between their two nodes. We also looked at the commitment and penalty mechanisms that secure the payment channel. In <xref linkend="routing"/>, we looked at HTLCs and how these can be used to route a payment across a path made of multiple payment channels. In this chapter we bring the two concepts together by looking at how HTLCs are managed on each payment channel, how the HTLCs are committed to the channel state, and how they are settled to update the channel balances.</simpara>
<simpara>Specifically, we will be discussing "Adding, settling, failing HTLCs" and the "Channel state machine" that form the overlap between the peer-to-peer layer and the routing layer, as highlighted by an outline in <xref linkend="LN_protocol_channelops_highlight"/>.</simpara>
<figure id="LN_protocol_channelops_highlight"><title>Channel operation and payment forwarding in the Lightning protocol suite</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0901.png"/>
  </imageobject>
  <textobject><phrase>Channel operation and payment forwarding in the Lightning protocol suite</phrase></textobject>
</mediaobject>
</figure>
<section id="_local_single_channel_versus_routed_multiple_channels">
<title>Local (Single Channel) Versus Routed (Multiple Channels)</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>local channel versus routed channels</secondary>
</indexterm>
<indexterm>
  <primary>local channel versus routed channels</primary>
</indexterm>Even though it is possible to send payments across a payment channel simply by updating the channel balances and creating new commitment transactions, the Lightning protocol uses HTLCs even for "local" payments across a payment channel. The reason for this is to maintain the same protocol design regardless of whether a payment is only one hop (across a single payment channel) or several hops (routed across multiple payment channels).</simpara>
<simpara>By maintaining the same abstraction for both local and remote, we not only simplify the protocol design but also improve privacy. For the recipient of a payment there is no discernible difference between a payment made directly by their channel partner and a payment forwarded by their channel partner on behalf of someone else.</simpara>
</section>
<section id="_forwarding_payments_and_updating_commitments_span_class_keep_together_with_htlcs_span">
<title>Forwarding Payments and Updating Commitments <span class="keep-together">with HTLCs</span></title>
<simpara><indexterm>
  <primary>commitment transactions</primary><secondary>updating commitments with HTLCs</secondary>
</indexterm>
<indexterm>
  <primary>updating commitments with HTLCs</primary>
</indexterm><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>updating commitments with</secondary>
</indexterm>
<indexterm>
  <primary>updating commitments with</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>updating commitments with HTLCs</secondary>
</indexterm>
<indexterm>
  <primary>updating commitments with HTLCs</primary>
</indexterm>We will revisit our example from <xref linkend="routing"/> to demonstrate how the HTLCs from Alice to Dina get committed to each payment channel. As you recall in our example, Alice is paying Dina 50,000 satoshis by routing an HTLC via Bob and Chan. The network is shown in <xref linkend="alice_dina_htlc_2"/>.</simpara>
<figure id="alice_dina_htlc_2"><title>Alice pays Dina with an HTLC routed via Bob and Chan</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0809.png"/>
  </imageobject>
  <textobject><phrase>Alice pays Dina with an HTLC routed via Bob and Chan</phrase></textobject>
</mediaobject>
</figure>
<simpara>We will focus on the payment channel between Alice and Bob and review the messages and transactions that they use to process this HTLC.</simpara>
<section id="_htlc_and_commitment_message_flow">
<title>HTLC and Commitment Message Flow</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>commitment message flow</secondary>
</indexterm>
<indexterm>
  <primary>commitment message flow</primary>
</indexterm>The message flow between Alice and Bob (and also between any pair of channel partners) is shown in <xref linkend="HTLC_commitment_message_flow"/>.</simpara>
<figure id="HTLC_commitment_message_flow"><title>The message flow for HTLC commitment between channel partners</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0903.png"/>
  </imageobject>
  <textobject><phrase>The message flow for HTLC commitment between channel partners</phrase></textobject>
</mediaobject>
</figure>
<simpara role="pagebreak-before">We&#8217;ve already seen the <literal>commitment_signed</literal> and <literal>revoke_and_ack</literal> in <xref linkend="payment_channels"/>. Now we will see how HTLCs fit into the commitment scheme. The two new messages are <literal>update_add_htlc</literal>, which Alice uses to ask Bob to add an HTLC, and <literal>update_fulfill_htlc</literal>, which Bob uses to redeem the HTLC once he has received the payment secret (Dina&#8217;s secret).<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_forwarding_payments_with_htlcs">
<title>Forwarding Payments with HTLCs</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>forwarding payments with</secondary>
</indexterm>
<indexterm>
  <primary>forwarding payments with</primary>
</indexterm><indexterm>
  <primary>payment forwarding</primary><secondary>with HTLCs</secondary>
</indexterm>
<indexterm>
  <primary>with HTLCs</primary>
</indexterm>Alice and Bob start with a payment channel that has a 70,000 satoshi balance on each side.</simpara>
<simpara>As we saw in <xref linkend="payment_channels"/>, this means that Alice and Bob have negotiated and each hold commitment transactions. These commitment transactions are asymmetric, delayed, and revocable, and look like the example in <xref linkend="alice_bob_commitment_txs_1"/>.</simpara>
<figure id="alice_bob_commitment_txs_1"><title>Alice and Bob&#8217;s initial commitment transactions</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0904.png"/>
  </imageobject>
  <textobject><phrase>Alice and Bob's initial commitment transactions</phrase></textobject>
</mediaobject>
</figure>
<section id="_adding_an_htlc">
<title>Adding an HTLC</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>adding an HTLC</secondary>
</indexterm>
<indexterm>
  <primary>adding an HTLC</primary>
</indexterm>Alice wants Bob to accept an HTLC worth 50,200 satoshis to forward to Dina. To do so, Alice must send the details of this HTLC, including the payment hash and amount, to Bob. Bob will also need to know where to forward it, which is something we discuss in detail in <xref linkend="onion_routing"/>.</simpara>
<simpara>To add the HTLC, Alice starts the flow we saw in <xref linkend="HTLC_commitment_message_flow"/> by sending the <literal>update_add_htlc</literal> message to Bob.</simpara>
</section>
<section id="update_add_htlc">
<title>The update_add_HTLC Message</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>update_add_HTLC message</secondary>
</indexterm>
<indexterm>
  <primary>update_add_HTLC message</primary>
</indexterm><indexterm>
  <primary>update_add_HTLC message</primary>
</indexterm>Alice sends the <literal>update_add_HTLC</literal> Lightning message to Bob. This message is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#adding-an-htlc-update_add_htlc">BOLT #2: Peer Protocol, <literal>update_add_HTLC</literal></ulink>, and is shown in Example 9-1.</simpara>
<example id="update_add_HTLC_message_fields">
<title>The <literal>update_add_HTLC</literal> message</title>
<screen>[channel_id:channel_id]
[u64:id]
[u64:amount_msat]
[sha256:payment_hash]
[u32:cltv_expiry]
[1366*byte:onion_routing_packet]</screen>
</example>
<variablelist>
<varlistentry>
<term>
<literal>channel_id</literal>
</term>
<listitem>
<simpara>
This is the channel that Alice has with Bob where she wants to add the HTLC. Remember that Alice and Bob may have multiple channels with each other.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>id</literal>
</term>
<listitem>
<simpara>
This is an HTLC counter and starts at <literal>0</literal> for the first HTLC offered to Bob by Alice and is incremented for each subsequent offered HTLC.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>amount_msat</literal>
</term>
<listitem>
<simpara>
This is the amount (value) of the HTLC in millisatoshis. In our example this is 50,200,000 millisatoshis (i.e., 50,200 satoshis).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>payment_hash</literal>
</term>
<listitem>
<simpara>
This is the payment hash calculated from Dina&#8217;s invoice. It is <emphasis>H</emphasis> = RIPEMD160(SHA-256(<emphasis>R</emphasis>)), where <emphasis>R</emphasis> is Dina&#8217;s secret that is known only by Dina and will be revealed if Dina is paid.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>cltv_expiry</literal>
</term>
<listitem>
<simpara>
This is the expiry time for this HTLC, which will be encoded as a time-locked refund in case the HTLC fails to reach Dina in this time.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>onion_routing_packet</literal>
</term>
<listitem>
<simpara>
This is an onion-encrypted route that tells Bob where to forward this HTLC next (to Chan). Onion routing is covered in detail in <xref linkend="onion_routing"/>.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>As a reminder, accounting within the Lightning Network is in units of millisatoshis (thousandths of a satoshi), whereas Bitcoin accounting is in satoshis. Any amounts in HTLCs are millisatoshis, which are then rounded to the nearest satoshi in the Bitcoin commitment transactions.</simpara>
</tip>
</section>
<section id="_htlc_in_commitment_transactions">
<title>HTLC in Commitment Transactions</title>
<simpara><indexterm>
  <primary>commitment transactions</primary><secondary>HTLC in</secondary>
</indexterm>
<indexterm>
  <primary>HTLC in</primary>
</indexterm><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>commitment transactions and</secondary>
</indexterm>
<indexterm>
  <primary>commitment transactions and</primary>
</indexterm>The received information is enough for Bob to create a new commitment transaction. The new commitment transaction has the same two outputs <literal>to_self</literal> and <literal>to_remote</literal> for Alice and Bob&#8217;s balance, and a <emphasis>new</emphasis> output representing the HTLC offered by Alice.</simpara>
<simpara>We&#8217;ve already seen the basic structure of an HTLC in <xref linkend="routing"/>. The complete script of an offered HTLC is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#offered-htlc-outputs">BOLT #3: Transactions, Offered HTLC Output</ulink> and is shown in <xref linkend="offered_htlc_output_script"/>.</simpara>
<example id="offered_htlc_output_script">
<title>Offered HTLC output script</title>
<programlisting language="text" linenumbering="linenums"># Revocation <co id="CO1-1"/>
OP_DUP OP_HASH160 &lt;RIPEMD160(SHA256(revocationpubkey))&gt; OP_EQUAL
OP_IF
    OP_CHECKSIG
OP_ELSE
    &lt;remote_HTLCpubkey&gt; OP_SWAP OP_SIZE 32 OP_EQUAL
    OP_IF
        # Redemption <co id="CO1-2"/>
        OP_HASH160 &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY
        2 OP_SWAP &lt;local_HTLCpubkey&gt; 2 OP_CHECKMULTISIG
    OP_ELSE
        # Refund <co id="CO1-3"/>
        OP_DROP &lt;cltv_expiry&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP
        OP_CHECKSIG
    OP_ENDIF
OP_ENDIF</programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>
The first clause of the <literal>OP_IF</literal> conditional is redeemable by Alice with a revocation key. If this commitment is later revoked, Alice will have a revocation key to claim this output in a penalty transaction, taking the whole channel balance.
</para>
</callout>
<callout arearefs="CO1-2">
<para>
The second clause is redeemable by the preimage (payment secret, or in our example, Dina&#8217;s secret) if it is revealed. This allows Bob to claim this output if he has the secret from Dina, meaning he has successfully delivered the payment to Dina.
</para>
</callout>
<callout arearefs="CO1-3">
<para>
The third and final clause is a refund of the HTLC to Alice if the HTLC expires without reaching Dina. It is time-locked with the expiration <literal>cltv_expiry</literal>. This ensures that Alice&#8217;s balance is not "stuck" in an HTLC that can&#8217;t be routed to Dina.
</para>
</callout>
</calloutlist>
</example>
<simpara>There are three ways to claim this output. Try to read the script and see if you can figure it out (remember, it is a stack-based language, so things appear "backward").</simpara>
</section>
<section id="_new_commitment_with_htlc_output">
<title>New Commitment with HTLC Output</title>
<simpara><indexterm>
  <primary>commitment transactions</primary><secondary>new commitment with HTLC output</secondary>
</indexterm>
<indexterm>
  <primary>new commitment with HTLC output</primary>
</indexterm><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>new commitment with HTLC output</secondary>
</indexterm>
<indexterm>
  <primary>new commitment with HTLC output</primary>
</indexterm>Bob now has the necessary information to add this HTLC script as an additional output and create a new commitment transaction. Bob&#8217;s new commitment will have 50,200 satoshis in the HTLC output. That amount will come from Alice&#8217;s channel balance, so Alice&#8217;s new balance will be 19,800 satoshis (70,000 – 50,200 = 19,800). Bob constructs this commitment as a tentative "Commitment #3," shown in <xref linkend="add_commitment_3b"/>.</simpara>
<figure id="add_commitment_3b"><title>Bob&#8217;s new commitment with an HTLC output</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0905.png"/>
  </imageobject>
  <textobject><phrase>Bob's new commitment with an HTLC output</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_alice_commits" role="pagebreak-before less_space">
<title>Alice Commits</title>
<simpara>Shortly after sending the <literal>update_add_htlc</literal> message, she will commit to the new state of the channel, so that the HTLC can be safely added by Bob. Bob has the HTLC information and has constructed a new commitment but does not yet have this new commitment signed by Alice.</simpara>
<simpara>Alice sends <literal>commitment_signed</literal> to Bob, with the signature for the new commitment and for the HTLC within. We saw the <literal>commitment_signed</literal> message in <xref linkend="payment_channels"/>, but now we can understand the rest of the fields. As a reminder, it is shown in <xref linkend="ops_commitment_signed_message"/>.</simpara>
<example id="ops_commitment_signed_message">
<title>The <literal>commitment_signed</literal> message</title>
<screen>[channel_id:channel_id]
[signature:signature]
[u16:num_htlcs]
[num_htlcs*signature:htlc_signature]</screen>
</example>
<simpara>The fields <literal>num_htlcs</literal> and <literal>htlc_signature</literal> now make more sense:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>num_htlcs</literal>
</term>
<listitem>
<simpara>
This is the number of HTLCs that are outstanding in the commitment transaction. In our example, just one HTLC, the one Alice offered.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>htlc_signature</literal>
</term>
<listitem>
<simpara>
This is an array of signatures (<literal>num_htlcs</literal> in length), containing signatures for the HTLC outputs.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Alice can send these signatures without hesitation: she can always get a refund if the HTLC expires without being routed to Dina.</simpara>
<simpara>Now, Bob has a new signed commitment transaction, as shown in <xref linkend="signed_commitment_3b"/>.</simpara>
<figure id="signed_commitment_3b"><title>Bob has a new signed commitment</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0906.png"/>
  </imageobject>
  <textobject><phrase>Bob has a new signed commitment</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_bob_acknowledges_new_commitment_and_revokes_old_one">
<title>Bob Acknowledges New Commitment and Revokes Old One</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>acknowledging new commitment/revoking old commitment</secondary>
</indexterm>
<indexterm>
  <primary>acknowledging new commitment/revoking old commitment</primary>
</indexterm>Now that Bob has a new signed commitment, he needs to acknowledge it and revoke the old commitment. <indexterm>
  <primary>revoke_and_ack message</primary>
</indexterm>He does so by sending the <literal>revoke_and_ack</literal> message, as we saw in <xref linkend="payment_channels"/> previously. As a reminder, that message is shown in <xref linkend="revoke_and_ack_message_2"/>.</simpara>
<example id="revoke_and_ack_message_2">
<title>The <literal>revoke_and_ack</literal> message</title>
<screen>[channel_id:channel_id]
[32*byte:per_commitment_secret]
[point:next_per_commitment_point]</screen>
</example>
<simpara>Bob sends the <literal>per_commitment_secret</literal> that allows Alice to construct a revocation key to build a penalty transaction spending Bob&#8217;s old commitment. Once Bob has sent this, he can never publish "Commitment #2" without risking a penalty transaction and losing all his money. So, the old commitment is effectively revoked.</simpara>
<simpara>Bob has effectively moved the channel state forward, as shown in <xref linkend="revoked_commitment_2b"/>.</simpara>
<figure id="revoked_commitment_2b"><title>Bob has revoked the old commitment</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0907.png"/>
  </imageobject>
  <textobject><phrase>Bob has revoked the old commitment</phrase></textobject>
</mediaobject>
</figure>
<simpara>Despite the fact that Bob has a new (signed) commitment transaction and an HTLC output inside, he cannot consider his HTLC as being set up successfully.</simpara>
<simpara>He first needs to have Alice revoke her old commitment, because otherwise, Alice can roll back her balance to 70,000 satoshis. Bob needs to make sure that Alice also has a commitment transaction containing the HTLC and has revoked the old commitment.</simpara>
<simpara>That is why, if Bob is not the final recipient of the HTLC funds, he should not forward the HTLC yet by offering an HTLC on the next channel with Chan.</simpara>
<simpara>Alice has constructed a mirror-image new commitment transaction containing the new HTLC, but it is yet to be signed by Bob. We can see it in <xref linkend="add_commitment_3a"/>.</simpara>
<figure id="add_commitment_3a"><title>Alice&#8217;s new commitment with an HTLC output</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0908.png"/>
  </imageobject>
  <textobject><phrase>Alice's new commitment with an HTLC output</phrase></textobject>
</mediaobject>
</figure>
<simpara>As we described in <xref linkend="payment_channels"/>, Alice&#8217;s commitment is the mirror image of Bob&#8217;s, as it contains the asymmetric, delayed, revocable construct for revocation and penalty enforcement of old commitments. Alice&#8217;s 19,800 satoshi balance (after deducting the HTLC value), is delayed and revocable. Bob&#8217;s 70,000 satoshi balance is immediately redeemable.</simpara>
<simpara>Next, the message flow for <literal>commitment_signed</literal> and <literal>revoke_and_ack</literal> is now repeated, but in the opposite direction. Bob sends <literal>commitment_signed</literal> to sign Alice&#8217;s  new commitment, and Alice responds by revoking her old commitment.<indexterm>
</indexterm></simpara>
<simpara>For completeness sake, let&#8217;s quickly review the commitment transactions as this round of commitment/revocation happens.</simpara>
</section>
<section id="_bob_commits" role="pagebreak-before less_space">
<title>Bob Commits</title>
<simpara>Bob now sends a <literal>commitment_signed</literal> back to Alice, with his signatures for Alice&#8217;s new commitment transaction, including the HTLC output she has added.</simpara>
<simpara>Now Alice has the signature for the new commitment transaction. The state of the channel is shown in <xref linkend="signed_commitment_3a"/>.</simpara>
<figure id="signed_commitment_3a"><title>Alice has a new signed commitment</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0909.png"/>
  </imageobject>
  <textobject><phrase>Alice has a new signed commitment</phrase></textobject>
</mediaobject>
</figure>
<simpara>Alice can now acknowledge the new commitment by revoking the old one. Alice sends the <literal>revoke_and_ack</literal> message containing the necessary <literal>per_commitment_point</literal> that will allow Bob to construct a revocation key and penalty transaction. Thus, Alice revokes her old commitment.</simpara>
<simpara>The channel state is shown in <xref linkend="revoked_commitment_2a"/>.<indexterm>
</indexterm><indexterm>
</indexterm> <indexterm>
</indexterm><indexterm>
</indexterm></simpara>
<figure id="revoked_commitment_2a"><title>Alice has revoked the old commitment</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0910.png"/>
  </imageobject>
  <textobject><phrase>Alice has revoked the old commitment</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section id="_multiple_htlcs">
<title>Multiple HTLCs</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>multiple contracts</secondary>
</indexterm>
<indexterm>
  <primary>multiple contracts</primary>
</indexterm>At any point in time, Alice and Bob may have dozens or even hundreds of HTLCs across a single channel. Each HTLC is offered and added to the commitment transaction as an additional output. A commitment transaction therefore always has two outputs for the channel partner balances and any number of HTLC outputs, one per HTLC.</simpara>
<simpara>As we saw in the <literal>commitment_signed</literal> message, there is an array for HTLC signatures so that multiple HTLC commitments can be transmitted at the same time.</simpara>
<simpara>The current maximum number of HTLCs allowed on a channel is 483 HTLCs to account for the maximum Bitcoin transaction size and ensure that the commitment transactions continue to be valid Bitcoin transactions.</simpara>
<simpara>As we will see in the next section, the maximum is only for <emphasis>pending</emphasis> HTLCs because, once an HTLC is fulfilled (or fails due to timeout/error), it is removed from the commitment transaction.</simpara>
</section>
<section id="_htlc_fulfillment">
<title>HTLC Fulfillment</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>fulfillment</secondary>
</indexterm>
<indexterm>
  <primary>fulfillment</primary>
</indexterm><indexterm>
  <primary>payment forwarding</primary><secondary>HTLC fulfillment</secondary>
</indexterm>
<indexterm>
  <primary>HTLC fulfillment</primary>
</indexterm>Now Bob and Alice both have a new commitment transaction with an additional HTLC output, and we have achieved a major step toward updating a payment <span class="keep-together">channel</span>.</simpara>
<simpara>The new balance of Alice and Bob does not reflect yet that Alice has successfully sent 50,200 satoshis to Bob.</simpara>
<simpara>However, the HTLCs are now set up in a way that secure settlement in exchange for the proof of payment will be possible.</simpara>
<section id="_htlc_propagation">
<title>HTLC Propagation</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>propagation</secondary>
</indexterm>
<indexterm>
  <primary>propagation</primary>
</indexterm><indexterm>
  <primary>payment forwarding</primary><secondary>HTLC propagation</secondary>
</indexterm>
<indexterm>
  <primary>HTLC propagation</primary>
</indexterm>Let&#8217;s assume that Bob continues the chain and sets up an HTLC with Chan for 50,100 satoshis. The process will be exactly the same as we just saw between Alice and Bob. Bob will send <literal>update_add_htlc</literal> to Chan, then they will exchange <literal>commitment_signed</literal> and <literal>revoke_and_ack</literal> messages in two rounds, progressing their channel to the next state.</simpara>
<simpara>Next, Chan will do the same with Dina: offer a 50,000 satoshi HTLC, commit, and revoke, etc. However, Dina is the final recipient of the HTLC. Dina is the only one that knows the payment secret (the preimage of the payment hash). Therefore, Dina can fulfill the HTLC with Chan immediately!</simpara>
</section>
<section id="_dina_fulfills_the_htlc_with_chan">
<title>Dina Fulfills the HTLC with Chan</title>
<simpara>Dina can settle the HTLC by sending an <literal>update_ful&#x2060;fill_&#x200b;htlc</literal> message to Chan. The <literal>update_fulfill_htlc</literal> message is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#removing-an-htlc-update_fulfill_htlc-update_fail_htlc-and-update_fail_malformed_htlc">BOLT #2: Peer Protocol, <literal>update_fulfill_htlc</literal></ulink> and is shown here:</simpara>
<formalpara id="update_fulfill_htlc_message"><title>The <literal>update_fulfill_htlc</literal> message</title><para>
<screen>[channel_id:channel_id]
[u64:id]
[32*byte:payment_preimage]</screen>
</para></formalpara>
<simpara>It&#8217;s a really simple message:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>channel_id</literal>
</term>
<listitem>
<simpara>
The channel ID on which the HTLC is committed.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>id</literal>
</term>
<listitem>
<simpara>
The ID of the HTLC (we started with 0 and incremented for each HTLC on the channel).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>payment_preimage</literal>
</term>
<listitem>
<simpara>
The secret that proves payment was made and redeems the HTLC. This is the <literal>R</literal> value that was hashed by Dina to produce the payment hash in the invoice to Alice.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>When Chan receives this message, he will immediately check if the <literal>payment_preimage</literal> (let&#8217;s call it <emphasis>R</emphasis>) produces the payment hash (let&#8217;s call it <emphasis>H</emphasis>) in the HTLC that he offered to Dina. He hashes it like this:</simpara>
<ul class="simplelist">
<li><em>H</em> = RIPEMD160(SHA-256 (<em>R</em>))</li>
</ul>
<simpara>If the result <emphasis>H</emphasis> matches the payment hash in the HTLC, Chan can do a little dance of celebration. This long-awaited secret can be used to redeem the HTLC, and will be passed back along the chain of payment channels all the way to Alice, resolving every HTLC that was part of this payment to Dina.</simpara>
<simpara>Let&#8217;s go back to Alice and Bob&#8217;s channel and watch them unwind the HTLC. To get there, let&#8217;s assume Dina sent the <literal>update_fulfill_htlc</literal> to Chan, Chan sent <literal>update_fulfill_htlc</literal> to Bob, and Bob sent <literal>update_fulfill_htlc</literal> to Alice. The payment preimage has propagated all the way back to Alice.</simpara>
</section>
<section id="_bob_settles_the_htlc_with_alice">
<title>Bob Settles the HTLC with Alice</title>
<simpara>When Bob sends the <literal>update_fulfill_htlc</literal> to Alice, it will contain the same <literal>payment_preimage</literal> that Dina selected for her invoice. That <literal>payment_preimage</literal> has traveled backward along the payment path. At each step, the <literal>channel_id</literal> will be different and <literal>id</literal> (HTLC ID) may be different. But the preimage is the same!</simpara>
<simpara>Alice will also validate the <literal>payment_preimage</literal> received from Bob. She will compare its hash to the HTLC payment hash in the HTLC she offered Bob. She will also find this preimage matches the hash in Dina&#8217;s invoice. This is proof that Dina was paid.</simpara>
<simpara>The message flow between Alice and Bob is shown in <xref linkend="htlc_fulfillment_message_flow"/>.</simpara>
<figure id="htlc_fulfillment_message_flow"><title>The HTLC fulfillment message flow</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0911.png"/>
  </imageobject>
  <textobject><phrase>The HTLC fulfillment message flow</phrase></textobject>
</mediaobject>
</figure>
<simpara>Both Alice and Bob can now remove the HTLC from the commitment transactions and update their channel balances.</simpara>
<simpara>They create new commitments (Commitment #4), as shown in <xref linkend="htlc_fulfillment_commitments_added"/>.</simpara>
<figure id="htlc_fulfillment_commitments_added"><title>The HTLC is removed and balances are updated in new commitments</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0912.png"/>
  </imageobject>
  <textobject><phrase>The HTLC is removed and balances are updated in new commitments</phrase></textobject>
</mediaobject>
</figure>
<simpara role="pagebreak-before">Next, they complete two rounds of commitment and revocation. First, Alice sends <literal>commitment_signed</literal> to sign Bob&#8217;s new commitment transaction. Bob responds with <literal>revoke_and_ack</literal> to revoke his old commitment. Once Bob has moved the state of the channel forward, the commitments look like we see in <xref linkend="htlc_fulfillment_commitments_bob_commit"/>.</simpara>
<figure id="htlc_fulfillment_commitments_bob_commit"><title>Alice signs Bob&#8217;s new commitment and Bob revoked the old one</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0913.png"/>
  </imageobject>
  <textobject><phrase>Alice signs Bob's new commitment and Bob revoked the old one</phrase></textobject>
</mediaobject>
</figure>
<simpara role="pagebreak-before">Finally, Bob signs Alice&#8217;s commitment by sending Alice a <literal>commitment_signed</literal> message. Then Alice acknowledges and revokes her old commitment by sending <literal>revoke_and_ack</literal> to Bob. The end result is that both Alice and Bob have moved their channel state to Commitment #4, have removed the HTLC, and have updated their balances. Their current channel state is represented by the commitment transactions that are shown in <xref linkend="alice_bob_htlc_fulfilled"/><indexterm>
</indexterm><indexterm>
</indexterm>. <indexterm>
</indexterm><indexterm>
</indexterm></simpara>
<figure id="alice_bob_htlc_fulfilled"><title>Alice and Bob settle the HTLC and update balances</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_0914.png"/>
  </imageobject>
  <textobject><phrase>Alice and Bob settle the HTLC and update balances</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section id="_removing_an_htlc_due_to_error_or_expiry" role="pagebreak-before less_space">
<title>Removing an HTLC Due to Error or Expiry</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>removing due to error/expiry</secondary>
</indexterm>
<indexterm>
  <primary>removing due to error/expiry</primary>
</indexterm><indexterm>
  <primary>payment forwarding</primary><secondary>removing an HTLC due to error/expiry</secondary>
</indexterm>
<indexterm>
  <primary>removing an HTLC due to error/expiry</primary>
</indexterm>If an HTLC cannot be fulfilled, it can be removed from the channel commitment using the same process of commitment and revocation.</simpara>
<simpara>Instead of <literal>update_fulfill_htlc</literal>, Bob would send an <literal>update_fail_htlc</literal> or <literal>update_fail_malformed_htlc</literal>. These two messages are defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#removing-an-htlc-update_fulfill_htlc-update_fail_htlc-and-update_fail_malformed_htlc">BOLT #2: Peer Protocol, Removing an HTLC</ulink>.</simpara>
<simpara>The <literal>update_fail_htlc</literal> message is shown in the following:</simpara>
<formalpara id="update_fail_htlc_message"><title>The <literal>update_fail_htlc</literal> message</title><para>
<screen>[channel_id:channel_id]
[u64:id]
[u16:len]
[len*byte:reason]</screen>
</para></formalpara>
<simpara>It&#8217;s pretty self-explanatory. The multibyte <literal>reason</literal> field is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#failure-messages">BOLT #4: Onion Routing</ulink>, which we will describe in <xref linkend="onion_routing"/>.</simpara>
<simpara>If Alice received an <literal>update_fail_htlc</literal> from Bob, the process would unfold in much the same way: the two channel partners would remove the HTLC, create updated commitment transactions, and go through two rounds of commitment/revocation to move the channel state forward to the next commitment. The only difference: the end balances would revert back to what they were without the HTLC, essentially refunding Alice for the HTLC value.</simpara>
</section>
<section id="_making_a_local_payment">
<title>Making a Local Payment</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>local payment with</secondary>
</indexterm>
<indexterm>
  <primary>local payment with</primary>
</indexterm><indexterm>
  <primary>local payments</primary>
</indexterm><indexterm>
  <primary>payment forwarding</primary><secondary>local payments</secondary>
</indexterm>
<indexterm>
  <primary>local payments</primary>
</indexterm>At this point, you will easily understand why HTLCs are used for both remote and local payments. When Alice pays Bob for a coffee, she doesn&#8217;t just update the channel balance and commit to a new state. Instead, the payment is made with an HTLC, in the same way Alice paid Dina. The fact that there&#8217;s only one channel hop makes no difference. It would work like this:</simpara>
<orderedlist numeration="arabic"><?dbfo start="1"?><?dbhtml start="1"?>
<listitem>
<simpara>
Alice orders a coffee from Bob&#8217;s shop page.
</simpara>
</listitem>
<listitem>
<simpara>
Bob&#8217;s shop sends an invoice with a payment hash.
</simpara>
</listitem>
<listitem>
<simpara>
Alice constructs an HTLC from that payment hash.
</simpara>
</listitem>
<listitem>
<simpara>
Alice offers the HTLC to Bob with <literal>update_add_htlc</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Alice and Bob exchange commitments and revocations adding the HTLC to their commitment transactions.
</simpara>
</listitem>
<listitem>
<simpara>
Bob sends <literal>update_fulfill_htlc</literal> to Alice with the payment preimage.
</simpara>
</listitem>
<listitem>
<simpara>
Alice and Bob exchange commitments and revocations removing the HTLC and updating the channel balances.
</simpara>
</listitem>
</orderedlist>
<simpara>Whether an HTLC is forwarded across many channels or just fulfilled in a single channel "hop," the process is exactly the same</simpara>
</section>
<section id="_conclusion_8">
<title>Conclusion</title>
<simpara>In this chapter we saw how commitment transactions (from <xref linkend="payment_channels"/>) and HTLCs (from <xref linkend="routing"/>) work together. We saw how an HTLC is added to a commitment transaction, and how it is fulfilled. We saw how the asymmetric, delayed, revocable system for enforcing channel state is extended to HTLCs.</simpara>
<simpara>We also saw how a local payment and a multihop routed payment are handled identically: using HTLCs.<indexterm>
</indexterm></simpara>
<simpara>In the next chapter we will look at the encrypted message routing system called <emphasis>onion routing</emphasis>.</simpara>
</section>
</chapter>
<chapter id="onion_routing">
<title>Onion Routing</title>
<simpara><indexterm>
  <primary>onion routing</primary>
</indexterm>In this chapter we will describe the Lightning Network&#8217;s onion routing mechanism. The invention of <emphasis>onion routing</emphasis> precedes the Lightning Network by 25 years! Onion routing was invented by U.S. Navy researchers as a communications security protocol. Onion routing is most famously used by Tor, the onion-routed internet overlay that allows researchers, activists, intelligence agents, and everyone else to use the internet privately and anonymously.</simpara>
<simpara>In this chapter we are focusing on the "Source-based onion routing (SPHINX)" part of the Lightning protocol architecture, highlighted by an outline in the center (routing layer) of <xref linkend="LN_protocol_onion_highlight"/>.</simpara>
<figure id="LN_protocol_onion_highlight"><title>Onion routing in the Lightning protocol suite</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1001.png"/>
  </imageobject>
  <textobject><phrase>Onion routing in the Lightning protocol suite</phrase></textobject>
</mediaobject>
</figure>
<simpara>Onion routing describes a method of encrypted communication where a message sender builds successive <emphasis>nested layers of encryption</emphasis> that are "peeled" off by each intermediary node, until the innermost layer is delivered to the intended recipient. The name "onion routing" describes this use of layered encryption that is peeled off one layer at a time, like the skin of an onion.</simpara>
<simpara>Each of the intermediary nodes can only "peel" one layer and see who is next in the communication path. Onion routing ensures that no one except the sender knows the destination or length of the communication path. Each intermediary only knows the previous and next hop.</simpara>
<simpara>The Lightning Network uses an implementation of onion routing protocol based on <em>Sphinx</em>,<footnote><simpara>George Danezis and Ian Goldberg, "Sphinx: A Compact and Provably Secure Mix Format," in <emphasis>IEEE Symposium on Security and Privacy</emphasis> (New York: IEEE, 2009), 269–282.</simpara></footnote> developed in 2009 by George Danezis and Ian Goldberg.</simpara>
<simpara>The implementation of onion routing in the Lightning Network is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md">BOLT #4: Onion Routing Protocol</ulink>.</simpara>
<section id="_a_physical_example_illustrating_onion_routing">
<title>A Physical Example Illustrating Onion Routing</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>physical example</secondary>
</indexterm>
<indexterm>
  <primary>physical example</primary>
</indexterm>There are many ways to describe onion routing, but one of the easiest is to use the physical equivalent of sealed envelopes. An envelope represents a layer of encryption, allowing only the named recipient to open it and read the contents.</simpara>
<simpara>Let&#8217;s say Alice wants to send a secret letter to Dina, indirectly via some intermediaries.</simpara>
<section id="_selecting_a_path">
<title>Selecting a Path</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>selecting a path</secondary>
</indexterm>
<indexterm>
  <primary>selecting a path</primary>
</indexterm>The Lightning Network uses <emphasis>source routing</emphasis>, which means that the payment path is selected and specified by the sender, and only the sender. In this example, Alice&#8217;s secret letter to Dina will be the equivalent of a payment. To make sure the letter reaches Dina, Alice will create a path from her to Dina, using Bob and Chan as intermediaries.</simpara>
<tip>
<simpara>There may be many paths that make it possible for Alice to reach Dina. We will explain the process of selecting the <emphasis>optimum</emphasis> path in <xref linkend="path_finding"/>. For now, we&#8217;ll assume that the path selected by Alice uses Bob and Chan as intermediaries to get to Dina.</simpara>
</tip>
<simpara role="pagebreak-before">As a reminder, the path selected by Alice is shown in <xref linkend="alice_dina_path"/>.</simpara>
<figure id="alice_dina_path"><title>Path: Alice to Bob to Chan to Dina</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1002.png"/>
  </imageobject>
  <textobject><phrase>Alice to Bob to Chan to Dina</phrase></textobject>
</mediaobject>
</figure>
<simpara>Let&#8217;s see how Alice can use this path without revealing information to intermediaries Bob and Chan.</simpara>
<sidebar>
<title>Source-Based Routing</title>
<simpara><indexterm>
  <primary>source-based routing</primary>
</indexterm>Source-based routing is not how packets are typically routed on the internet today, though source routing was possible in the early days.
Internet routing is based on <emphasis>packet switching</emphasis> at each intermediary routing node. An IPv4 packet, for example, includes the sender and recipient&#8217;s IP addresses, and every other IP routing node decides how to forward each packet toward the destination.
However, the lack of privacy in such a routing mechanism, where every intermediary node sees the sender and recipient, makes this a poor choice for use in a payment network.</simpara>
</sidebar>
</section>
<section id="_building_the_layers">
<title>Building the Layers</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>building the layers</secondary>
</indexterm>
<indexterm>
  <primary>building the layers</primary>
</indexterm>Alice starts by writing a secret letter to Dina.  She then seals the letter inside an envelope and writes "To Dina" on the outside (see <xref linkend="dina_envelope"/>). The envelope represents encryption with Dina&#8217;s public key so that only Dina can open the envelope and read the letter.</simpara>
<figure id="dina_envelope"><title>Dina&#8217;s secret letter, sealed in an envelope</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1003.png"/>
  </imageobject>
  <textobject><phrase>Dina's secret letter, sealed in an envelope</phrase></textobject>
</mediaobject>
</figure>
<simpara>Dina&#8217;s letter will be delivered to Dina by Chan, who is immediately before Dina in the "path." So, Alice puts Dina&#8217;s envelope inside an envelope addressed to Chan (see <xref linkend="chan_envelope"/>). The only part that Chan can read is the destination (routing instructions): "To Dina." Sealing this inside an envelope addressed to Chan represents encrypting it with Chan&#8217;s public key so that only Chan can read the envelope address. Chan still can&#8217;t open Dina&#8217;s envelope. All he sees is the instructions on the outside (the address).</simpara>
<figure id="chan_envelope"><title>Chan&#8217;s envelope, containing Dina&#8217;s sealed envelope</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1004.png"/>
  </imageobject>
  <textobject><phrase>Chan's envelope, containing Dina's sealed envelope</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now, this letter will be delivered to Chan by Bob. So Alice puts it inside an envelope addressed to Bob (see <xref linkend="bob_envelope"/>). As before, the envelope represents a message encrypted to Bob that only Bob can read. Bob can only read the outside of Chan&#8217;s envelope (the address), so he knows to send it to Chan.</simpara>
<figure id="bob_envelope"><title>Bob&#8217;s envelope, containing Chan&#8217;s sealed envelope</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1005.png"/>
  </imageobject>
  <textobject><phrase>Bob's envelope, containing Chan's sealed envelope</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now, if we could look through the envelopes (with X-rays!) we would see the envelopes nested one inside the other, as shown in <xref linkend="nested_envelopes"/>. <indexterm>
</indexterm></simpara>
<figure id="nested_envelopes"><title>Nested envelopes</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1006.png"/>
  </imageobject>
  <textobject><phrase>Nested envelopes</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_peeling_the_layers">
<title>Peeling the Layers</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>peeling the layers</secondary>
</indexterm>
<indexterm>
  <primary>peeling the layers</primary>
</indexterm>Alice now has an envelope that says "To Bob" on the outside. It represents an encrypted message that only Bob can open (decrypt). Alice will now begin the process by sending this to Bob. The entire process is shown in <xref linkend="sending_nested_envelopes"/>.</simpara>
<figure id="sending_nested_envelopes"><title>Sending the envelopes</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1007.png"/>
  </imageobject>
  <textobject><phrase>Sending the envelopes</phrase></textobject>
</mediaobject>
</figure>
<simpara>As you can see, Bob receives the envelope from Alice. He knows it came from Alice, but doesn&#8217;t know if Alice is the original sender or just someone forwarding envelopes. He opens it to find an envelope inside that says "To Chan." Since this is addressed to Chan, Bob can&#8217;t open it. He doesn&#8217;t know what&#8217;s inside it and doesn&#8217;t know if Chan is getting a letter or another envelope to forward. Bob doesn&#8217;t know if Chan is the ultimate recipient or not. Bob forwards the envelope to Chan.</simpara>
<simpara>Chan receives the envelope from Bob. He doesn&#8217;t know that it came from Alice. He doesn&#8217;t know if Bob is an intermediary or the sender of a letter. Chan opens the envelope and finds another envelope inside addressed "To Dina," which he can&#8217;t open. Chan forwards it to Dina, not knowing if Dina is the final recipient.</simpara>
<simpara>Dina receives an envelope from Chan. Opening it she finds a letter inside, so now she knows she&#8217;s the intended recipient of this message. She reads the letter, knowing that none of the intermediaries know where it came from and no one else has read her secret letter!</simpara>
<simpara>This is the essence of onion routing. The sender wraps a message in layers, specifying exactly how it will be routed and preventing any of the intermediaries from gaining any information about the path or payload. Each intermediary peels one layer, sees only a forwarding address, and doesn&#8217;t know anything other than the previous and next hop in the path.</simpara>
<simpara>Now, let&#8217;s look at the details of the onion routing implementation in the Lightning Network.<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_introduction_to_onion_routing_of_htlcs">
<title>Introduction to Onion Routing of HTLCs</title>
<simpara><indexterm>
  <primary>hash time-locked contracts (HTLCs)</primary><secondary>onion routing basics</secondary>
</indexterm>
<indexterm>
  <primary>onion routing basics</primary>
</indexterm><indexterm>
  <primary>onion routing</primary><secondary>HTLCs</secondary>
</indexterm>
<indexterm>
  <primary>HTLCs</primary>
</indexterm>Onion routing in the Lightning Network appears complex at first glance, but once you understand the basic concept, it is really quite simple.</simpara>
<simpara>From a practical perspective, Alice is telling every intermediary node what HTLC to set up with the next node in the path.</simpara>
<simpara><indexterm>
  <primary>origin node</primary>
</indexterm>The first node, which is the payment sender or Alice in our example, is called the <emphasis>origin node</emphasis>.  <indexterm>
  <primary>final node</primary>
</indexterm>The last node, which is the payment recipient or Dina in our example, is called the <emphasis>final node</emphasis>.</simpara>
<simpara><indexterm>
  <primary>hop</primary>
</indexterm>Each intermediary node, or Bob and Chan in our example, is called a <emphasis>hop</emphasis>. Every hop must set up an <emphasis>outgoing HTLC</emphasis> to the next hop. The information communicated to each hop by Alice is called the <emphasis>hop payload</emphasis> or <emphasis>hop data</emphasis>. The message that is routed from Alice to Dina is called an <emphasis>onion</emphasis> and consists of encrypted <emphasis>hop payload</emphasis> or <emphasis>hop data</emphasis> messages encrypted to each hop.</simpara>
<simpara>Now that we know the terminology used in Lightning onion routing, let&#8217;s restate Alice&#8217;s task: Alice must construct an onion with hop data, telling each hop how to construct an outgoing HTLC to send a payment to the final node (Dina).</simpara>
<section id="_alice_selects_the_path">
<title>Alice Selects the Path</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>selecting a path</secondary>
</indexterm>
<indexterm>
  <primary>selecting a path</primary>
</indexterm>From <xref linkend="routing"/> we know that Alice will send a 50,000 satoshi payment to Dina via Bob and Chan. This payment is transmitted via a series of HTLCs, as shown in <xref linkend="alice_dina_htlc_path"/>.</simpara>
<figure id="alice_dina_htlc_path"><title>Payment path with HTLCs from Alice to Dina</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1008.png"/>
  </imageobject>
  <textobject><phrase>Payment path with HTLCs from Alice to Dina</phrase></textobject>
</mediaobject>
</figure>
<simpara>As we will see in <xref linkend="gossip"/>, Alice is able to construct this path to Dina because Lightning nodes announce their channels to the entire Lightning Network using the Lightning Gossip Protocol. After the initial channel announcement, Bob and Chan each sent out an additional <literal>channel_update</literal> message with their routing fee and timelock expectations for payment routing.</simpara>
<simpara>From the announcements and updates, Alice knows the following information about the channels between Bob, Chan, and Dina:</simpara>
<itemizedlist>
<listitem>
<simpara>
A <literal>short_channel_id</literal> (short channel ID) for each channel, which Alice can use to reference the channel when constructing the path
</simpara>
</listitem>
<listitem>
<simpara>
A <literal>cltv_expiry_delta</literal> (timelock delta), which Alice can add to the expiry time for each HTLC
</simpara>
</listitem>
<listitem>
<simpara>
A <literal>fee_base_msat</literal> and <literal>fee_proportional_millionths</literal>, which Alice can use to calculate the total routing fee expected by that node for relay on that channel.
</simpara>
</listitem>
</itemizedlist>
<simpara>In practice, other information is also exchanged, such as the largest (<literal>htlc_maximum_msat</literal>) and smallest (<literal>htlc_minimum_msat</literal>) HTLCs a channel will carry, but these aren&#8217;t used as directly during onion route construction as the preceding fields are.</simpara>
<simpara>This information is used by Alice to identify the nodes, channels, fees, and timelocks for the following detailed path, shown in <xref linkend="alice_dina_path_detail"/>.</simpara>
<figure id="alice_dina_path_detail"><title>A detailed path constructed from gossiped channel and node information</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1009.png"/>
  </imageobject>
  <textobject><phrase>A path constructed from gossiped channel and node information</phrase></textobject>
</mediaobject>
</figure>
<simpara>Alice already knows her own channel to Bob and therefore doesn&#8217;t need this info to construct the path. Note also that Alice didn&#8217;t need a channel update from Dina because she has the update from Chan for that last channel in the path.</simpara>
</section>
<section id="_alice_constructs_the_payloads">
<title>Alice Constructs the Payloads</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>payload construction</secondary>
</indexterm>
<indexterm>
  <primary>payload construction</primary>
</indexterm>There are two possible formats that Alice can use for the information communicated to each hop: <indexterm>
  <primary>hop data</primary>
</indexterm>a legacy fixed-length format called the <emphasis>hop data</emphasis> and a more flexible Type-Length-Value (TLV) based format called the <emphasis>hop payload</emphasis>. The TLV message format is explained in more detail in <xref linkend="tlv"/>. It offers flexibility by allowing fields to be added to the protocol at will.</simpara>
<note>
<simpara>Both formats are specified in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#packet-structure">BOLT #4: Onion Routing Protocol, Packet Structure</ulink>.</simpara>
</note>
<simpara>Alice will start building the hop data from the end of the path backwards: Dina, Chan, then Bob.</simpara>
<section id="_final_node_payload_for_dina">
<title>Final node payload for Dina</title>
<simpara><indexterm>
  <primary>final node</primary>
</indexterm>Alice first builds the payload that will be delivered to Dina. Dina will not be constructing an "outgoing HTLC," because Dina is the final node and payment recipient. For this reason, the payload for Dina is different than all the others (uses all zeros for the <literal>short_channel_id</literal>), but only Dina will know this because it will be encrypted in the innermost layer of the onion. Essentially, this is the "secret letter to Dina" we saw in our physical envelope example.</simpara>
<simpara>The hop payload for Dina must match the information in the invoice generated by Dina for Alice and will contain (at least) the following fields in TLV format:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>amt_to_forward</literal>
</term>
<listitem>
<simpara>
The amount of this payment in millisatoshis. If this is only one part of a multipart payment, the amount is less than the total. Otherwise, this is a single, full payment and it is equal to the invoice amount and <literal>total_msat</literal> value.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>outgoing_cltv_value</literal>
</term>
<listitem>
<simpara>
The payment expiry timelock set to the value <literal>min_final_cltv_expiry</literal> in the invoice.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>payment_secret</literal>
</term>
<listitem>
<simpara>
A special 256-bit secret value from the invoice, allowing Dina to recognize this incoming payment. This also prevents a class of probing that previously made zero-value invoices insecure. Probing by intermediate nodes is mitigated as this value is encrypted to <emphasis>only</emphasis> the recipient, meaning they can&#8217;t reconstruct a final packet that "looks" legitimate.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>total_msat</literal>
</term>
<listitem>
<simpara>
The total amount matching the invoice. This may be omitted if there is only one part, in which case it is assumed to match <literal>amt_to_forward</literal> and must equal the invoice amount.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The invoice Alice received from Dina specified the amount as 50,000 satoshis, which is 50,000,000 millisatoshis. Dina specified the minimum expiry for the payment <literal>min_final_cltv_expiry</literal> as 18 blocks (3 hours, given 10-minute on average Bitcoin blocks). At the time Alice is attempting to make the payment, let&#8217;s say the Bitcoin blockchain has recorded 700,000 blocks. So Alice must set the <literal>outgoing_cltv_value</literal> to a <emphasis>minimum</emphasis> block height of 700,018.</simpara>
<simpara><indexterm>
  <primary>hop payload</primary>
</indexterm>Alice constructs the hop payload for Dina as follows:</simpara>
<screen>amt_to_forward : 50,000,000
outgoing_cltv_value: 700,018
payment_secret: fb53d94b7b65580f75b98f10...03521bdab6d519143cd521d1b3826
total_msat: 50,000,000</screen>
<simpara>Alice serializes it in TLV format, as shown (simplified) in <xref linkend="dina_onion_payload"/>.</simpara>
<figure id="dina_onion_payload"><title>Dina&#8217;s payload is constructed by Alice</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1010.png"/>
  </imageobject>
  <textobject><phrase>Dina's payload is constructed by Alice</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_hop_payload_for_chan">
<title>Hop payload for Chan</title>
<simpara>Next, Alice constructs the hop payload for Chan. This will tell Chan how to set up an outgoing HTLC to Dina.</simpara>
<simpara>The hop payload for Chan includes three fields: <literal>short_channel_id</literal>, <literal>amt_to_forward</literal>, and <literal>outgoing_cltv_value</literal>:</simpara>
<screen>short_channel_id: 010002010a42be
amt_to_forward: 50,000,000
outgoing_cltv_value: 700,018</screen>
<simpara>Alice serializes this payload in TLV format, as shown (simplified) in <xref linkend="chan_onion_payload"/>.</simpara>
<figure id="chan_onion_payload"><title>Chan&#8217;s payload is constructed by Alice</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1011.png"/>
  </imageobject>
  <textobject><phrase>Chan's payload is constructed by Alice</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_hop_payload_for_bob">
<title>Hop payload for Bob</title>
<simpara>Finally, Alice constructs the hop payload for Bob, which also contains the same three fields as the hop payload for Chan, but with different values:</simpara>
<screen>short_channel_id: 000004040a61f0
amt_to_forward: 50,100,000
outgoing_cltv_value: 700,038</screen>
<simpara>As you can see, the <literal>amt_to_forward</literal> field is 50,100,000 millisatoshis, or 50,100 satoshis. That&#8217;s because Chan expects a fee of 100 satoshis to route a payment to Dina. In order for Chan to "earn" that routing fee, Chan&#8217;s incoming HTLC must be 100 satoshis more than Chan&#8217;s outgoing HTLC. Since Chan&#8217;s incoming HTLC is Bob&#8217;s outgoing HTLC, the instructions to Bob reflect the fee Chan earns. In simple terms, Bob needs to be told to send 50,100 satoshi to Chan, so that Chan can send 50,000 satoshi and keep 100 satoshi.</simpara>
<simpara>Similarly, Chan expects a timelock delta of 20 blocks. So Chan&#8217;s incoming HTLC must expire 20 blocks <emphasis>later</emphasis> than Chan&#8217;s outgoing HTLC. To achieve this, Alice tells Bob to make his outgoing HTLC to Chan expire at block height 700,038-20 blocks later than Chan&#8217;s HTLC to Dina.</simpara>
<tip>
<simpara>Fees and timelock delta expectations for a channel are set by the difference between incoming and outgoing HTLCs. Since the incoming HTLC is created by the <emphasis>preceding node</emphasis>, the fee and timelock delta is set in the onion payload to that preceding node. Bob is told how to make an HTLC that meets Chan&#8217;s fee and timelock expectations.</simpara>
</tip>
<simpara>Alice serializes this payload in TLV format, as shown (simplified) in <xref linkend="bob_onion_payload"/>.</simpara>
<figure id="bob_onion_payload"><title>Bob&#8217;s payload is constructed by Alice</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1012.png"/>
  </imageobject>
  <textobject><phrase>Bob's payload is constructed by Alice</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_finished_hop_payloads">
<title>Finished hop payloads</title>
<simpara>Alice has now built the three hop payloads that will be wrapped in an onion. A simplified view of the payloads is shown in <xref linkend="onion_hop_payloads"/>.<indexterm>
</indexterm> <indexterm>
</indexterm></simpara>
<figure id="onion_hop_payloads"><title>Hop payloads for all the hops</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1013.png"/>
  </imageobject>
  <textobject><phrase>Hop payloads for all the hops</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section id="_key_generation" role="pagebreak-before less_space">
<title>Key Generation</title>
<simpara><indexterm>
  <primary>keys</primary><secondary>generating for onion routing</secondary>
</indexterm>
<indexterm>
  <primary>generating for onion routing</primary>
</indexterm><indexterm>
  <primary>keys</primary><secondary>onion routing and</secondary>
</indexterm>
<indexterm>
  <primary>onion routing and</primary>
</indexterm><indexterm>
  <primary>onion routing</primary><secondary>key generation</secondary>
</indexterm>
<indexterm>
  <primary>key generation</primary>
</indexterm>Alice must now generate several keys that will be used to encrypt the various layers in the onion.</simpara>
<simpara>With these keys, Alice can achieve a high degree of privacy and integrity:</simpara>
<itemizedlist>
<listitem>
<simpara>
Alice can encrypt each layer of the onion so that only the intended recipient can read it.
</simpara>
</listitem>
<listitem>
<simpara>
Every intermediary can check that the message is not modified.
</simpara>
</listitem>
<listitem>
<simpara>
No one in the path will know who sent this onion or where it is going. Alice doesn&#8217;t reveal her identity as the sender or Dina&#8217;s identity as the recipient of the payment.
</simpara>
</listitem>
<listitem>
<simpara>
Each hop only learns about the previous and next hop.
</simpara>
</listitem>
<listitem>
<simpara>
No one can know how long the path is, or where  in the path they are.
</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>Like a chopped onion, the following technical details may bring tears to your eyes. Feel free to skip to the next section if you get confused. Come back to this and read <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#packet-construction">BOLT #4: Onion Routing, Packet Construction</ulink>, if you want to learn more.</simpara>
</warning>
<simpara><indexterm>
  <primary>shared secret (ss)</primary>
</indexterm>The basis for all the keys used in the onion is a <emphasis>shared secret</emphasis> that Alice and Bob can both generate independently using the Elliptic Curve Diffie–Hellman (ECDH) algorithm. From the shared secret (ss), they can independently generate four additional keys named <literal>rho</literal>, <literal>mu</literal>, <literal>um</literal>, and <literal>pad</literal>:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>rho</literal>
</term>
<listitem>
<simpara>
Used to generate a stream of random bytes from a stream cipher (used as a
CSPRNG). These bytes are used to encrypt/decrypt the message body as well as
filler zero bytes during Sphinx packet processing.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>mu</literal>
</term>
<listitem>
<simpara>
Used in the hash-based message authentication code (HMAC) for integrity/authenticity verification.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>um</literal>
</term>
<listitem>
<simpara>
Used in error reporting.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>pad</literal>
</term>
<listitem>
<simpara>
Used to generate filler bytes for padding the onion to a fixed length.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The relationship between the various keys and how they are generated is diagrammed in <xref linkend="onion_keygen"/>.</simpara>
<figure id="onion_keygen"><title>Onion key generation</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1014.png"/>
  </imageobject>
  <textobject><phrase>Onion Key Generation</phrase></textobject>
</mediaobject>
</figure>
<section id="session_key">
<title>Alice&#8217;s session key</title>
<simpara><indexterm>
  <primary>session key</primary>
</indexterm>To avoid revealing her identity, Alice does not use her own node&#8217;s public key in building the onion. Instead, Alice creates a temporary 32-byte (256-bit) key called the <emphasis>session private key</emphasis> and corresponding <emphasis>session public key</emphasis>. This serves as a temporary "identity" and key <emphasis>for this onion only</emphasis>. From this session key, Alice will build all the other keys that will be used in this onion.</simpara>
</section>
<section id="keygen_details">
<title>Key generation details</title>
<simpara>The key generation, random byte generation, ephemeral keys, and how they are used in packet construction are specified in three sections of BOLT #4:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#key-generation">Key Generation</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#pseudo-random-byte-stream">Random Byte Stream</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#packet-construction">Packet Construction</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>For simplicity and to avoid getting too technical, we have not included these details in the book. See the preceding links if you want to see the inner workings.</simpara>
</section>
<section id="shared_secret">
<title>Shared secret generation</title>
<simpara><indexterm>
  <primary>shared secret (ss)</primary>
</indexterm>One important detail that seems almost magical is the ability for Alice to create a <emphasis>shared secret</emphasis> with another node simply by knowing their public keys. <indexterm>
  <primary>Diffie-Hellman Key Exchange (DHKE)</primary>
</indexterm>This is based on the invention of Diffie–Hellman key exchange (DH) in the 1970s that revolutionized cryptography. Lightning onion routing uses Elliptic Curve Diffie–Hellman (ECDH) on Bitcoin&#8217;s <literal>secp256k1</literal> curve. It&#8217;s such a cool trick that we try to explain it in simple terms in <xref linkend="ecdh_explained"/>.</simpara>
<sidebar id="ecdh_explained">
<title>Elliptic Curve Diffie–Hellman Explained</title>
<simpara><indexterm>
  <primary>ECDH (Elliptic Curve Diffie–Hellman)</primary>
</indexterm><indexterm>
  <primary>Elliptic Curve Diffie–Hellman (ECDH)</primary>
</indexterm>Assume Alice&#8217;s private key is <emphasis>a</emphasis> and Bob&#8217;s private key is <emphasis>b</emphasis>. Using the elliptic curve, Alice and Bob each multiply their private key by the generator point <emphasis>G</emphasis> to produce their public keys <emphasis>A</emphasis> and <emphasis>B</emphasis>, respectively:</simpara>
<ul class="simplelist">
<li><em>A</em> = <em>aG</em></li>
<li><em>B</em> = <em>bG</em></li>
</ul>
<simpara>Now Alice and Bob can use <emphasis>Elliptic Curve Diffie–Hellman Key Exchange</emphasis> to create a shared secret <emphasis>ss</emphasis>, a value that they can both calculate independently without exchanging any information</simpara>
<simpara>The shared secret <emphasis>ss</emphasis> is calculated by each by multiplying their own private key with the <emphasis>other&#8217;s</emphasis> public key, such that:</simpara>
<ul class="simplelist">
<li><em>ss</em> = <em>aB</em> = <em>bA</em></li>
</ul>
<simpara>But why would these two multiplications result in the same value <emphasis>ss</emphasis>?
Follow along, as we demonstrate the math that proves this is possible:</simpara>
<ul class="simplelist">
<li><em>ss</em></li>
<li>= <em>aB</em></li>
</ul>
<simpara>calculated by Alice who knows both <emphasis>a</emphasis> (her private key) and <emphasis>B</emphasis> (Bob&#8217;s public key)</simpara>
<ul class="simplelist">
<li>= <em>a</em>(<em>bG</em>)</li>
</ul>
<simpara>because we know that <emphasis>B</emphasis> = <emphasis>bG</emphasis>, we substitute</simpara>
<ul class="simplelist">
<li> = (<em>ab</em>)<em>G</em></li>
</ul>
<simpara>because of associativity, we can move the parentheses</simpara>
<ul class="simplelist">
<li>= (<em>ba</em>)<em>G</em></li>
</ul>
<simpara>because <emphasis>xy</emphasis> = <emphasis>yx</emphasis> (the curve is an abelian group)</simpara>
<ul class="simplelist">
<li>= <em>b</em>(<em>aG</em>)</li>
</ul>
<simpara>because of associativity, we can move the parentheses</simpara>
<ul class="simplelist">
<li>= <em>bA</em></li>
</ul>
<simpara>and we can substitute <emphasis>aG</emphasis> with <emphasis>A</emphasis>.</simpara>
<simpara>The result <emphasis>bA</emphasis> can be calculated independently by Bob who knows <emphasis>b</emphasis> (his private key) and <emphasis>A</emphasis> (Alice&#8217;s public key).</simpara>
<simpara>We have therefore shown that:</simpara>
<ul class="simplelist">
<li><em>ss</em> = <em>aB</em> (Alice can calculate this)</li>
<li><em>ss</em> = <em>bA</em> (Bob can calculate this)</li>
</ul>
<simpara>Thus, they can each independently calculate <emphasis>ss</emphasis> which they can use as a shared key to symmetrically encrypt secrets between the two of them without communicating the shared secret.<indexterm>
</indexterm></simpara>
</sidebar>
<simpara>A unique trait of Sphinx as a mix-net packet format is that rather than include a distinct session key for each hop in the route, which would increase the size of the mix-net packet dramatically, <indexterm>
  <primary>blinding scheme</primary>
</indexterm>a clever <emphasis>blinding</emphasis> scheme is used to deterministically randomize the session key at each hop.</simpara>
<simpara>In practice, this little trick allows us to keep the onion packet as compact as possible while still retaining the desired security properties.</simpara>
<simpara>The session key for hop <literal>i</literal> is derived using the node public key, and derived shared secret of hop <literal>i – 1</literal>:
```
```</simpara>
<simpara>In other words, we take the session key of the prior hop, and multiply it by a value derived from the public key and the derived shared secret for that hop.</simpara>
<simpara>As elliptic curve multiplication can be performed on a public key without knowledge of the private key, each hop is able to re-randomize the session key for the next hop in a deterministic fashion.</simpara>
<simpara>The creator of the onion packet knows all the shared secrets (as they&#8217;ve encrypted the packet uniquely for each hop), and thus are able to derive all the blinding factors.</simpara>
<simpara>This knowledge allows them to derive all the session keys used up front during packet generation.</simpara>
<simpara>Note that the very first hop uses the original session key generated because this key is used to kick off the session key blinding by each subsequent hop<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm>.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
</section>
<section id="wrapping_the_onion">
<title>Wrapping the Onion Layers</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>wrapping the onion layers</secondary>
</indexterm>
<indexterm>
  <primary>wrapping the onion layers</primary>
</indexterm>The process of wrapping the onion is detailed in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#packet-construction">BOLT #4: Onion Routing, Packet Construction</ulink>.</simpara>
<simpara>In this section we will describe this process at a high and somewhat simplified level, omitting certain details.</simpara>
<section id="fixed_length_onions">
<title>Fixed-Length Onions</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>fixed-length onions</secondary>
</indexterm>
<indexterm>
  <primary>fixed-length onions</primary>
</indexterm>We&#8217;ve mentioned the fact that none of the "hop" nodes know how long the path is, or where they are in the path. How is this possible?</simpara>
<simpara>If you have a set of directions, even if encrypted, can&#8217;t you tell how far you are from the beginning or end simply by looking at <emphasis>where</emphasis> in the list of directions you are?</simpara>
<simpara>The trick used in onion routing is to always make the path (the list of directions) the same length for every node. This is achieved by keeping the onion packet the same length at every step.</simpara>
<simpara>At each hop, the hop payload appears at the beginning of the onion payload, followed by <emphasis>what seem to be</emphasis> 19 more hop payloads. Every hop sees itself as the first of 20 hops.</simpara>
<tip>
<simpara>The onion payload is 1,300 bytes. Each hop payload is 65 bytes or less (padded to 65 bytes if less). So the total onion payload can fit 20 hop payloads (1300 = 20 &times; 65). The maximum onion routed path is therefore 20 hops.</simpara>
</tip>
<simpara>As each layer is "peeled off," more filler data (essentially junk) is added at the end of the onion payload so the next hop gets an onion of the same size and is once again the "first hop" in the onion.</simpara>
<simpara>The onion size is 1,366 bytes, structured as shown in <xref linkend="onion_packet"/>:</simpara>
<variablelist>
<varlistentry>
<term>
1 byte
</term>
<listitem>
<simpara>
A version byte
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
33 bytes
</term>
<listitem>
<simpara>
A compressed public session key (<xref linkend="session_key"/>) from which the per-hop shared secret (<xref linkend="shared_secret"/>) can be generated without revealing Alice&#8217;s identity
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
1,300 bytes
</term>
<listitem>
<simpara>
The actual <emphasis>onion payload</emphasis> containing the instructions for each hop
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
32 bytes
</term>
<listitem>
<simpara>
An HMAC integrity checksum
</simpara>
</listitem>
</varlistentry>
</variablelist>
<figure id="onion_packet"><title>The onion packet</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1015.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1015.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>A unique trait of Sphinx as a mix-net packet format is that rather than include a distinct session key for each hop in the route, which would increase the size of the mix-net packet dramatically, instead a clever <emphasis>blinding</emphasis> scheme is used to deterministically randomize the session key at each hop.</simpara>
<simpara>In practice, this little trick allows us to keep the onion packet as compact as possible while still retaining the desired security properties.</simpara>
</section>
<section id="_wrapping_the_onion_outlined">
<title>Wrapping the Onion (Outlined)</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>outline of wrapping process</secondary>
</indexterm>
<indexterm>
  <primary>outline of wrapping process</primary>
</indexterm>Here is the process of wrapping the onion, outlined next. Come back to this list as we explore each step with our real-world example.</simpara>
<simpara>For each hop, the sender (Alice) repeats the same process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Alice generates the per-hop shared secret and the <literal>rho</literal>, <literal>mu</literal>, and <literal>pad</literal> keys.
</simpara>
</listitem>
<listitem>
<simpara>
Alice generates 1,300 bytes of filler and fills the 1,300-byte onion payload field with this filler.
</simpara>
</listitem>
<listitem>
<simpara>
Alice calculates the HMAC for the hop payload (zeros for the final hop).
</simpara>
</listitem>
<listitem>
<simpara>
Alice calculates the length of the hop payload + HMAC + space to store the length itself.
</simpara>
</listitem>
<listitem>
<simpara>
Alice <emphasis>right-shifts</emphasis> the onion payload by the calculated space needed to fit the hop payload. The rightmost "filler" data is discarded, making enough space on the left for the payload.
</simpara>
</listitem>
<listitem>
<simpara>
Alice inserts the length + hop payload + HMAC at the front of the payload field in the space made from shifting the filler.
</simpara>
</listitem>
<listitem>
<simpara>
Alice uses the <literal>rho</literal> key to generate a 1,300-byte one-time pad.
</simpara>
</listitem>
<listitem>
<simpara>
Alice obfuscates the entire onion payload by XORing with the bytes generated from <literal>rho</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Alice calculates the HMAC of the onion payload, using the <literal>mu</literal> key.
</simpara>
</listitem>
<listitem>
<simpara>
Alice adds the session public key (so that the hop can calculate the shared secret).
</simpara>
</listitem>
<listitem>
<simpara>
Alice adds the version number.
</simpara>
</listitem>
<listitem>
<simpara>
Alice deterministically re-blinds the session key using a value derived by hashing the shared secret and prior hop&#8217;s public key.
</simpara>
</listitem>
</orderedlist>
<simpara>Next, Alice repeats the process. The new keys are calculated, the onion payload is shifted (dropping more junk), the new hop payload is added to the front, and the whole onion payload is encrypted with the <literal>rho</literal> byte stream for the next hop.</simpara>
<simpara>For the final hop, the HMAC included in Step #3 over the plain-text instructions is actually <emphasis>all zero</emphasis>.
The final hop uses this signal to determine that it is indeed the final hop in the route.
Alternatively, the fact that the <literal>short_chan_id</literal> included in the payload to denote the "next hop" is all zero can be used as well.</simpara>
<simpara>Note that at each phase the <literal>mu</literal> key is used to generate an HMAC over the <emphasis>encrypted</emphasis> (from the point of view of the node processing the payload) onion packet, as well as over the contents of the packet with a single layer of encryption removed.
This outer HMAC allows the node processing the packet to verify the integrity of the onion packet (no bytes modified).
The inner HMAC is then revealed during the inverse of the "shift and encrypt" routine described previously, which serves as the <emphasis>outer</emphasis> HMAC for the next hop.</simpara>
</section>
<section id="_wrapping_dina_8217_s_hop_payload">
<title>Wrapping Dina&#8217;s Hop Payload</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>wrapping hop payloads</secondary>
</indexterm>
<indexterm>
  <primary>wrapping hop payloads</primary>
</indexterm>As a reminder, the onion is wrapped by starting at the end of the path from Dina, the final node or recipient. Then the path is built in reverse all the way back to the sender, Alice.</simpara>
<simpara>Alice starts with an empty 1,300-byte field, the fixed-length <emphasis>onion payload</emphasis>. Then, she fills the onion payload with a pseudorandom byte stream "filler" that is generated from the <literal>pad</literal> key.</simpara>
<simpara>This is shown in <xref linkend="onion_payload_filler"/>.</simpara>
<note>
<simpara>Random byte stream generation uses the ChaCha20 algorithm, as a cryptographic secure pseudorandom number generator (CSPRNG). Such an algorithm will generate a deterministic, long, nonrepeating stream of seemingly random bytes from an initial seed. The details are specified in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#pseudo-random-byte-stream">BOLT #4: Onion Routing, Pseudo Random Byte Stream</ulink>.</simpara>
</note>
<figure id="onion_payload_filler"><title>Filling the onion payload with a random byte stream</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1016.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1016.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>Alice will now insert Dina&#8217;s hop payload into the left side of the 1,300-byte array, shifting the filler to the right and discarding anything that overflows. This is visualized in <xref linkend="onion_add_dina"/>.</simpara>
<figure id="onion_add_dina"><title>Adding Dina&#8217;s hop payload</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1017.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1017.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>Another way to look at this is that Alice measures the length of Dina&#8217;s hop payload, shifts the filler right to create an equal space in the left side of the onion payload, and inserts Dina&#8217;s payload in that space.</simpara>
<simpara>Next row down we see the result: the 1,300 byte onion payload contains Dina&#8217;s hop payload and then the filler byte stream filling up the rest of the space.</simpara>
<simpara>Next, Alice obfuscates the entire onion payload so that <emphasis>only Dina</emphasis> can read it.</simpara>
<simpara>To do this, Alice generates a byte stream using the <literal>rho</literal> key (which Dina also knows). Alice uses a bitwise exclusive or (XOR) between the bits of the onion payload and the byte stream created from <literal>rho</literal>. The result appears like a random (or encrypted) byte stream of 1,300 bytes length. This step is shown in <xref linkend="onion_obfuscate_dina"/>.</simpara>
<figure id="onion_obfuscate_dina"><title>Obfuscating the onion payload</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1018.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1018.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>One of the properties of XOR is that if you do it twice, you get back to the original data. As we will see in <xref linkend="bobDeobfuscates"/>, if Dina applies the same XOR operation with the byte stream generated from <literal>rho</literal>, it will reveal the original onion payload.</simpara>
<tip>
<simpara>XOR is an <emphasis>involutory</emphasis> function, which means that if it is applied twice, it undoes itself. Specifically XOR(XOR(<emphasis>a</emphasis>, <emphasis>b</emphasis>), <emphasis>b</emphasis>) = <emphasis>a</emphasis>. This property is used extensively in symmetric-key cryptography.</simpara>
</tip>
<simpara>Because only Alice and Dina have the <literal>rho</literal> key (derived from Alice and Dina&#8217;s shared secret), only they can do this. Effectively, this encrypts the onion payload for Dina&#8217;s eyes only.</simpara>
<simpara>Finally, Alice calculates a hash-based message authentication code (HMAC) for Dina&#8217;s payload, which uses the <literal>mu</literal> key as its initialization key. This is shown in <xref linkend="dina_hop_payload_hmac"/>.</simpara>
<figure id="dina_hop_payload_hmac"><title>Adding an HMAC integrity checksum to Dina&#8217;s hop payload</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1019.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1019.png</phrase></textobject>
</mediaobject>
</figure>
<section id="_onion_routing_replay_protection_and_detection">
<title>Onion routing replay protection and detection</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>replay protection/detection</secondary>
</indexterm>
<indexterm>
  <primary>replay protection/detection</primary>
</indexterm>The HMAC acts as a secure checksum and helps Dina verify the integrity of the hop payload. The 32-byte HMAC is appended to Dina&#8217;s hop payload.
<indexterm>
  <primary>encrypt-then-mac</primary>
</indexterm>Note that we compute the HMAC over the <emphasis>encrypted</emphasis> data rather then over the plain-text data.
This is known as <emphasis>encrypt-then-mac</emphasis> and is the recommended way to use a MAC, as it provides both plain-text <emphasis>and</emphasis> ciphertext integrity.</simpara>
<simpara><indexterm>
  <primary>AD (associated data)</primary>
</indexterm><indexterm>
  <primary>associated data (AD)</primary>
</indexterm>Modern authenticated encryption also allows for the use of an optional set of plaintext bytes to also be authenticated, known as <emphasis>associated data.</emphasis>
In practice, this is usually something like a plain-text packet header or other auxiliary information.
By including this associated data in the payload to be authenticated (MAC&#8217;ed), the verifier of the MAC ensures that this associated data hasn&#8217;t been tampered with (e.g., swapping out the plain-text header on an encrypted packet).</simpara>
<simpara>In the context of the Lightning Network, this associated data is used to <emphasis>strengthen</emphasis> the replay protection of this scheme.
As we&#8217;ll learn in the following, replay protection ensures that an attacker can&#8217;t <emphasis>retransmit</emphasis> (replay) a packet into the network and observe its resulting path.
Instead, intermediate nodes are able to use the defined replay protection measures to detect and reject a replayed packet.
The base Sphinx packet format uses a log of all the ephemeral secret keys used to detect replays.
If a secret key is ever used again, then the node can detect it and reject the packet.</simpara>
<simpara>The nature of HTLCs in the Lightning Network allows us to further strengthen the replay protection by adding an additional <emphasis>economic</emphasis> incentive.
Remember that the payment hash of an HTLC can only ever safely be used (for a complete payment) once.
If a payment hash is used again and traverses a node that has already seen the payment secret for that hash, then they can simply pull the funds and collect the entire payment amount without forwarding!
We can use this fact to strengthen the replay protection by requiring that the <emphasis>payment hash</emphasis> is included in our HMAC computation as the associated data.
With this added step, attempting to replay an onion packet also requires the sender to commit to using the <emphasis>same</emphasis> payment hash.
As a result, on top of the normal replay protection, an attacker also stands to lose the entire amount of the HTLC replayed.</simpara>
<simpara>One consideration with the ever-increasing set of session keys stored for replay protection is: are nodes able to reclaim this space?
In the context of the Lightning Network, the answer is: yes!
Once again, due to the unique attributes of the HTLC construct, we can make a further improvement over the base Sphinx protocol.
Given that HTLCs are <emphasis>time-locked</emphasis> contracts based on the absolute block height, once an HTLC has expired, then the contract is effectively permanently closed.
As a result, nodes can use this CLTV (CHECKLOCKTIMEVERIFY operator) expiration height as an indicator to know when it&#8217;s safe to garbage collect an entry in the anti-replay log.</simpara>
</section>
</section>
<section id="_wrapping_chan_8217_s_hop_payload">
<title>Wrapping Chan&#8217;s Hop Payload</title>
<simpara>In <xref linkend="chan_onion_wrapping"/> we see the steps used to wrap Chan&#8217;s hop payload in the onion. These are the same steps Alice used to wrap Dina&#8217;s hop payload.</simpara>
<figure id="chan_onion_wrapping"><title>Wrapping the onion for Chan</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1020.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1020.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>Alice starts with the 1,300 onion payload created for Dina. The first 65 (or fewer) bytes of this are Dina&#8217;s payload obfuscated and the rest is filler. Alice must be careful not to overwrite Dina&#8217;s payload.</simpara>
<simpara>Next, Alice needs to locate the ephemeral public key (which was generated at the very start for each hop) that will be prepended to the routing packet at this hop.</simpara>
<simpara>Remember that rather than include a unique ephemeral public key (that the sender and intermediate node use in an ECDH operation to generate a shared secret), Sphinx uses a single ephemeral public key that is deterministically randomized at each hop.</simpara>
<simpara>When processing the packet, Dina will use her shared secret and public key to derive the blinding value (<literal>b_dina</literal>) and use that to re-randomize the ephemeral public key, in an identical operation to what Alice performs during initial packet construction.</simpara>
<simpara>Alice adds an inner HMAC checksum to Chan&#8217;s payload and inserts it at the "front" (left side) of the onion payload, shifting the existing payload to the right by an equal amount.
Remember that there are effectively <emphasis>two</emphasis> HMACs used in the scheme: the outer HMAC and the inner HMAC.
In this case, Chan&#8217;s <emphasis>inner</emphasis> HMAC is actually Dina&#8217;s <emphasis>outer</emphasis> HMAC.</simpara>
<simpara>Now Chan&#8217;s payload is in the front of the onion. When Chan sees this, he has no idea how many payloads came before or after. It looks like the first of 20 hops always!</simpara>
<simpara>Next, Alice obfuscates the entire payload by XOR with the byte stream generated from the Alice-Chan <literal>rho</literal> key. Only Alice and Chan have this <literal>rho</literal> key, and only they can produce the byte stream to obfuscate and de-obfuscate the onion.
Finally, as we did in the earlier step, we compute Chan&#8217;s outer HMAC, which is what she&#8217;ll use to verify the integrity of the encrypted onion packet.</simpara>
</section>
<section id="_wrapping_bob_8217_s_hop_payload">
<title>Wrapping Bob&#8217;s Hop Payload</title>
<simpara>In <xref linkend="bob_onion_wrapping"/> we see the steps used to wrap Bob&#8217;s hop payload in the onion.</simpara>
<simpara>All right, by now this is easy!</simpara>
<simpara>Start with the onion payload (obfuscated) containing Chan&#8217;s and Dina&#8217;s hop payloads.</simpara>
<simpara>Obtain the session key for this hop dervied from the blinding factor generated by the prior hop.
Include the prior hop&#8217;s outer HMAC as this hop&#8217;s inner HMAC.
Insert Bob&#8217;s hop payload at the beginning and shift everything else over to the right, dropping a Bob-hop-payload-size chunk from the end (it was filler anyway).</simpara>
<simpara>Obfuscate the whole thing XOR with the <literal>rho</literal> key from the Alice-Bob shared secret so that only Bob can unwrap this.</simpara>
<simpara>Calculate the outer HMAC and stick it on the end of Bob&#8217;s hop payload.<indexterm>
</indexterm></simpara>
<figure id="bob_onion_wrapping"><title>Wrapping the onion for Bob</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1021.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1021.png</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_the_final_onion_packet">
<title>The Final Onion Packet</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>final onion packet</secondary>
</indexterm>
<indexterm>
  <primary>final onion packet</primary>
</indexterm>The final onion payload is ready to be sent to Bob. Alice doesn&#8217;t need to add any more hop payloads.</simpara>
<simpara>Alice calculates an HMAC for the onion payload to cryptographically secure it with a checksum that Bob can verify.</simpara>
<simpara>Alice adds a 33-byte public session key that will be used by each hop to generate a shared secret and the <literal>rho</literal>, <literal>mu</literal>, and <literal>pad</literal> keys.</simpara>
<simpara>Finally Alice puts the onion version number (<literal>0</literal> currently) in the front. This allows for future upgrades of the onion packet format.</simpara>
<simpara>The result can be seen in <xref linkend="onion_packet_2"/>. <indexterm>
</indexterm></simpara>
<figure id="onion_packet_2"><title>The onion packet</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1015.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1015.png</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section id="_sending_the_onion">
<title>Sending the Onion</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>sending the onion</secondary>
</indexterm>
<indexterm>
  <primary>sending the onion</primary>
</indexterm>In this section we will look at how the onion packet is forwarded and how HTLCs are deployed along the path.</simpara>
<section id="_the_update_add_htlc_message">
<title>The update_add_htlc Message</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>update_add_htlc message</secondary>
</indexterm>
<indexterm>
  <primary>update_add_htlc message</primary>
</indexterm><indexterm>
  <primary>update_add_htlc message</primary>
</indexterm>Onion packets are sent as part of the <literal>update_add_htlc</literal> message. If you recall from <xref linkend="update_add_htlc"/>, in <xref linkend="channel_operation"/>, we saw the contents of the <literal>update_add_htlc</literal> message are as follows:</simpara>
<screen>[channel_id:channel_id]
[u64:id]
[u64:amount_msat]
[sha256:payment_hash]
[u32:cltv_expiry]
[1366*byte:onion_routing_packet]</screen>
<simpara>You will recall that this message is sent by one channel partner to ask the other channel partner to add an HTLC. This is how Alice will ask Bob to add an HTLC to pay Dina. Now you understand the purpose of the last field, <literal>onion_routing_packet</literal>, which is 1,366 bytes long. It&#8217;s the fully wrapped onion packet we just constructed!</simpara>
</section>
<section id="_alice_sends_the_onion_to_bob">
<title>Alice Sends the Onion to Bob</title>
<simpara>Alice will send the <literal>update_add_htlc</literal> message to Bob. Let&#8217;s look at what this message will contain:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>channel_id</literal>
</term>
<listitem>
<simpara>
This field contains the Alice-Bob channel ID, which in our example is <literal>0000031e192ca1</literal> (see <xref linkend="alice_dina_path_detail"/>).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>id</literal>
</term>
<listitem>
<simpara>
The ID of this HTLC in this channel, starting at <literal>0</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>amount_msat</literal>
</term>
<listitem>
<simpara>
The amount of the HTLC: 50,200,000 millisatoshis.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>payment_hash</literal>
</term>
<listitem>
<simpara>
The RIPEMD160(SHA-256) payment hash:
</simpara>
<simpara><literal>9e017f6767971ed7cea17f98528d5f5c0ccb2c71</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>cltv_expiry</literal>
</term>
<listitem>
<simpara>
The expiry timelock for the HTLC will be 700,058. Alice adds 20 blocks to the expiry set in Bob&#8217;s payload according to Bob&#8217;s negotiated <literal>cltv_expiry_delta</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>onion_routing_packet</literal>
</term>
<listitem>
<simpara>
The final onion packet Alice constructed with all the hop payloads!
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_bob_checks_the_onion">
<title>Bob Checks the Onion</title>
<simpara>As we saw in <xref linkend="channel_operation"/>, Bob will add the HTLC to the commitment transactions and update the state of the channel with Alice.</simpara>
<simpara>Bob will unwrap the onion he received from Alice as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Bob takes the session key from the onion packet and derives the Alice-Bob shared secret.
</simpara>
</listitem>
<listitem>
<simpara>
Bob generates the <literal>mu</literal> key from the shared secret and uses it to verify the onion packet HMAC checksum.
</simpara>
</listitem>
</orderedlist>
<simpara>Now that Bob has generated the shared key and verified the HMAC, he can start unwrapping the 1,300 byte onion payload inside the onion packet. The goal is for Bob to retrieve his own hop payload and then forward the remaining onion to the next hop.</simpara>
<simpara>If Bob extracts and removes his hop payload, the remaining onion will not be 1,300 bytes, it will be shorter! So the next hop will know that they are not the first hop and will be able to detect how long the path is. To prevent this, Bob needs to add more filler to refill the onion.</simpara>
</section>
<section id="_bob_generates_filler">
<title>Bob Generates Filler</title>
<simpara>Bob generates filler in a slightly different way than Alice, but following the same general principle.</simpara>
<simpara>First, Bob <emphasis>extends</emphasis> the onion payload by 1,300 bytes and fills them with <literal>0</literal> values. Now the onion packet is 2,600 bytes long, with the first half containing the data Alice sent and the next half containing zeroes. This operation is shown in <xref linkend="bob_extends"/>.</simpara>
<figure id="bob_extends"><title>Bob extends the onion payload by 1,300 (zero-filled) bytes</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1023.png"/>
  </imageobject>
  <textobject><phrase>Bob extends the onion payload by 1,300 (zero-filled) bytes</phrase></textobject>
</mediaobject>
</figure>
<simpara>This empty space will become obfuscated and turn into "filler" by the same process that Bob uses to de-obfuscate his own hop payload. Let&#8217;s see how that works.</simpara>
</section>
<section id="bobDeobfuscates">
<title>Bob De-Obfuscates His Hop Payload</title>
<simpara>Next, Bob will generate the <literal>rho</literal> key from the Alice-Bob shared key. He will use this to generate a 2,600 byte stream, using the ChaCha20 algorithm.</simpara>
<tip>
<simpara>The first 1,300 bytes of the byte stream generated by Bob are exactly the same as those generated by Alice using the <literal>rho</literal> key.</simpara>
</tip>
<simpara>Next, Bob applies the 2,600 bytes of the <literal>rho</literal> byte stream to the 2,600-byte onion payload with a bitwise XOR operation.</simpara>
<simpara>The first 1,300 bytes will become de-obfuscated by this XOR operation, because it is the same operation Alice applied and XOR is involutory. So Bob will <emphasis>reveal</emphasis> his hop payload followed by some data that seems scrambled.</simpara>
<simpara>At the same time, applying the <literal>rho</literal> byte stream to the 1,300 zeroes that were added to the onion payload will turn them into seemingly random filler data. This operation is shown in <xref linkend="bob_deobfuscates"/>.</simpara>
<figure id="bob_deobfuscates"><title>Bob de-obfuscates the onion, obfuscates the filler</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1024.png"/>
  </imageobject>
  <textobject><phrase>Bob de-obfuscates the onion, obfuscates the filler</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_bob_extracts_the_outer_hmac_for_the_next_hop">
<title>Bob Extracts the Outer HMAC for the Next Hop</title>
<simpara>Remember that an inner HMAC is included for each hop, which will then become the outer HMAC for the <emphasis>next</emphasis> hop.
In this case, Bob extracts the inner HMAC (he&#8217;s already verified the integrity of the encrypted packet with the outer HMAC), and puts it aside because he&#8217;ll append it to the de-obfuscated packet to allow Chan to verify the HMAC of his encrypted packet.</simpara>
</section>
<section id="_bob_removes_his_payload_and_left_shifts_the_onion">
<title>Bob Removes His Payload and Left-Shifts the Onion</title>
<simpara>Now Bob can remove his hop payload from the front of the onion and left-shift the remaining data. An amount of data equal to Bob&#8217;s hop payload from the second-half 1,300 bytes of filler will now shift into the onion payload space. This is shown in <xref linkend="bob_removes_shifts"/>.</simpara>
<simpara>Now Bob can keep the first half 1,300 bytes, and discard the extended (filler) 1,300 bytes.</simpara>
<simpara>Bob now has a 1,300-byte onion packet to send to the next hop. It is almost identical to the onion payload that Alice had created for Chan, except that the last 65 or so bytes of filler was put there by Bob and will be different.</simpara>
<figure id="bob_removes_shifts"><title>Bob removes the hop payload and left-shifts the rest, filling the gap with new filler</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1025.png"/>
  </imageobject>
  <textobject><phrase>Bob removes the hop payload and left-shifts the rest, filling the gap with new filler</phrase></textobject>
</mediaobject>
</figure>
<simpara role="pagebreak-before">No one can tell the difference between filler put there by Alice and filler put there by Bob. Filler is filler! It&#8217;s all random bytes anyway. Note that if Bob (or one of Bob&#8217;s other aliases) is present in the route in two distinct locations, then they can tell the difference because the base protocol always uses the same payment hash across the entire route. Atomic multipath payments (AMPs) and Point Time-Locked Contracts (PTLCs) eliminate the correlation vector by randomizing the payment identifier across each route/hop.</simpara>
</section>
<section id="_bob_constructs_the_new_onion_packet">
<title>Bob Constructs the New Onion Packet</title>
<simpara>Bob now copies the onion payload into the onion packet, appends the outer HMAC for chan, re-randomizes the session key (the same way Alice the sender does) with the elliptic curve multiplication operation, and appends a fresh version byte.</simpara>
<simpara>To re-randomize the session key, Bob first computes the blinding factor for his hop, using his node public key and the shared secret he derived:
```
b_bob = SHA-256(P_bob || shared_secret_bob)
```</simpara>
<simpara>With this generated, Bob now re-randomizes the session key by performing an EC multiplication using his session key and the blinding factor:
```
session_key_chan = session_key_bob * b_bob
```</simpara>
<simpara>The <literal>session_key_chan</literal> public key will then be appended to the front of the onion packet for processing by Chan.</simpara>
</section>
<section id="_bob_verifies_the_htlc_details">
<title>Bob Verifies the HTLC Details</title>
<simpara>Bob&#8217;s hop payload contains the instructions needed to create an HTLC for Chan.</simpara>
<simpara>In the hop payload, Bob finds a <literal>short_channel_id</literal>, <literal>amt_to_forward</literal>, and <literal>cltv_expiry</literal>.</simpara>
<simpara>First, Bob checks to see if he has a channel with that short ID. He finds that he has such a channel with Chan.</simpara>
<simpara>Next, Bob confirms that the outgoing amount (50,100 satoshis) is less than the incoming amount (50,200 satoshis), and therefore Bob&#8217;s fee expectations are met.</simpara>
<simpara>Similarly, Bob checks that the outgoing <literal>cltv_expiry</literal> is less than the incoming <literal>cltv_expiry</literal>, giving Bob enough time to claim the incoming HTLC if there is a breach.</simpara>
</section>
<section id="_bob_sends_the_update_add_htlc_to_chan">
<title>Bob Sends the update_add_htlc to Chan</title>
<simpara>Bob now constructs and HTLC to send to Chan, as follows:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>channel_id</literal>
</term>
<listitem>
<simpara>
This field contains the Bob-Chan channel ID, which in our example is <literal>000004040a61f0</literal> (see <xref linkend="alice_dina_path_detail"/>).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>id</literal>
</term>
<listitem>
<simpara>
The ID of this HTLC in this channel, starting at <literal>0</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>amount_msat</literal>
</term>
<listitem>
<simpara>
The amount of the HTLC: 50,100,000 millisatoshis.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>payment_hash</literal>
</term>
<listitem>
<simpara>
The RIPEMD160(SHA-256) payment hash:
</simpara>
<simpara><literal>9e017f6767971ed7cea17f98528d5f5c0&#x200b;ccb2c71</literal>.</simpara>
<simpara>This is the same as the payment hash from Alice&#8217;s HTLC.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>cltv_expiry</literal>
</term>
<listitem>
<simpara>
The expiry timelock for the HTLC will be 700,038.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>onion_routing_packet</literal>
</term>
<listitem>
<simpara>
The onion packet Bob reconstructed after removing his hop payload.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_chan_forwards_the_onion">
<title>Chan Forwards the Onion</title>
<simpara>Chan repeats the exact same process as Bob:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Chan receives the <literal>update_add_htlc</literal> and processes the HTLC request, adding it to commitment transactions.
</simpara>
</listitem>
<listitem>
<simpara>
Chan generates the Alice-Chan shared key and the <literal>mu</literal> subkey.
</simpara>
</listitem>
<listitem>
<simpara>
Chan verifies the onion packet HMAC, then extracts the 1,300-byte onion <span class="keep-together">payload</span>.
</simpara>
</listitem>
<listitem>
<simpara>
Chan extends the onion payload by 1,300 extra bytes, filling it with zeroes.
</simpara>
</listitem>
<listitem>
<simpara>
Chan uses the <literal>rho</literal> key to produce 2,600 bytes.
</simpara>
</listitem>
<listitem>
<simpara>
Chan uses the generated byte stream to XOR and de-obfuscate the onion payload. Simultaneously, the XOR operation obfuscates the extra 1,300 zeroes, turning them into filler.
</simpara>
</listitem>
<listitem>
<simpara>
Chan extracts the inner HMAC in the payload, which will become the outer HMAC for Dina.
</simpara>
</listitem>
<listitem>
<simpara>
Chan removes his hop payload and left-shifts the onion payload by the same amount. Some of the filler generated in the 1,300 extended bytes moves into the first-half 1,300 bytes, becoming part of the onion payload.
</simpara>
</listitem>
<listitem>
<simpara>
Chan constructs the onion packet for Dina with this onion payload.
</simpara>
</listitem>
<listitem>
<simpara>
Chan builds an <literal>update_add_htlc</literal> message for Dina and inserts the onion packet into it.
</simpara>
</listitem>
<listitem>
<simpara>
Chan sends the <literal>update_add_htlc</literal> to Dina.
</simpara>
</listitem>
<listitem>
<simpara>
Chan re-randomizes the session key as Bob did in the prior hop for Dina.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="_dina_receives_the_final_payload">
<title>Dina Receives the Final Payload</title>
<simpara>When Dina receives the <literal>update_add_htlc</literal> message from Chan, she knows from the <literal>payment_hash</literal> that this is a payment for her. She knows she is the last hop in the onion.</simpara>
<simpara>Dina follows the exact same process as Bob and Chan to verify and unwrap the onion, except she doesn&#8217;t construct new filler and doesn&#8217;t forward anything. Instead, Dina responds to Chan with <literal>update_fulfill_htlc</literal> to redeem the HTLC. The <literal>update_fulfill_htlc</literal> will flow backward along the path until it reaches Alice. All the HTLCs are redeemed and channel balances are updated. The payment is complete!<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_returning_errors">
<title>Returning Errors</title>
<simpara><indexterm>
  <primary>error return</primary><secondary>onion routing and</secondary>
</indexterm>
<indexterm>
  <primary>onion routing and</primary>
</indexterm><indexterm>
  <primary>onion routing</primary><secondary>returning errors</secondary>
</indexterm>
<indexterm>
  <primary>returning errors</primary>
</indexterm>This far we&#8217;ve looked at the forward propagation of the onion establishing the HTLCs and the backward propagation of the payment secret unwinding the HTLCs once payment is successful.</simpara>
<simpara>There is another very important function of onion routing: <emphasis>error return</emphasis>. If there is a problem with the payment, onion, or hops, we must propagate an error backwards to inform all nodes of the failure and unwind any HTLCs.</simpara>
<simpara>Errors generally fall into three categories: onion failures, node failures, and channel failures. These furthermore may be subdivided into permanent and transient errors. Finally, some errors contain channel updates to help with future payment delivery attempts.</simpara>
<note>
<simpara>Unlike messages in the peer-to-peer (P2P) protocol (defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md">BOLT #2: Peer Protocol for Channel Management</ulink>), errors are not sent as P2P messages but are wrapped inside onion return packets and follow the reverse of the onion path (back-propagating).</simpara>
</note>
<simpara>Error return is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#returning-errors">BOLT #4: Onion Routing, Returning Errors</ulink>.</simpara>
<simpara>Errors are encoded by the returning node (the one that discovered an error) in a <emphasis>return packet</emphasis> as follows:</simpara>
<screen>    [32*byte:hmac]
    [u16:failure_len]
    [failure_len*byte:failuremsg]
    [u16:pad_len]
    [pad_len*byte:pad]</screen>
<simpara>The return packet HMAC verification checksum is calculated with the <literal>um</literal> key, generated from the shared secret established by the onion.</simpara>
<tip>
<simpara>The <literal>um</literal> key name is the reverse of the <literal>mu</literal> name, indicating the same use but in the opposite direction (back-propagation).</simpara>
</tip>
<simpara>Next, the returning node generates an <literal>ammag</literal> (inverse of the word "gamma") key and obfuscates the return packet using an XOR operation with a byte stream generated from <literal>ammag</literal>.</simpara>
<simpara>Finally the return node sends the return packet to the hop from which it received the original onion.</simpara>
<simpara>Each hop receiving an error will generate an <literal>ammag</literal> key and obfuscate the return packet again using an XOR operation with the byte stream from <literal>ammag</literal>.</simpara>
<simpara>Eventually, the sender (origin node) receives a return packet. It will then generate <literal>ammag</literal> and <literal>um</literal> keys for each hop and XOR de-obfuscate the return error iteratively until it reveals the return packet.</simpara>
<section id="failure_messages">
<title>Failure Messages</title>
<simpara><indexterm>
  <primary>error return</primary><secondary>failure messages</secondary>
</indexterm>
<indexterm>
  <primary>failure messages</primary>
</indexterm><indexterm>
  <primary>failure messages, onion routing and</primary>
</indexterm>The <literal>failuremsg</literal> is defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#failure-messages">BOLT #4: Onion Routing, Failure Messages</ulink>.</simpara>
<simpara>A failure message consists of a two-byte <literal>failure code</literal> followed by the data applicable to that failure type.</simpara>
<simpara>The top byte of the <literal>failure_code</literal> is a set of binary flags that can be combined (with binary OR):</simpara>
<variablelist>
<varlistentry>
<term>
0x8000 (<literal>BADONION</literal>)
</term>
<listitem>
<simpara>
Unparsable onion encrypted by sending peer
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
0x4000 (<literal>PERM</literal>)
</term>
<listitem>
<simpara>
Permanent failure (otherwise transient)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
0x2000 (<literal>NODE</literal>)
</term>
<listitem>
<simpara>
Node failure (otherwise channel)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
0x1000 (<literal>UPDATE</literal>)
</term>
<listitem>
<simpara>
New channel update enclosed
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The failure types shown in <xref linkend="failure_types_table"/> are currently defined.</simpara>
<table id="failure_types_table"
frame="all"
rowsep="1" colsep="1"
>
<title>Onion error failure types</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"> Type </entry>
<entry align="left" valign="top"> Symbolic name </entry>
<entry align="left" valign="top"> Meaning</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>PERM|1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>invalid_realm</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>realm</literal> byte was not understood by the processing node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NODE|2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>temporary_node_failure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>General temporary failure of the processing node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PERM|NODE|2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>permanent_node_failure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>General permanent failure of the processing node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PERM|NODE|3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>required_node_fea&#x2060;ture_&#x200b;missing</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The processing node has a required feature which was not in this onion</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>BADONION|PERM|4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>invalid_onion_version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>version</literal> byte was not understood by the processing node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>BADONION|PERM|5</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>invalid_onion_hmac</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The HMAC of the onion was incorrect when it reached the processing node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>BADONION|PERM|6</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>invalid_onion_key</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The ephemeral key was unparsable by the processing node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UPDATE|7</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>temporary_channel_&#x200b;fail&#x2060;ure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The channel from the processing node was unable to handle this HTLC,
but may be able to handle it, or others, later</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PERM|8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>permanent_channel_&#x200b;fail&#x2060;ure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The channel from the processing node is unable to handle any HTLCs</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PERM|9</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>required_channel_&#x200b;fea&#x2060;ture_missing</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The channel from the processing node requires features not present in
the onion</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PERM|10</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>unknown_next_peer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The onion specified a <literal>short_channel_id</literal> which doesn&#8217;t match any
leading from the processing node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UPDATE|11</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>amount_below_minimum</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The HTLC amount was below the <literal>htlc_minimum_msat</literal> of the channel from
the processing node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UPDATE|12</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>fee_insufficient</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The fee amount was below that required by the channel from the
processing node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UPDATE|13</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>incorrect_cltv_expiry</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>cltv_expiry</literal> does not comply with the <literal>cltv_expiry_delta</literal> required by
the channel from the processing node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UPDATE|14</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>expiry_too_soon</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The CLTV expiry is too close to the current block height for safe
handling by the processing node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PERM|15</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>incor&#x2060;rect_or_unknown_&#x200b;pay&#x2060;ment_details</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>payment_hash</literal> is unknown to the final node, the <literal>payment_secret</literal> doesn&#8217;t
match the <literal>payment_hash</literal>, the amount for that <literal>payment_hash</literal> is incorrect, or
the CLTV expiry of the HTLC is too close to the current block height for safe
handling</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>18</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>final_incor&#x2060;rect_&#x200b;cltv_expiry</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The CLTV expiry in the HTLC doesn&#8217;t match the value in the onion</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>19</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>final_incor&#x2060;rect_&#x200b;htlc_amount</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount in the HTLC doesn&#8217;t match the value in the onion</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UPDATE|20</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>channel_disabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The channel from the processing node has been disabled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>21</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>expiry_too_far</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The CLTV expiry in the HTLC is too far in the future</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PERM|22</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>invalid_onion_payload</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The decrypted onion per-hop payload was not understood by the processing node
or is incomplete</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>23</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>mpp_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The complete amount of the multipart payment was not received within a
reasonable time</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section id="stuck_payments">
<title>Stuck payments</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>stuck payments</secondary>
</indexterm>
<indexterm>
  <primary>stuck payments</primary>
</indexterm><indexterm>
  <primary>stuck payments</primary>
</indexterm>In the current implementation of the Lightning Network, there is a possibility that a payment attempt becomes <emphasis>stuck</emphasis>: neither fulfilled nor cancelled by an error. This can happen due to a bug on an intermediary node, a node going offline while handling HTLCs, or a malicious node holding HTLCs without reporting an error. In all of these cases, the HTLC cannot be resolved until it expires. The timelock (CLTV) that is set on every HTLC helps resolve this condition (among other possible HTLC routing and channel failures).</simpara>
<simpara>However, this means that the sender of the HTLC has to wait until expiry, and the funds committed to that HTLC remain unavailable until the HTLC expires. Furthermore, the sender <emphasis>cannot retry</emphasis> that same payment, because if they do, they run the risk of <emphasis>both</emphasis> the original and the retried payment succeeding—the recipient gets paid twice. This is because, once sent, an HTLC cannot be "cancelled" by the sender—it either has to fail or expire. Stuck payments, while rare, create an unwanted user experience, where the user&#8217;s wallet cannot pay or cancel a payment.</simpara>
<simpara><indexterm>
  <primary>Point Time-Locked Contract (PTLC)</primary>
</indexterm><indexterm>
  <primary>PTLC (Point Time-Locked Contract)</primary>
</indexterm><indexterm>
  <primary>stuckless payments</primary>
</indexterm>One proposed solution to this problem is called <emphasis>stuckless payments</emphasis>, and it depends on Point Time-Locked Contracts (PTLCs), which are payment contracts that use a different cryptographic primitive than HTLCs (i.e., point addition on the elliptic curve instead of a hash and secret preimage). PTLCs are cumbersome using ECDSA but much easier with Bitcoin&#8217;s Taproot and Schnorr signature features, which were recently locked in for activation in November 2021. It is expected that PTLCs will be implemented in the Lightning Network after these Bitcoin features become activated<indexterm>
</indexterm><indexterm>
</indexterm>.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
</section>
<section id="keysend">
<title>Keysend Spontaneous Payments</title>
<simpara><indexterm>
  <primary>keysend spontaneous payments</primary>
</indexterm><indexterm>
  <primary>onion routing</primary><secondary>keysend spontaneous payments</secondary>
</indexterm>
<indexterm>
  <primary>keysend spontaneous payments</primary>
</indexterm>In the payment flow described earlier in the chapter, we assumed that Dina
received an invoice from Alice "out of band," or obtained it via some mechanism
unrelated to the protocol (typically copy/paste or QR code scans). This trait
means that the payment process always takes two steps: first, the sender
obtains an invoice, and second, uses the payment hash (encoded in the invoice) to
successfully route an HTLC. The extra round trip required to obtain an invoice
before making a payment may be a bottleneck in applications that involve
streaming micropayments over Lightning. What if we could just "push" a payment
over spontaneously, without having to obtain an invoice from the recipient
first? The <literal>keysend</literal> protocol is an end-to-end extension (only the sender and
receiver are aware) to the Lightning protocol that enables spontaneous push
payments.</simpara>
<section id="_custom_onion_tlv_records">
<title>Custom Onion TLV Records</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>custom onion TLV records</secondary>
</indexterm>
<indexterm>
  <primary>custom onion TLV records</primary>
</indexterm><indexterm>
  <primary>Type-Length-Value (TLV) format</primary><secondary>custom onion TLV records</secondary>
</indexterm>
<indexterm>
  <primary>custom onion TLV records</primary>
</indexterm>The modern Lightning protocol uses the TLV (Type-Length-Value) encoding in
the onion to encode information that tells each node <emphasis>where</emphasis> and <emphasis>how</emphasis> to
forward the payment. Leveraging the TLV format, each piece of routing information
(like the next node to which to pass the HTLC) is assigned a specific type (or key)
encoded as a <literal>BigSize</literal> variable length integer (max sized as as 64-bit
integer). These "essential" (reversed values below <literal>65536</literal>) types are defined
in BOLT #4, along with the rest of the onion routing details. Onion types with a
value greater than <literal>65536</literal> are intended to be used by wallets and applications
as "custom records."</simpara>
<simpara>Custom records allow payment applications to attach additional metadata or
context to a payment as key/value pairs in the onion. Since the custom records
are included in the onion payload itself, like all other hop contents, the
records are end-to-end encrypted. As the custom records effectively consume a
portion of the fixed-size 1300-bytes onion packet, encoding each key and
value of each custom record reduces the amount of available space for encoding
the rest of the route. In practice, this means that the more onion space used for custom records, the shorter the route can be. Given that each HTLC
packet is fixed size, custom records don&#8217;t <emphasis>add</emphasis> any additional data to an
HTLC; rather, they reallocate bytes that would have been filled with random data
otherwise.</simpara>
</section>
<section id="_sending_and_receiving_keysend_payments">
<title>Sending and Receiving Keysend Payments</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>sending/receiving keysend payments</secondary>
</indexterm>
<indexterm>
  <primary>sending/receiving keysend payments</primary>
</indexterm>A <literal>keysend</literal> payment inverts the typical flow of an HTLC where the receiver
reveals a secret preimage to the sender. Instead, the sender includes the
preimage <emphasis>within</emphasis> the onion to the receiver, and routes the HTLC to the
receiver. The receiver then decrypts the onion payload, and uses the included
preimage (which <emphasis>must</emphasis> match the payment hash of the HTLC) to settle the
payment. As a result, <literal>keysend</literal> payments can be carried out without first
obtaining an invoice from the receiver, as the preimage is "pushed" over to
the receiver. A <literal>keysend</literal> payment uses a TLV custom record type of <literal>5482373484</literal>
to encode a 32-byte preimage value.</simpara>
</section>
<section id="_keysend_and_custom_records_in_lightning_applications">
<title>Keysend and Custom Records in Lightning Applications</title>
<simpara><indexterm>
  <primary>onion routing</primary><secondary>keysend and custom records in Lightning applications</secondary>
</indexterm>
<indexterm>
  <primary>keysend and custom records in Lightning applications</primary>
</indexterm>Many streaming Lightning applications use the <literal>keysend</literal> protocol to continually
stream satoshis to a destination identified by its public key in the network.
Typically, an application will also include metadata such as a
tipping/donation note or other application-level information in addition to
the <literal>keysend</literal> record.</simpara>
</section>
</section>
<section id="_conclusion_9">
<title>Conclusion</title>
<simpara>The Lightning Network&#8217;s onion routing protocol is adapted from the Sphinx protocol to better serve the needs of a payment network. As such, it offers a huge improvement in privacy and counter-surveillance compared to the public and transparent Bitcoin blockchain.<indexterm>
</indexterm></simpara>
<simpara>In <xref linkend="path_finding"/> we will see how the combination of source routing and onion routing is used by Alice to find a good path and route the payment to Dina. To find a path, Alice first needs to learn about the network topology, which is the topic of <xref linkend="gossip"/>.</simpara>
</section>
</chapter>
<chapter id="gossip">
<title>Gossip and the Channel Graph</title>
<simpara><indexterm>
  <primary>channel graph</primary>
</indexterm><indexterm>
  <primary>gossip protocol</primary>
</indexterm>In this chapter we will describe the Lightning Network&#8217;s gossip protocol and how it is used by nodes to construct and maintain a channel graph. We will also review the DNS bootstrap mechanism used to find peers to "gossip" with.</simpara>
<simpara>The "Routing fees and Gossip relaying" section is highlighted by an outline spanning the routing layer and peer-to-peer layer of <xref linkend="LN_protocol_gossip_highlight"/>.</simpara>
<figure id="LN_protocol_gossip_highlight"><title>Gossip protocol in the Lightning protocol suite</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1101.png"/>
  </imageobject>
  <textobject><phrase>Gossip protocol in the Lightning protocol suite</phrase></textobject>
</mediaobject>
</figure>
<simpara>As we&#8217;ve learned already, the Lightning Network uses a source-based onion routing protocol to deliver a payment from a sender to the recipient.
To do this, the sending node must be able to construct a path of payment channels that connects it with the recipient, as we will see in <xref linkend="path_finding"/>.
Thus, the sender has to be able to map the Lightning Network by constructing a channel graph.
The <emphasis>channel graph</emphasis> is the interconnected set of publicly advertised channels and the nodes that these channels interlink.</simpara>
<simpara>As channels are backed by a funding transaction that is happening on-chain, one might falsely believe that Lightning nodes could just extract the existing channels from the Bitcoin blockchain.
However this is only possible to a certain extent.
<indexterm>
  <primary>P2WSH (Pay-to-Witness-Script-Hash)</primary>
</indexterm><indexterm>
  <primary>Pay-to-Witness-Script-Hash (P2WSH)</primary>
</indexterm>The funding transactions are Pay-to-Witness-Script-Hash (P2WSH) addresses, and the nature of the script (a 2-of-2 multisig) will only be revealed once the funding transaction output is spent.
Even if the nature of the script were known, it&#8217;s important to remember that not all 2-of-2 multisig scripts correspond to payment channels.</simpara>
<simpara>There are even more reasons why looking at the Bitcoin blockchain might not be helpful.
For example, on the Lightning Network, the Bitcoin keys that are used for signing are rotated by the nodes for every channel and update.
Thus, even if we could reliably detect funding transactions on the Bitcoin blockchain, we would not know which two nodes on the Lightning Network own that particular channel.</simpara>
<simpara>The Lightning Network solves this problem by implementing a <emphasis>gossip protocol</emphasis>.
Gossip protocols are typical for peer-to-peer (P2P) networks and allow nodes to share information with the whole network with just a few direct connections to peers.
Lightning nodes open encrypted peer-to-peer connections to each other and share (gossip) information that they have received from other peers.
As soon as a node wants to share some information, for example, about a newly created channel, it sends a message to all its peers.
Upon receiving a message, a node decides if the received message was novel and, if so, forwards the information to its peers.
In this way, if the peer-to-peer network is well connected, all new information that is necessary for the operation of the network will eventually be propagated to all other peers.</simpara>
<simpara>Obviously, if a new peer joins the network for the first time, it needs to know some other peers on the network, so it can connect to others and participate in the network.</simpara>
<simpara>In this chapter, we&#8217;ll explore exactly <emphasis>how</emphasis> Lightning nodes discover each other, discover and update their node status, and communicate with one another.</simpara>
<simpara>When most refer to the <emphasis>network</emphasis> part of the Lightning Network, they&#8217;re referring to the <emphasis>channel graph</emphasis> which itself is a unique authenticated data structure <emphasis>anchored</emphasis> in the base Bitcoin
blockchain.</simpara>
<simpara>However, the Lightning Network is also a peer-to-peer network of nodes that gossip information about payment channels and nodes. Usually, for two peers to maintain a payment channel they need to talk to each other directly, which means that there will be a peer connection between them.
This suggests that the channel graph is a subnetwork of the peer-to-peer network.
However, this is not true because payment channels can remain open even if one or both peers go temporarily offline.</simpara>
<simpara>Let&#8217;s revisit some of the terminology that we have used throughout the book, specifically looking at what they mean in terms of the channel graph and the peer-to-peer network (see <xref linkend="network_terminology"/>).</simpara>
<table id="network_terminology"
frame="all"
rowsep="1" colsep="1"
>
<title>Terminology of the different networks</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"> Channel graph  </entry>
<entry align="left" valign="top">Peer-to-peer network</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>channel</simpara></entry>
<entry align="left" valign="top"><simpara>connection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>open</simpara></entry>
<entry align="left" valign="top"><simpara>connect</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>close</simpara></entry>
<entry align="left" valign="top"><simpara>disconnect</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>funding transaction</simpara></entry>
<entry align="left" valign="top"><simpara>encrypted TCP/IP connection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>send</simpara></entry>
<entry align="left" valign="top"><simpara>transmit</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>payment</simpara></entry>
<entry align="left" valign="top"><simpara>message</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Because the Lightning Network is a peer-to-peer network, some initial bootstrapping is required in order for peers to discover each other.  Within this chapter we&#8217;ll follow the story of a new peer connecting to the network for the first time and examine each step in the bootstrapping process, from initial peer discovery to channel graph syncing and validation.</simpara>
<simpara>As an initial step, our new node needs to somehow <emphasis>discover</emphasis> at least <emphasis>one</emphasis> peer that is already connected to the network and has a full channel graph (as we&#8217;ll see later, there&#8217;s no canonical version of the channel graph). Using one of many initial bootstrapping protocols to find that first peer, after a connection is established, our new
peer now needs to <emphasis>download</emphasis> and <emphasis>validate</emphasis> the channel graph. Once the channel graph has been fully validated, our new peer is ready to start opening channels and sending payments on the network.</simpara>
<simpara>After initial bootstrap, a node on the network needs to continue to maintain its view of the channel graph by processing new channel routing policy updates, discovering and validating new channels, removing channels that have been closed on-chain, and finally pruning channels that fail to send out a proper "heartbeat" every two weeks <span class="keep-together">or so</span>.</simpara>
<simpara>Upon completion of this chapter, you will understand a key component of
the peer-to-peer Lightning Network: namely, how peers discover each other and maintain a local copy (perspective) of the channel graph. We&#8217;ll begin by exploring the story of a new node that has just booted up and needs to find other peers to connect to on the network.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
<section id="_peer_discovery" role="pagebreak-before less_space">
<title>Peer Discovery</title>
<simpara><indexterm>
  <primary>gossip protocol</primary><secondary>peer discovery</secondary>
</indexterm>
<indexterm>
  <primary>peer discovery</primary>
</indexterm><indexterm>
  <primary>peer discovery</primary>
</indexterm>In this section, we&#8217;ll begin to follow a new Lightning node that wishes to join the network through three steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Discover a set of bootstrap peers
</simpara>
</listitem>
<listitem>
<simpara>
Download and validate the channel graph
</simpara>
</listitem>
<listitem>
<simpara>
Begin the process of ongoing maintenance of the channel graph itself
</simpara>
</listitem>
</orderedlist>
<section id="_p2p_bootstrapping">
<title>P2P Bootstrapping</title>
<simpara><indexterm>
  <primary>bootstrapping</primary><secondary>P2P</secondary>
</indexterm>
<indexterm>
  <primary>P2P</primary>
</indexterm><indexterm>
  <primary>initial peer bootstrapping</primary>
</indexterm><indexterm>
  <primary>P2P bootstrapping</primary>
</indexterm><indexterm>
  <primary>peer discovery</primary><secondary>P2P bootstrapping</secondary>
</indexterm>
<indexterm>
  <primary>P2P bootstrapping</primary>
</indexterm>Before doing any thing else, our new node first needs to discover a set of peers who are already part of the network. We call this process initial peer bootstrapping, and it&#8217;s something that every peer-to-peer network needs to implement properly to ensure a robust, healthy network.</simpara>
<simpara>Bootstrapping new peers to existing peer-to-peer networks is a very well studied problem with several known solutions, each with their own distinct trade-offs. The simplest solution to this problem is simply to package a set of <emphasis>hardcoded</emphasis> bootstrap peers into the packaged P2P node software. This is simple in that each new node has a list of bootstrap peers in the software they&#8217;re running, but rather fragile given that if the set of bootstrap peers goes offline, then no new nodes will be able to join the network. Due to this fragility, this
option is usually used as a fallback in case none of the other P2P bootstrapping mechanisms work properly.</simpara>
<simpara><indexterm>
  <primary>initial peer discovery</primary>
</indexterm>Rather than hardcoding the set of bootstrap peers within the software/binary itself, we can instead allow peers to dynamically obtain a fresh/new set of bootstrap peers they can use to join the network. We&#8217;ll call this process <emphasis>initial peer discovery</emphasis>. Typically we&#8217;ll leverage
existing internet protocols to maintain and distribute a set of bootstrapping peers. A nonexhaustive list of protocols that have been used in the past to accomplish initial peer discovery includes:</simpara>
<itemizedlist>
<listitem>
<simpara>
Domain Name Service (DNS)
</simpara>
</listitem>
<listitem>
<simpara>
Internet Relay Chat (IRC)
</simpara>
</listitem>
<listitem>
<simpara>
Hypertext Transfer Protocol (HTTP)
</simpara>
</listitem>
</itemizedlist>
<simpara>Similar to the Bitcoin protocol, the primary initial peer discovery mechanism used in the Lightning Network happens via DNS. Because initial peer discovery is a critical and universal task for the network, the process has been <emphasis>standardized</emphasis> in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/10-dns-bootstrap.md">BOLT #10: DNS Bootstrap</ulink>.</simpara>
</section>
<section id="_dns_bootstrapping">
<title>DNS Bootstrapping</title>
<simpara><indexterm>
  <primary>bootstrapping</primary><secondary>DNS</secondary>
</indexterm>
<indexterm>
  <primary>DNS</primary>
</indexterm><indexterm>
  <primary>DNS bootstrapping</primary>
</indexterm><indexterm>
  <primary>peer discovery</primary><secondary>DNS bootstrapping</secondary>
</indexterm>
<indexterm>
  <primary>DNS bootstrapping</primary>
</indexterm>The <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/10-dns-bootstrap.md">BOLT #10</ulink> document describes a standardized way of implementing peer
discovery using the DNS. Lightning&#8217;s flavor of DNS-based bootstrapping uses up to three distinct record types:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>SRV</literal> records for discovering a set of <emphasis>node public keys</emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>A</literal> records for mapping a node&#8217;s public key to its current <literal>IPv4</literal> address.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>AAA</literal> records for mapping a node&#8217;s public key to its current <literal>IPv6</literal> address.
</simpara>
</listitem>
</itemizedlist>
<simpara>Those somewhat familiar with the DNS protocol may already be familiar with the <literal>A</literal> (name to IPv4 address) and <literal>AAA</literal> (name to IPv6 address) record types, but not the <literal>SRV</literal> type. The <literal>SRV</literal> record type is used by protocols built on top of DNS to determine the <emphasis>location</emphasis> for a specified service. In our context, the service in question is a given Lightning node, and the location is its IP address. We need to use this additional record type because, unlike nodes within the Bitcoin protocol, we need both a public key <emphasis>and</emphasis> an IP address to connect to a node. As we see in <xref linkend="wire_protocol"/>, the transport encryption protocol used in the Lightning Network requires knowledge of the public key of a node before connecting, so as to implement identity hiding for nodes in the network.</simpara>
<section id="_a_new_peer_8217_s_bootstrapping_workflow">
<title>A new peer&#8217;s bootstrapping workflow</title>
<simpara>Before diving into the specifics of <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/10-dns-bootstrap.md">BOLT #10</ulink>, we&#8217;ll first outline the high-level flow of a new node that wishes to use BOLT #10 to join the network.</simpara>
<simpara>First, a node needs to identify a single DNS server or set of DNS servers that understand BOLT #10 so they can be used for P2P bootstrapping.</simpara>
<simpara>While BOLT #10 uses <emphasis>lseed.bitcoinstats.com</emphasis> as the seed server, there exists no "official" set of DNS seeds for this purpose, but each of the major implementations maintains their own DNS seed, and they cross-query each other&#8217;s seeds for redundancy purposes. In <xref linkend="dns_seeds"/> you&#8217;ll see a nonexhaustive list of some popular DNS seed servers.</simpara>
<table id="dns_seeds"
frame="all"
rowsep="1" colsep="1"
>
<title>Table of known Lightning DNS seed servers</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"> DNS server     </entry>
<entry align="left" valign="top"> Maintainer</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis>lseed.bitcoinstats.com</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Christian Decker</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>nodes.lightning.directory</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Lightning Labs (Olaoluwa Osuntokun)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>soa.nodes.lightning.directory</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Lightning Labs (Olaoluwa Osuntokun)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>lseed.darosior.ninja</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Antoine Poinsot</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>DNS seeds exist for both Bitcoin&#8217;s mainnet and testnet. For the sake
of our example, we&#8217;ll assume the existence of a valid BOLT #10 DNS seed at <emphasis>nodes.lightning.directory</emphasis>.</simpara>
<simpara>Next, our new node will issue an <literal>SRV</literal> query to obtain a set of <emphasis>candidate bootstrap peers</emphasis>. The response to our query will be a series of bech32 encoded public keys. Because DNS is a text-based protocol, we can&#8217;t send raw binary data, so an encoding scheme is required. BOLT #10 specifies a bech32 encoding due to its use in the wider Bitcoin ecosystem. The number of encoded public keys returned depends on the server returning the query, as well as all the resolvers that stand between the client and the authoritative server.</simpara>
<simpara>Using the widely available <literal>dig</literal> command-line tool, we can query the <emphasis>testnet</emphasis> version of the DNS seed mentioned previously with the following command:</simpara>
<screen>$ dig @8.8.8.8 test.nodes.lightning.directory SRV</screen>
<simpara>We use the <literal>@</literal> argument to force resolution via Google&#8217;s nameserver (with IP address 8.8.8.8) because it does not filter large SRV query responses. At the end of the command, we specify that we only want <literal>SRV</literal> records to be returned. A sample response looks something like <xref linkend="ex1101"/>.</simpara>
<example id="ex1101">
<title>Querying the DNS seed for reachable nodes</title>
<screen>$ dig @8.8.8.8 test.nodes.lightning.directory SRV

; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; @8.8.8.8 test.nodes.lightning.directory SRV
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 43610
;; flags: qr rd ra; QUERY: 1, ANSWER: 25, AUTHORITY: 0, ADDITIONAL: 1

;; QUESTION SECTION:
;test.nodes.lightning.directory.        IN      SRV

;; ANSWER SECTION:
test.nodes.lightning.directory. 59 IN   SRV     10 10 9735 <co id="CO2-1"/>
ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7.test.nodes.lightning.directory. <co id="CO2-2"/>
test.nodes.lightning.directory. 59 IN   SRV     10 10 15735 ln1qtgsl3efj8verd4z27k44xu0a59kncvsarxatahm334exgnuvwhnz8dkhx8.test.nodes.lightning.directory.

 [...]

;; Query time: 89 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Thu Dec 31 16:41:07 PST 2020</screen>
<calloutlist>
<callout arearefs="CO2-1">
<para>
TCP port number where the LN node can be reached.
</para>
</callout>
<callout arearefs="CO2-2">
<para>
Node public key (ID) encoded as a virtual domain name.
</para>
</callout>
</calloutlist>
</example>
<simpara>We&#8217;ve truncated the response for brevity and show only two of the returned responses. The responses contain a "virtual" domain name for a target node, then to the left we have the <emphasis>TCP port</emphasis> where this node can be reached. The first response uses the standard TCP port for the Lightning Network: <literal>9735</literal>. The second response uses a custom port, which is permitted by the protocol.</simpara>
<simpara>Next, we&#8217;ll attempt to obtain the other piece of information we need to connect to a node: its IP address. Before we can query for this, however, we&#8217;ll first <emphasis>decode</emphasis> the bech32 encoding of the public key from the virtual domain name:</simpara>
<screen>ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7</screen>
<simpara>Decoding this bech32 string we obtain the following valid
<literal>secp256k1</literal> public key:</simpara>
<screen>026c64f5a7f24c6f7f0e1d6ec877f23b2f672fb48967c2545f227d70636395eaf3</screen>
<simpara>Now that we have the raw public key, we&#8217;ll ask the DNS server to <emphasis>resolve</emphasis> the virtual host given so we can obtain the IP information (<literal>A</literal> record) for the node, as shown in <xref linkend="ex1102"/>.</simpara>
<div id="ex1102" data-type="example">
<h5>Obtaining the latest IP address for a node</h5>

<pre data-type="programlisting">$ dig ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7.test.nodes.lightning.directory A

; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7.test.nodes.lightning.directory A
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 41934
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7.test.nodes.lightning.directory. IN A

;; ANSWER SECTION:
ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7.test.nodes.lightning.directory. 60 IN A <em>X.X.X.X</em> <a class="co" id="comarker1" href="#c01"><img src="callouts/1.png" alt="1"/></a>

;; Query time: 83 msec
;; SERVER: 2600:1700:6971:6dd0::1#53(2600:1700:6971:6dd0::1)
;; WHEN: Thu Dec 31 16:59:22 PST 2020
;; MSG SIZE  rcvd: 138</pre>

<dl class="calloutlist">
<dt><a class="co" id="c01" href="#comarker1"><img src="callouts/1.png" alt="1"/></a></dt>
<dd><p>The DNS server returns an IP address <code><em>X.X.X.X</em></code>. We’ve replaced it with X’s in the text here so as to avoid presenting a real IP address.</p></dd>
</dl></div>
<simpara>In the preceding command, we&#8217;ve queried the server so we can obtain an IPv4 <span class="keep-together">(<code>A</code> record)</span> address for our target node (replaced by <literal><emphasis>X.X.X.X</emphasis></literal> in the preceding example). Now that we have the raw public key, IP address, and TCP port, we can connect to the node transport protocol at:</simpara>
<screen>026c64f5a7f24c6f7f0e1d6ec877f23b2f672fb48967c2545f227d70636395eaf3@X.X.X.X:9735</screen>
<simpara>Querying the current DNS <literal>A</literal> record for a given node can also be used to look up the <emphasis>latest</emphasis> set of addresses. Such queries can be used to more quickly sync the latest addressing information for a node, compared to waiting for address updates on the gossip network (see <xref linkend="node_announcement"/>).</simpara>
<simpara>At this point in our journey, our new Lightning node has found its first
peer and established its first connection! Now we can begin the second phase of new peer bootstrapping: channel graph synchronization and validation.</simpara>
<simpara>First, we&#8217;ll explore more of the intricacies of BOLT #10 itself to take a deeper look into how things work under the hood.<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_srv_query_options">
<title>SRV Query Options</title>
<simpara>The <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/10-dns-bootstrap.md">BOLT #10</ulink> standard is highly extensible due to its usage of nested
subdomains as a communication layer for additional query options. The
bootstrapping protocol allows clients to further specify the <emphasis>type</emphasis> of nodes they&#8217;re attempting to query for versus the default of receiving a random subset of nodes in the query responses.</simpara>
<simpara>The query option subdomain scheme uses a series of key-value pairs where the key itself is a <emphasis>single letter</emphasis> and the remaining set of text is the value itself. The following query types exist in the current version of the <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/10-dns-bootstrap.md">BOLT #10</ulink> standards document:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>r</literal>
</term>
<listitem>
<simpara>
The <emphasis>realm</emphasis> byte which is used to determine which chain or realm    queries should be returned for. As is, the only value for this key is <literal>0</literal> which denotes "Bitcoin."
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>a</literal>
</term>
<listitem>
<simpara>
Allows clients to filter out returned nodes based on the <emphasis>types</emphasis> of addresses they advertise. As an example, this can be used to only obtain nodes that advertise a valid IPv6 address. The value that follows this type is based on a bitfield that <emphasis>indexes</emphasis> into the set of specified address <emphasis>types</emphasis> that are defined in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md">BOLT #7</ulink>. The default value for this field is <literal>6</literal>, which represents both IPv4 and IPv6 (bits 1 and 2 are set).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>l</literal>
</term>
<listitem>
<simpara>
A valid node public key serialized in compressed format. This allows a client to query for a specified node rather than receiving a set of random nodes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>n</literal>
</term>
<listitem>
<simpara>
The number of records to return. The default value for this field is <literal>25</literal>.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>An example query with additional query options looks something like the following:</simpara>
<screen>r0.a2.n10.nodes.lightning.directory</screen>
<simpara>Breaking down the query one key-value pair at a time, we gain the following
insights:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>r0</literal>
</term>
<listitem>
<simpara>
The query targets the Bitcoin realm
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>a2</literal>
</term>
<listitem>
<simpara>
The query only wants IPv4 addresses to be returned
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>n10</literal>
</term>
<listitem>
<simpara>
The query requests
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Try some combinations of the various flags using the <literal>dig</literal> DNS command-line tool yourself<indexterm>
</indexterm><indexterm>
</indexterm>:</simpara>
<screen>dig @8.8.8.8 r0.a6.nodes.lightning.directory SRV</screen>
</section>
</section>
<section id="_the_channel_graph">
<title>The Channel Graph</title>
<simpara><indexterm>
  <primary>channel graph</primary><secondary>structure of</secondary>
</indexterm>
<indexterm>
  <primary>structure of</primary>
</indexterm>Now that our new node is able to use the DNS bootstrapping protocol to connect to its very first peer, it can start to sync the channel graph! However, before we sync the channel graph, we&#8217;ll need to learn exactly <emphasis>what</emphasis> we mean by the channel graph. In this section we&#8217;ll explore the precise <emphasis>structure</emphasis> of the channel graph and examine the unique aspects of the channel graph compared to the typical abstract "graph" data structure which is well-known/used in the field of computer science.</simpara>
<section id="_a_directed_graph">
<title>A Directed Graph</title>
<simpara><indexterm>
  <primary>channel graph</primary><secondary>directed graph</secondary>
</indexterm>
<indexterm>
  <primary>directed graph</primary>
</indexterm><indexterm>
  <primary>directed graph</primary>
</indexterm>A <emphasis>graph</emphasis> in computer science is a special data structure composed of vertices (typically referred to as nodes) and edges (also known as links). Two nodes may be connected by one or more edges. The channel graph is also <emphasis>directed</emphasis> given that a payment is able to flow in either direction over a given edge (a channel). An example of a <emphasis>directed graph</emphasis> is shown in <xref linkend="directed_graph"/>.</simpara>
<figure id="directed_graph"><title>A directed graph</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1102.png"/>
  </imageobject>
  <textobject><phrase>A directed graph</phrase></textobject>
</mediaobject>
</figure>
<simpara>In the context of the Lightning Network, our vertices are the Lightning nodes themselves, with our edges being the payment channels connecting these nodes. Because we&#8217;re concerned with <emphasis>routing payments</emphasis>, in our model a node with no edges (no payment channels) isn&#8217;t considered to be a part of the graph since it isn&#8217;t useful.</simpara>
<simpara>Because channels themselves are UTXOs (funded 2-of-2 multisig addresses), we can view the channel graph as a special subset of the Bitcoin UTXO set, on top of which we can add some additional information (the nodes, etc.) to arrive at the final overlay structure, which is the channel graph. This anchoring of fundamental components of the channel graph in the
base Bitcoin blockchain means that it&#8217;s impossible to <emphasis>fake</emphasis> a valid channel graph, which has useful properties when it comes to spam prevention as we&#8217;ll see later.</simpara>
</section>
</section>
<section id="_gossip_protocol_messages">
<title>Gossip Protocol Messages</title>
<simpara><indexterm>
  <primary>channel graph</primary><secondary>gossip protocol messages</secondary>
</indexterm>
<indexterm>
  <primary>gossip protocol messages</primary>
</indexterm><indexterm>
  <primary>gossip protocol</primary><secondary>messages</secondary>
</indexterm>
<indexterm>
  <primary>messages</primary>
</indexterm>The channel graph information is propagated across the Lightning P2P Network as three messages, which are described in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md">BOLT #7</ulink>:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>node_announcement</literal>
</term>
<listitem>
<simpara>
The vertex in our graph which communicates the public key of a node, as well as how to reach the node over the internet and some additional metadata describing the set of <emphasis>features</emphasis> the node supports.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>channel_announcement</literal>
</term>
<listitem>
<simpara>
A blockchain anchored proof of the existence of a channel between two individual nodes. Any third party can verify this proof to ensure that a <emphasis>real</emphasis> channel is actually being advertised. Similar to the <literal>node_announcement</literal>, this message also contains information describing the <emphasis>capabilities</emphasis> of the channel, which is useful when attempting to route a payment.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>channel_update</literal>
</term>
<listitem>
<simpara>
A <emphasis>pair</emphasis> of structures that describes the set of routing policies for a given channel. <literal>channel_update</literal> messages come in a <emphasis>pair</emphasis> because a channel is a directed edge, so each side of the channel is able to specify its own custom routing policy.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>It&#8217;s important to note that each component of the channel graph is <emphasis>authenticated</emphasis>, allowing a third party to ensure that the owner of a channel/update/node is actually the one sending out an update. This effectively makes the channel graph a unique type of <emphasis>authenticated data structure</emphasis> that cannot be counterfeited. For authentication, we use an <literal>secp256k1</literal> ECDSA digital signature (or a series of them) over the serialized digest of the message itself. We won&#8217;t get into the specific of the messaging framing/serialization used in the Lightning Network in this chapter, as we&#8217;ll cover that information in <xref linkend="wire_protocol"/>.</simpara>
<simpara>With the high-level structure of the channel graph laid out, we&#8217;ll now dive down into the precise structure of each of the three messages used to gossip the channel graph. We&#8217;ll also explain how one can also verify each message and component of the channel graph.</simpara>
<section id="node_announcement">
<title>The node_announcement Message</title>
<simpara><indexterm>
  <primary>gossip protocol</primary><secondary>node_announcement message</secondary>
</indexterm>
<indexterm>
  <primary>node_announcement message</primary>
</indexterm><indexterm>
  <primary>node_announcement message</primary>
</indexterm>First, we have the <literal>node_announcement</literal> message, which serves two primary
purposes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
To advertise connection information so other nodes can connect to a node either to bootstrap to the network or to attempt to establish a  new payment channel with that node.
</simpara>
</listitem>
<listitem>
<simpara>
To communicate the set of protocol-level features (capabilities) a node understands/supports. Feature negotiation between nodes allows developers to add new features independently and support them with any other node on an opt-in basis.
</simpara>
</listitem>
</orderedlist>
<simpara>Unlike channel announcements, node announcements are not anchored in
the base blockchain. Therefore, node announcements are
only considered valid if they have propagated with a corresponding channel announcement. In other words, we always reject nodes without payment channels to ensure a malicious peer can&#8217;t flood the network with bogus nodes that are not part of the channel graph.</simpara>
<section id="_the_node_announcement_message_structure">
<title>The node_announcement message structure</title>
<simpara><indexterm>
  <primary>node_announcement message</primary><secondary>structure</secondary>
</indexterm>
<indexterm>
  <primary>structure</primary>
</indexterm>The <literal>node_announcement</literal> is comprised of
the following fields:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>signature</literal>
</term>
<listitem>
<simpara>
A valid ECDSA signature that covers the serialized digest of all fields listed below. This signature must correspond to the public key of the advertised node.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>features</literal>
</term>
<listitem>
<simpara>
A bit vector that describes the set of protocol features that this node understands. We&#8217;ll cover this field in more detail in <xref linkend="feature_bits"/> on the extensibility of the Lightning protocol. At a high level, this field carries a set of bits that represent the features a node understands. As an example, a node may signal that it understands the latest channel type.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>timestamp</literal>
</term>
<listitem>
<simpara>
A Unix epoch encoded timestamp. This allows clients to enforce a partial ordering over the updates to a node&#8217;s announcement.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>node_id</literal>
</term>
<listitem>
<simpara>
The <literal>secp256k1</literal> public key that this node announcement belongs to. There can only be a single <literal>node_announcement</literal> for a given node in the channel graph at any given time. As a result, a <literal>node_announcement</literal> can supersede a prior <literal>node_announcement</literal> for the same node if it carries a higher (later) timestamp.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>rgb_color</literal>
</term>
<listitem>
<simpara>
A field that allows a node to specify an RGB color to be associated with it, often used in channel graph visualizations and node directories.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>alias</literal>
</term>
<listitem>
<simpara>
A UTF-8 string to serve as the nickname for a given node. Note that these aliases aren&#8217;t required to be globally unique, nor are they verified in any way. As a result, they should not be relied on as a form of identity—they can be easily spoofed.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>addresses</literal>
</term>
<listitem>
<simpara>
A set of public internet reachable addresses that are to be associated with a given node. In the current version of the protocol, four address types are supported: IPv4 (type: 1), IPv6 (type: 2), Tor v2 (type: 3), and Tor v3 (type: 4). In the <literal>node_announcement</literal> message, each of these address types is denoted by an integer type which is included in parenthesis after the address type.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_validating_node_announcements">
<title>Validating node announcements</title>
<simpara><indexterm>
  <primary>node_announcement message</primary><secondary>validating</secondary>
</indexterm>
<indexterm>
  <primary>validating</primary>
</indexterm>Validating an incoming <literal>node_announcement</literal> is straightforward. The following assertions should be upheld when examining a node announcement:</simpara>
<itemizedlist>
<listitem>
<simpara>
If an existing <literal>node_announcement</literal> for that node is already known, then the <literal>timestamp</literal> field of a new incoming <literal>node_announcement</literal> must be greater than the prior one.
</simpara>
</listitem>
<listitem>
<simpara>
With this constraint, we enforce a forced level of "freshness."
</simpara>
</listitem>
<listitem>
<simpara>
If no <literal>node_announcement</literal> exists for the given node, then an existing <literal>channel_announcement</literal> that references the given node (more on that later) must already exist in one&#8217;s local channel graph.
</simpara>
</listitem>
<listitem>
<simpara>
The included <literal>signature</literal> must be a valid ECDSA signature verified using the included <literal>node_id</literal> public key and the double–SHA-256 digest of the raw message encoding (minus the signature and frame header) as the message.
</simpara>
</listitem>
<listitem>
<simpara>
All included <literal>addresses</literal> must be sorted in ascending order based on their address identifier.
</simpara>
</listitem>
<listitem>
<simpara>
The included <literal>alias</literal> bytes must be a valid UTF-8 string.<indexterm>
</indexterm><indexterm>
</indexterm>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="_the_channel_announcement_message">
<title>The channel_announcement Message</title>
<simpara><indexterm>
  <primary>channel_announcement message</primary>
</indexterm><indexterm>
  <primary>gossip protocol</primary><secondary>channel_announcement message</secondary>
</indexterm>
<indexterm>
  <primary>channel_announcement message</primary>
</indexterm>Next, we have the <literal>channel_announcement</literal> message, which is used to <emphasis>announce</emphasis> a new <emphasis>public</emphasis> channel to the wider network. Note that announcing a channel is <emphasis>optional</emphasis>. A channel only needs to be announced if it is intended to be used for routing by the Lightning Network. Active routing nodes may wish to announce all their channels. However, certain nodes like mobile nodes likely don&#8217;t have the
uptime or desire to be an active routing node. As a result, these
mobile nodes (which typically use light clients to connect to the Bitcoin P2P network) instead may have purely <emphasis>unannounced</emphasis> (private) channels.</simpara>
<section id="_unannounced_private_channels">
<title>Unannounced (private) channels</title>
<simpara><indexterm>
  <primary>channel_announcement message</primary><secondary>unannounced (private) channels</secondary>
</indexterm>
<indexterm>
  <primary>unannounced (private) channels</primary>
</indexterm><indexterm>
  <primary>unannounced channels</primary>
</indexterm>An unannounced channel isn&#8217;t part of the known public channel graph, but can still be used to send/receive payments. An astute reader may now be wondering how a channel which isn&#8217;t part of the public channel graph is able to receive payments. The solution to this problem is a set of "pathfinding helpers" that we call routing hints. As we&#8217;ll see in <xref linkend="invoices"/>, invoices created by nodes with unadvertised channels will include information to help the sender route to them, assuming the node has at least a single channel with an existing public routing node.</simpara>
<simpara>Due to the existence of unadvertised channels, the <emphasis>true</emphasis> size of the channel graph (both the public and private components) is unknown.</simpara>
</section>
<section id="_locating_a_channel_on_the_bitcoin_blockchain">
<title>Locating a channel on the bitcoin blockchain</title>
<simpara><indexterm>
  <primary>blockchain</primary><secondary>locating a channel on the Bitcoin blockchain</secondary>
</indexterm>
<indexterm>
  <primary>locating a channel on the Bitcoin blockchain</primary>
</indexterm><indexterm>
  <primary>channel_announcement message</primary><secondary>locating a channel on the Bitcoin blockchain</secondary>
</indexterm>
<indexterm>
  <primary>locating a channel on the Bitcoin blockchain</primary>
</indexterm>As mentioned earlier, the channel graph is authenticated due to its usage of public key cryptography, as well as the Bitcoin blockchain as a spam prevention system. To have a node accept a new <literal>channel_announcement</literal>, the advertisement must <emphasis>prove</emphasis> that the channel actually exists in the Bitcoin blockchain. This proof system adds an up-front cost to adding a new entry to the channel graph (the on-chain fees one must pay to create the UTXO of the channel). As a result, we mitigate spam and ensure that a dishonest node on the network can&#8217;t fill up the memory of an honest node at no cost with bogus channels.</simpara>
<simpara>Given that we need to construct a proof of the existence of a channel, a
natural question that arises is: how do we "point to" or reference a given channel for the verifier? Given that a payment channel is anchored in an unspent transaction output (see <xref linkend="utxo"/>), an initial thought might be to first attempt to advertise the full outpoint (<literal>txid:index</literal>) of the channel. Given that the outpoint is globally unique and confirmed in the chain, this sounds like a good idea; however, it has a drawback: the verifier must maintain a full copy of the UTXO set to verify channels. This works fine for Bitcoin full nodes, but clients that rely on lightweight verification don&#8217;t typically maintain a full UTXO set. Because we want to ensure we can support mobile nodes in the Lightning Network, we&#8217;re forced to find another solution.</simpara>
<simpara>What if rather than referencing a channel by its UTXO, we reference it based on its "location" in the chain? To do this, we&#8217;ll need a scheme that allows us to reference a given block, then a transaction within that block, and finally a specific output created by that transaction. Such an identifier is described in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md">BOLT #7</ulink> and is referred to as a <emphasis>short channel ID</emphasis>, or <literal>scid</literal>.
The <literal>scid</literal> is used in <literal>channel_announcement</literal> (and <literal>channel_update</literal>) as well as within the onion-encrypted routing packet included within HTLCs, as we learned in <xref linkend="onion_routing"/>.</simpara>
</section>
<section id="scid">
<title>The short channel ID</title>
<simpara><indexterm>
  <primary>blockchain</primary><secondary>short channel ID</secondary>
</indexterm>
<indexterm>
  <primary>short channel ID</primary>
</indexterm>Based on the preceding information, we have three pieces of information we need to encode to uniquely reference a given channel. Because we want a compact representation, we&#8217;ll attempt to encode the information into a <emphasis>single</emphasis> integer. Our integer format of choice is an unsigned 64-bit integer, comprised of 8 bytes.</simpara>
<simpara>First, the block height. Using 3 bytes (24 bits) we can encode 16,777,216 blocks. That leaves 5 bytes for us to encode the transaction index and the output index, respectively. We&#8217;ll use the next 3
bytes to encode the transaction index <emphasis>within</emphasis> a block. This is more than enough given that it&#8217;s only possible to fix tens of thousands of transactions in a block at current block sizes. This leaves 2 bytes left for us to encode the output index of the channel within the transaction.</simpara>
<simpara>Our final <literal>scid</literal> format resembles:</simpara>
<screen>block_height (3 bytes) || transaction_index (3 bytes) || output_index (2 bytes)</screen>
<simpara>Using bit packing techniques, we first encode the most significant 3 bytes as the block height, the next 3 bytes as the transaction index, and the least significant 2 bytes as the output index of that creates the channel UTXO.</simpara>
<simpara>A short channel ID can be represented as a single integer
(<literal>695313561322258433</literal>) or as a more human friendly string: <literal>632384x1568x1</literal>. Here we see the channel was mined in block <literal>632384</literal>, was the <literal>1568</literal>th transaction in the block, with the channel output as the second (UTXOs are zero-indexed) output produced by the transaction.</simpara>
<simpara>Now that we&#8217;re able to succinctly point to a given channel funding output in the chain, we can examine the full structure of the <literal>channel_announcement</literal> message, as well as see how to verify the proof-of-existence included within the message.</simpara>
</section>
<section id="_the_channel_announcement_message_structure">
<title>The channel_announcement message structure</title>
<simpara><indexterm>
  <primary>channel_announcement message</primary><secondary>message structure</secondary>
</indexterm>
<indexterm>
  <primary>message structure</primary>
</indexterm>A <literal>channel_announcement</literal> primarily communicates two things:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
A proof that a channel exists between node A and node B with both nodes controlling the mulitsig keys in that channel output.
</simpara>
</listitem>
<listitem>
<simpara>
The set of capabilities of the channel (what types of HTLCs can it route, etc.).
</simpara>
</listitem>
</orderedlist>
<simpara>When describing the proof, we&#8217;ll typically refer to node <literal>1</literal> and node <literal>2</literal>. Out of the two nodes that a channel connects, the "first" node is the node that has a "lower" public key encoding when we compare the public key of the two nodes in compressed format hex-encoded in lexicographical order. Correspondingly, in addition to a node public key on the network, each node should also control a public key within the Bitcoin blockchain.</simpara>
<simpara>Similar to the <literal>node_announcement</literal> message, all included signatures of the <literal>channel_announcement</literal> message should be signed/verified against the raw encoding of the message (minus the header) that follows <emphasis>after</emphasis> the final signature (because it isn&#8217;t possible for a digital signature to sign itself).</simpara>
<simpara>With that said, a <literal>channel_announcement</literal> message has the following fields:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>node_signature_1</literal>
</term>
<listitem>
<simpara>
The signature of the first node over the message digest.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>node_signature_2</literal>
</term>
<listitem>
<simpara>
The signature of the second node over the message digest.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>bitcoin_signature_1</literal>
</term>
<listitem>
<simpara>
The signature of the multisig key (in the funding output) of the first node over the message digest.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>bitcoin_signature_2</literal>
</term>
<listitem>
<simpara>
The signature of the multisig key (in the funding output) of the second node over the message digest.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>features</literal>
</term>
<listitem>
<simpara>
A feature bit vector that describes the set of protocol level features supported by this channel.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>chain_hash</literal>
</term>
<listitem>
<simpara>
A 32-byte hash which is typically the genesis block hash of the blockchain (e.g., Bitcoin mainnet) the channel was opened in.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>short_channel_id</literal>
</term>
<listitem>
<simpara>
The <literal>scid</literal> that uniquely locates the given channel funding output within the blockchain.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>node_id_1</literal>
</term>
<listitem>
<simpara>
The public key of the first node in the network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>node_id_2</literal>
</term>
<listitem>
<simpara>
The public key of the second node in the network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>bitcoin_key_1</literal>
</term>
<listitem>
<simpara>
The raw multisig key for the channel funding output for the first node in the network.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>bitcoin_key_2</literal>
</term>
<listitem>
<simpara>
The raw multisig key for the channel funding output for the second node in the network.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_channel_announcement_validation">
<title>Channel announcement validation</title>
<simpara><indexterm>
  <primary>channel_announcement message</primary><secondary>validation</secondary>
</indexterm>
<indexterm>
  <primary>validation</primary>
</indexterm>Now that we know what a <literal>channel_announcement</literal> contains, we can look at how to verify the channel&#8217;s existence on-chain.</simpara>
<simpara>Armed with the information in the <literal>channel_announcement</literal>, any Lightning node (even one without a full copy of the Bitcoin blockchain) can verify the existence and authenticity of the payment channel.</simpara>
<simpara>First, the verifier will use the short channel ID to find which Bitcoin block contains the channel funding output. With the block height information, the verifier can request only that specific block from a Bitcoin node. The block can then be linked back to the genesis block by following the block header chain backward (verifying the proof-of-work), confirming that this is in fact a block belonging to the Bitcoin blockchain.</simpara>
<simpara>Next, the verifier uses the transaction index number to identify the transaction ID of the transaction containing the payment channel. Most modern Bitcoin libraries will allow indexing into the transaction of a block based on the index of the transaction within the greater block.</simpara>
<simpara>Next, the verifier uses a Bitcoin library (in the verifier&#8217;s language) to extract the relevant transaction according to its index within the block. The verifier will validate the transaction (checking that it is properly signed and produces the same transaction ID when hashed).</simpara>
<simpara>Next, the verifier will extract the Pay-to-Witness-Script-Hash (P2WSH) output referenced by the output index number of the short channel ID. This is the address of the channel funding output. Additionally, the verifier will ensure that the size of the alleged channel matches the value of the output produced at the specified output index.</simpara>
<simpara>Finally, the verifier will reconstruct the multisig script from <literal>bitcoin_key_1</literal> and <literal>bitcoin_key_2</literal> and confirm that it produces the same address as in the output.</simpara>
<simpara>The verifier has now independently verified that the payment channel in the announcement is funded and confirmed on the Bitcoin blockchain!<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_the_channel_update_message">
<title>The channel_update Message</title>
<simpara><indexterm>
  <primary>channel_update message</primary>
</indexterm><indexterm>
  <primary>gossip protocol</primary><secondary>channel_update message</secondary>
</indexterm>
<indexterm>
  <primary>channel_update message</primary>
</indexterm>The third and final message used in the gossip protocol is the <literal>channel_update</literal> message. Two of these are generated for each payment channel (one by each channel partner) announcing their routing fees, timelock expectations, and capabilities.</simpara>
<simpara>The <literal>channel_update</literal> message also contains a timestamp, allowing a node to update its routing fees and other expectations and capabilities by sending a new <literal>channel_update</literal> message with a higher (later) timestamp that supersedes any older updates.</simpara>
<simpara>The <literal>channel_update</literal> message contains the following fields:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>signature</literal>
</term>
<listitem>
<simpara>
A digital signature matching the node&#8217;s public key, to authenticate the source and integrity of the channel update
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>chain_hash</literal>
</term>
<listitem>
<simpara>
The hash of the genesis block of the chain containing the channel
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>short_channel_id</literal>
</term>
<listitem>
<simpara>
The short channel ID to identify the channel
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>timestamp</literal>
</term>
<listitem>
<simpara>
The timestamp of this update, to allow recipients to sequence updates and replace older updates
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>message_flags</literal>
</term>
<listitem>
<simpara>
A bit field indicating the presence of additional fields in the <literal>channel_update</literal> message
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>channel_flags</literal>
</term>
<listitem>
<simpara>
A bit field showing the direction of the channel and other channel options
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>cltv_expiry_delta</literal>
</term>
<listitem>
<simpara>
The timelock delta expectations of this node for routing (see <xref linkend="onion_routing"/>)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>htlc_minimum_msat</literal>
</term>
<listitem>
<simpara>
The minimum HTLC amount that will be routed
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>fee_base_msat</literal>
</term>
<listitem>
<simpara>
The base fee that will be charged for routing
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>fee_proportional_millionths</literal>
</term>
<listitem>
<simpara>
The proportional fee rate that will be charged for routing
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>htlc_maximum_msat</literal> (<literal>option_channel_htlc_max</literal>)
</term>
<listitem>
<simpara>
The maximum amount that will be routed
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>A node that receives the <literal>channel_update</literal> message can attach this metadata to the channel graph edge to enable pathfinding,  as we will see in <xref linkend="path_finding"/>.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_ongoing_channel_graph_maintenance">
<title>Ongoing Channel Graph Maintenance</title>
<simpara><indexterm>
  <primary>channel graph</primary><secondary>ongoing maintenance</secondary>
</indexterm>
<indexterm>
  <primary>ongoing maintenance</primary>
</indexterm>The construction of a channel graph is not a one-time event, but rather an ongoing activity. As a node bootstraps into the network it will start receiving "gossip," in the form of the three update messages. It will use these messages to immediately start building a validated channel graph.</simpara>
<simpara>The more information a node receives, the better its "map" of the Lightning Network becomes and the more effective it can be at pathfinding and payment delivery.</simpara>
<simpara>A node won&#8217;t only add information to the channel graph. It will also keep track of the last time a channel was updated and will delete "stale" channels that have not been updated in more than two weeks. Finally, if it sees that some node no longer has any channels, it will also remove that node.</simpara>
<simpara>The information collected from the gossip protocol is not the only information that can be stored in the channel graph. Different Lightning node implementations may attach other metadata to nodes and channels. For example, some node implementations calculate a "score" that evaluates a node&#8217;s "quality" as a routing peer. This score is used as part of pathfinding to prioritize or deprioritize paths.</simpara>
</section>
<section id="_conclusion_10">
<title>Conclusion</title>
<simpara>In this chapter, we&#8217;ve learned how Lightning nodes discover each
other, discover and update their node status, and communicate with one another. We&#8217;ve learned how channel graphs are created and maintained, and we&#8217;ve explored a few ways that the Lightning Network discourages bad actors or dishonest nodes from spamming the network.</simpara>
</section>
</chapter>
<chapter id="path_finding">
<title>Pathfinding and Payment Delivery</title>
<simpara><indexterm>
  <primary>pathfinding</primary>
</indexterm>Payment <indexterm>
  <primary>payment delivery</primary>
</indexterm>delivery on the Lightning Network depends on finding a path from the sender to the recipient, a process called <emphasis>pathfinding</emphasis>. Since the routing is done by the sender, the sender must find a suitable path to reach the destination. This path is then encoded in an onion, as we saw in <xref linkend="onion_routing"/>.</simpara>
<simpara>In this chapter we will examine the problem of pathfinding, understand how uncertainty about channel balances complicates this problem, and look at how a typical pathfinding implementation attempts to solve it.</simpara>
<section id="_pathfinding_in_the_lightning_protocol_suite">
<title>Pathfinding in the Lightning Protocol Suite</title>
<simpara><indexterm>
  <primary>Lightning Network Protocol</primary><secondary>pathfinding in</secondary>
</indexterm>
<indexterm>
  <primary>pathfinding in</primary>
</indexterm><indexterm>
  <primary>pathfinding</primary><secondary>Lightning Protocol Suite and</secondary>
</indexterm>
<indexterm>
  <primary>Lightning Protocol Suite and</primary>
</indexterm>Pathfinding, path selection, multipart payments (MPP), and the payment attempt trial-and-error loop occupy the majority of the payment layer at the top of the protocol suite.</simpara>
<simpara>These components are highlighted by an outline in the protocol suite, shown in <xref linkend="LN_protocol_pathfinding_highlight"/>.</simpara>
<figure id="LN_protocol_pathfinding_highlight"><title>Payment delivery in the Lightning protocol suite</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1201.png"/>
  </imageobject>
  <textobject><phrase>Payment delivery in the Lightning protocol suite</phrase></textobject>
</mediaobject>
</figure>
<section id="_where_is_the_bolt">
<title>Where Is the BOLT?</title>
<simpara><indexterm>
  <primary>BOLT (Basis of Lightning Technology) standards documents</primary><secondary>pathfinding and</secondary>
</indexterm>
<indexterm>
  <primary>pathfinding and</primary>
</indexterm><indexterm>
  <primary>pathfinding</primary><secondary>BOLT standard and</secondary>
</indexterm>
<indexterm>
  <primary>BOLT standard and</primary>
</indexterm>So far we&#8217;ve looked at several technologies that are part of the Lightning Network and we have seen their exact specification as part of a BOLT standard. You may be surprised to find that pathfinding is not part of the BOLTs!</simpara>
<simpara>That&#8217;s because pathfinding isn&#8217;t an activity that requires any form of coordination or interoperability between different implementations. As we&#8217;ve seen, the path is selected by the sender. Even though the routing details are specified in detail in the BOLTs, the path discovery and selection are left entirely up to the sender. So each node implementation can choose a different strategy/algorithm to find paths. In fact, the different node/client and wallet implementations can even compete and use their pathfinding algorithm as a point of differentiation.</simpara>
</section>
</section>
<section id="_pathfinding_what_problem_are_we_solving">
<title>Pathfinding: What Problem Are We Solving?</title>
<simpara><indexterm>
  <primary>pathfinding</primary><secondary>nature of problem solved by</secondary>
</indexterm>
<indexterm>
  <primary>nature of problem solved by</primary>
</indexterm>The term pathfinding may be somewhat misleading because it implies a search for <emphasis>a single path</emphasis> connecting two nodes. In the beginning, when the Lightning Network was small and not well interconnected, the problem was indeed about finding a way to join payment channels to reach the recipient.</simpara>
<simpara>But, as the Lightning Network has grown explosively, the pathfinding problem&#8217;s nature has shifted. In mid-2021, as we finish this book, the Lightning Network consists of 20,000 nodes connected by at least 55,000 public channels with an aggregate capacity of almost 2,000 BTC. A node has on average 8.8 channels, while the top 10 most connected nodes have between 400 and 2,000 channels <emphasis>each</emphasis>. A visualization of just a small subset of the LN channel graph is shown in <xref linkend="lngraph"/>.</simpara>
<figure id="lngraph"><title>A visualization of part of the Lightning Network as of July 2021</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1202.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1202.png</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara>The network visualization in <xref linkend="lngraph"/> was produced with a simple Python script you can find in code/lngraph in the book&#8217;s repository.</simpara>
</note>
<simpara>If the sender and recipient are connected to other well-connected nodes and have at least one channel with adequate capacity, there will be thousands of paths. The problem becomes selecting the <emphasis>best</emphasis> path that will succeed in payment delivery, out of a list of thousands of possible paths.</simpara>
<section id="_selecting_the_best_path">
<title>Selecting the Best Path</title>
<simpara><indexterm>
  <primary>pathfinding</primary><secondary>selecting the best path</secondary>
</indexterm>
<indexterm>
  <primary>selecting the best path</primary>
</indexterm>To select the best path, we have to first define what we mean by "best." There may be many different criteria, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>
Paths with enough liquidity. Obviously if a path doesn&#8217;t have enough liquidity to route our payment, then it is not a suitable path.
</simpara>
</listitem>
<listitem>
<simpara>
Paths with low fees. If we have several candidates, we may want to select ones with lower fees.
</simpara>
</listitem>
<listitem>
<simpara>
Paths with short timelocks. We may want to avoid locking our funds for too long and therefore select paths with shorter timelocks.
</simpara>
</listitem>
</itemizedlist>
<simpara>All of these criteria may be desirable to some extent, and selecting paths that are favorable across many dimensions is not an easy task. Optimization problems like this may be too complex to solve for the "best" solution, but often can be solved for some approximation of the optimal, which is good news because otherwise pathfinding would be an intractable problem.</simpara>
</section>
<section id="_pathfinding_in_math_and_computer_science">
<title>Pathfinding in Math and Computer Science</title>
<simpara><indexterm>
  <primary>pathfinding</primary><secondary>math and computer science</secondary>
</indexterm>
<indexterm>
  <primary>math and computer science</primary>
</indexterm>Pathfinding in the Lightning Network falls under a general category of <emphasis>graph theory</emphasis> in mathematics and the more specific category of <emphasis>graph traversal</emphasis> in computer science.</simpara>
<simpara>A network such as the Lightning Network can be represented as a mathematical construct called a <emphasis>graph</emphasis>, where <emphasis>nodes</emphasis> are connected to each other by <emphasis>edges</emphasis> (equivalent to the payment channels). <indexterm>
  <primary>directed graph</primary>
</indexterm>The Lightning Network forms a <emphasis>directed graph</emphasis> because the nodes are linked <emphasis>asymmetrically</emphasis>, since the channel balance is split between the two channel partners and the payment liquidity is different in each direction. <indexterm>
  <primary>flow network</primary>
</indexterm>A directed graph with numerical capacity constraints on its edges is called a <emphasis>flow network</emphasis>, a mathematical construct used to optimize transportation and other similar networks. Flow networks can be used as a framework when solutions need to achieve a specific flow while minimizing cost, known as the minimum cost flow problem (MCFP).</simpara>
</section>
<section id="_capacity_balance_liquidity">
<title>Capacity, Balance, Liquidity</title>
<simpara><indexterm>
  <primary>pathfinding</primary><secondary>capacity, balance, and liquidity</secondary>
</indexterm>
<indexterm>
  <primary>capacity, balance, and liquidity</primary>
</indexterm>To better understand the problem of transporting satoshis from point A to point B, we need to better define three important terms: capacity, balance, and liquidity. We use these terms to describe a payment channel&#8217;s ability to route a payment.</simpara>
<simpara>In a payment channel connecting A&#8592;&#8594;B:</simpara>
<variablelist>
<varlistentry>
<term>
Capacity
</term>
<listitem>
<simpara>
<indexterm>
  <primary>capacity, payment channel</primary>
</indexterm>This is the aggregate amount of satoshis that were funded into the 2-of-2 multisig with the funding transaction. It represents the maximum amount of value held in the channel. The channel capacity is announced by the gossip protocol and is known to nodes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Balance
</term>
<listitem>
<simpara>
<indexterm>
  <primary>balance, in payment channel</primary>
</indexterm>This is the amount of satoshis held by each channel partner that can be sent to the other channel partner. A subset of the balance of A can be sent in the direction (A&#8594;B) toward node B. A subset of the balance of B can be sent in the opposite direction (A&#8592;B).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Liquidity
</term>
<listitem>
<simpara>
<indexterm>
  <primary>liquidity</primary><secondary>in payment channel</secondary>
</indexterm>
<indexterm>
  <primary>in payment channel</primary>
</indexterm>The available (subset) balance that can actually be sent across the channel in one direction. Liquidity of A is equal to the balance of A minus the channel reserve and any pending HTLCs committed by A.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The only value known to the network (via gossip announcements) is the aggregate capacity of the channel. Some unknown portion of that capacity is distributed as each partner&#8217;s balance. Some subset of that balance is available to send across the channel in one direction:</simpara>
<ul class="simplelist">
<li>capacity = balance(A) + balance(B)</li>
<li>liquidity(A) = balance(A) – channel_reserve(A) – pending_HTLCs(A)</li>
</ul>
</section>
<section id="_uncertainty_of_balances">
<title>Uncertainty of Balances</title>
<simpara><indexterm>
  <primary>pathfinding</primary><secondary>uncertainty of balances</secondary>
</indexterm>
<indexterm>
  <primary>uncertainty of balances</primary>
</indexterm>If we knew the exact channel balances of every channel, we could compute one or more payment paths using any of the standard pathfinding algorithms taught in good computer science programs. But we don&#8217;t know the channel balances; we only know the aggregate channel capacity, which is advertised by nodes in channel announcements. In order for a payment to succeed, there must be adequate balance on the sending side of the channel. If we don&#8217;t know how the capacity is distributed between the channel partners, we don&#8217;t know if there is enough balance in the direction we are trying to send the payment.</simpara>
<simpara>Balances are not announced in channel updates for two reasons: privacy and scalability. First, announcing balances would reduce the privacy of the Lightning Network because it would allow surveillance of payment by statistical analysis of the changes in balances. Second, if nodes announced balances (globally) with every payment, the Lightning Network&#8217;s scaling would be as bad as that of on-chain Bitcoin transactions which are broadcast to all participants. Therefore, balances are not announced. To solve the pathfinding problem in the face of uncertainty of balances, we need innovative pathfinding strategies. These strategies must relate closely to the routing algorithm that is used, which is source-based onion routing where it is the responsibility of the sender to find a path through the network.</simpara>
<simpara><indexterm>
  <primary>range of liquidity</primary>
</indexterm>The uncertainty problem can be described mathematically as a <emphasis>range of liquidity</emphasis>, indicating the lower and upper bounds of liquidity based on the information that is known. Since we know the capacity of the channel and we know the channel reserve balance (the minimum allowed balance on each end), the liquidity can be defined as:</simpara>
<ul class="simplelist">
<li>min(liquidity) = channel_reserve</li>
<li>max(liquidity) = capacity – channel_reserve</li>
</ul>
<simpara role="pagebreak-before">or as a range:</simpara>
<ul class="simplelist">
<li>channel_reserve &lt;= liquidity &lt;= (capacity – channel_reserve)</li>
</ul>
<simpara>Our channel liquidity uncertainty range is the range between the minimum and maximum possible liquidity. This is unknown to the network, except the two channel partners. However, as we will see, we can use failed HTLCs returned from our payment attempts to update our liquidity estimate and reduce uncertainty. If, for example, we get an HTLC failure code that tells us that a channel cannot fulfill an HTLC that is smaller than our estimate for maximum liquidity, that means the maximum liquidity can be updated to the amount of the failed HTLC. In simpler terms, if we think the liquidity can handle an HTLC of <emphasis>N</emphasis> satoshis and we find out it fails to deliver <emphasis>M</emphasis> satoshis (where <emphasis>M</emphasis> is smaller), then we can update our estimate to <emphasis>M</emphasis>–1 as the upper bound. We tried to find the ceiling and bumped against it, so it&#8217;s lower than we thought!</simpara>
</section>
<section id="_pathfinding_complexity">
<title>Pathfinding Complexity</title>
<simpara><indexterm>
  <primary>pathfinding</primary><secondary>complexity</secondary>
</indexterm>
<indexterm>
  <primary>complexity</primary>
</indexterm>Finding a path through a graph is a problem modern computers can solve rather efficiently.
Developers mainly choose breadth-first search if the edges are all of equal weight.
In cases where the edges are not of equal weight, an algorithm based on <indexterm>
  <primary>Dijkstra&apos;s algorithm</primary>
</indexterm>Dijkstra&#8217;s algorithm is used, such as <ulink url="https://en.wikipedia.org/wiki/A*_search_algorithm">A* (pronounced "A-star")</ulink>.
In our case the weights of the edges can represent the routing fees.
Only edges with a capacity larger than the amount to be sent will be included in the search.
In this basic form, pathfinding in the Lightning Network is very simple and straightforward.</simpara>
<simpara>However, channel liquidity is unknown to the sender. This turns our easy theoretical computer science problem into a rather complex real-world problem.
We now have to solve a pathfinding problem with only partial knowledge.
For example, we suspect which edges might be able to forward a payment because their capacity seems big enough.
But we can&#8217;t be certain unless we try it out or ask the channel owners directly.
Even if we were able to ask the channel owners directly, their balance might change by the time we have asked others, computed a path, constructed an onion, and sent it along.
Not only do we have limited information but the information we have is highly dynamic and might change at any point in time without our knowledge.</simpara>
</section>
<section id="_keeping_it_simple">
<title>Keeping It Simple</title>
<simpara><indexterm>
  <primary>pathfinding</primary><secondary>simplicity</secondary>
</indexterm>
<indexterm>
  <primary>simplicity</primary>
</indexterm>The pathfinding mechanism implemented in Lightning nodes is to first create a list of candidate paths, filtered and sorted by some function. Then, the node or wallet will probe paths (by attempting to deliver a payment) in a trial-and-error loop until a path is found that successfully delivers the payment.</simpara>
<note>
<simpara>This probing is done by the Lightning node or wallet and is not directly observed by the user of the software.
However, the user might suspect that probing is taking place if the payment is not completed instantly.</simpara>
</note>
<simpara>While blind probing is not optimal and leaves ample room for improvement, it should be noted that even this simplistic strategy works surprisingly well for smaller payments and well-connected nodes.</simpara>
<simpara>Most Lightning node and wallet implementations improve on this approach by ordering/weighting the list of candidate paths. Some implementations order the candidate paths by cost (fees) or some combination of cost and capacity.<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_pathfinding_and_payment_delivery_process">
<title>Pathfinding and Payment Delivery Process</title>
<simpara><indexterm>
  <primary>pathfinding</primary><secondary>payment delivery process</secondary>
</indexterm>
<indexterm>
  <primary>payment delivery process</primary>
</indexterm><indexterm>
  <primary>payment delivery</primary><secondary>pathfinding and delivery process</secondary>
</indexterm>
<indexterm>
  <primary>pathfinding and delivery process</primary>
</indexterm>Pathfinding and payment delivery involves several steps, which we list here. Different implementations may use different algorithms and strategies, but the basic steps are likely to be very similar:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Create a <emphasis>channel graph</emphasis> from announcements and updates containing the capacity of each channel, and filter the graph, ignoring any channels with insufficient capacity for the amount we want to send.
</simpara>
</listitem>
<listitem>
<simpara>
Find paths connecting the sender to the recipient.
</simpara>
</listitem>
<listitem>
<simpara>
Order the paths by some weight (this may be part of the previous step&#8217;s <span class="keep-together">algorithm</span>).
</simpara>
</listitem>
<listitem>
<simpara>
Try each path in order until payment succeeds (the trial-and-error loop).
</simpara>
</listitem>
<listitem>
<simpara>
Optionally use the HTLC failure returns to update our graph, reducing <span class="keep-together">uncertainty</span>.
</simpara>
</listitem>
</orderedlist>
<simpara>We can group these steps into three primary activities:</simpara>
<itemizedlist>
<listitem>
<simpara>
Channel graph construction
</simpara>
</listitem>
<listitem>
<simpara>
Pathfinding (filtered and ordered by some heuristics)
</simpara>
</listitem>
<listitem>
<simpara>
Payment attempt(s)
</simpara>
</listitem>
</itemizedlist>
<simpara>These three activities can be repeated in a <emphasis>payment round</emphasis> if we use the failure returns to update the graph, or if we are doing multipart payments (see <xref linkend="mpp"/>).</simpara>
<simpara>In the next sections we will look at each of these steps in more detail, as well as more advanced payment strategies.</simpara>
</section>
<section id="_channel_graph_construction">
<title>Channel Graph Construction</title>
<simpara><indexterm>
  <primary>channel graph</primary><secondary>construction of</secondary>
</indexterm>
<indexterm>
  <primary>construction of</primary>
</indexterm><indexterm>
  <primary>pathfinding</primary><secondary>channel graph construction</secondary>
</indexterm>
<indexterm>
  <primary>channel graph construction</primary>
</indexterm>In <xref linkend="gossip"/> we covered the three main messages that nodes use in their gossip: <literal>node_announcement</literal>, <literal>channel_announcement</literal>, and <literal>channel_update</literal>. These three messages allow any node to gradually construct a "map" of the Lightning Network in the form of a <emphasis>channel graph</emphasis>. Each of these messages provides a critical piece of information for the channel graph:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>node_announcement</literal>
</term>
<listitem>
<simpara>
<indexterm>
  <primary>node_announcement message</primary>
</indexterm>This contains the information about a node on the Lightning Network, such as its node ID (public key), network address (e.g., IPv4/6 or Tor), capabilities/features, etc.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>channel_announcement</literal>
</term>
<listitem>
<simpara>
<indexterm>
  <primary>channel_announcement message</primary><secondary>channel graph and</secondary>
</indexterm>
<indexterm>
  <primary>channel graph and</primary>
</indexterm><indexterm>
  <primary>channel_update message</primary>
</indexterm>This contains the capacity and channel ID of a public (announced) channel between two nodes and proof of the channel&#8217;s existence and ownership.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>channel_update</literal>
</term>
<listitem>
<simpara>
This contains a node&#8217;s fee and timelock (CLTV) expectations for routing an outgoing (from that node&#8217;s perspective) payment over a specified channel.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>In terms of a mathematical graph, the <literal>node_announcement</literal> is the information needed to create the nodes or <emphasis>vertices</emphasis> of the graph. The <literal>channel_announcement</literal> allows us to create the <emphasis>edges</emphasis> of the graph representing the payment channels. Since each direction of the payment channel has its own balance, we create a directed graph. The <literal>channel_update</literal> allows us to incorporate fees and timelocks to set the <emphasis>cost</emphasis> or <emphasis>weight</emphasis> of the graph edges.</simpara>
<simpara>Depending on the algorithm we will use for pathfinding, we may establish a number of different cost functions for the edges of the graph.</simpara>
<simpara>For now, let&#8217;s ignore the cost function and simply establish a channel graph showing nodes and channels, using the <literal>node_announcement</literal> and <literal>channel_announcement</literal> messages.</simpara>
<simpara>In this chapter we will see how Selena attempts to find a path to pay Rashid one million satoshis. To start, Selena is constructing a channel graph using the information from Lightning Network gossip to discover nodes and channels. Selena will then explore her channel graph to find a path to send a payment to Rashid.</simpara>
<simpara>This is <emphasis>Selena&#8217;s</emphasis> channel graph. There is no such thing as <emphasis>the</emphasis> channel graph, there is only ever <emphasis>a channel graph</emphasis>, and it is always from the perspective of the node that has constructed it (see <xref linkend="map_territory_relation"/>).</simpara>
<tip>
<simpara>Selena does not contruct a channel graph only when sending a payment. Rather, Selena&#8217;s node is <emphasis>continuously</emphasis> building and updating a channel graph. From the moment Selena&#8217;s node starts and connects to any peer on the network it will participate in the gossip and use every message to learn as much as possible about the network.</simpara>
</tip>
<sidebar id="map_territory_relation">
<title>The Map-Territory Relation</title>
<simpara><indexterm>
  <primary>channel graph</primary><secondary>map–territory relation</secondary>
</indexterm>
<indexterm>
  <primary>map–territory relation</primary>
</indexterm>From Wikipedia&#8217;s <ulink url="https://en.wikipedia.org/wiki/Map%E2%80%93territory_relation">page on the Map-Territory Relation</ulink>, "The map-territory relation describes the relationship between an object and a representation of that object, as in the relation between a geographical territory and a map of it."</simpara>
<simpara>The map-territory relation is best illustrated in "Sylvie and Bruno Concluded," a short story by Lewis Carroll which describes a fictional map that is a 1:1 scale of the territory it maps, therefore having perfect accuracy but becoming completely useless as it would cover the entire territory if unfolded.</simpara>
<simpara>What does this mean for the Lightning Network? The Lightning Network is the territory, and a channel graph is a map of that territory.</simpara>
<simpara>While we could imagine a theoretical (Platonic ideal) channel graph that represents the complete, up-to-date map of the Lightning Network, such a map is simply the Lightning Network itself. Each node has its own channel graph which is constructed from announcements and is necessarily incomplete, incorrect, and out-of-date!</simpara>
<simpara>The map can never completely and accurately describe the territory.</simpara>
</sidebar>
<simpara>Selena listens to <literal>node_announcement</literal> messages and discovers four other nodes (in addition to Rashid, the intended recipient). The resulting graph represents a network of six nodes: Selena and Rashid are the sender and recipient, respectively; Alice, Bob, Xavier, and Yan are intermediary nodes. Selena&#8217;s initial graph is just a list of nodes, shown in <xref linkend="channel_graph_nodes"/>.</simpara>
<figure id="channel_graph_nodes"><title>Node announcements</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1203.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1203.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>Selena also receives seven <literal>channel_announcement</literal> messages with the corresponding channel capacities, allowing her to construct a basic "map" of the network, shown in <xref linkend="channel_graph_1"/>. (The names Alice, Bob, Selena, Xavier, Yan, and Rashid have been replaced by their initials: A, B, S, X, and R, respectively.)</simpara>
<figure id="channel_graph_1"><title>The channel graph</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1204.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1204.png</phrase></textobject>
</mediaobject>
</figure>
<section id="_uncertainty_in_the_channel_graph">
<title>Uncertainty in the channel graph</title>
<simpara><indexterm>
  <primary>channel graph</primary><secondary>uncertainty in</secondary>
</indexterm>
<indexterm>
  <primary>uncertainty in</primary>
</indexterm>As you can see from <xref linkend="channel_graph_1"/>, Selena does not know any of the balances of the channels. Her initial channel graph contains the highest level of uncertainty.</simpara>
<simpara>But wait: Selena does know <emphasis>some</emphasis> channel balances! She knows the balances of the channels that her own node has connected with other nodes. While this does not seem like much, it is in fact very important information for constructing a path—Selena knows the actual liquidity of her own channels. Let&#8217;s update the channel graph to show this information. We will use a "?" symbol to represent the unknown balances, as shown in <xref linkend="channel_graph_2"/>.</simpara>
<figure id="channel_graph_2"><title>Channel graph with known and unknown balances</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1205.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1205.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>While the "?" symbol seems ominous, a lack of certainty is not the same as complete ignorance. We can <emphasis>quantify</emphasis> the uncertainty and <emphasis>reduce</emphasis> it by updating the graph with the successful/failed HTLCs we attempt.</simpara>
<simpara>Uncertainty can be quantified, because we know the maximum and minimum possible liquidity and can calculate probabilities for smaller (more precise) ranges.</simpara>
<simpara>Once we attempt to send an HTLC, we can learn more about channel balances: if we succeed, then the balance was <emphasis>at least</emphasis> sufficient to transport the specific amount. Meanwhile if we get a "temporary channel failure" error, the most likely reason is a lack of liquidity for the specific amount.</simpara>
<tip>
<simpara>You may be thinking, "What&#8217;s the point of learning from a successful HTLC?" After all, if it succeeded we&#8217;re "done." But consider that we may be sending one part of a multipart payment. We also may be sending other single-part payments within a short time. Anything we learn about liquidity is useful for the next attempt!</simpara>
</tip>
</section>
<section id="_liquidity_uncertainty_and_probability">
<title>Liquidity Uncertainty and Probability</title>
<simpara><indexterm>
  <primary>channel graph</primary><secondary>liquidity uncertainty and probability</secondary>
</indexterm>
<indexterm>
  <primary>liquidity uncertainty and probability</primary>
</indexterm><indexterm>
  <primary>liquidity</primary><secondary>uncertainty and probability</secondary>
</indexterm>
<indexterm>
  <primary>uncertainty and probability</primary>
</indexterm>To quantify the uncertainty of a channel&#8217;s liquidity, we can apply probability theory. A basic model of the probability of payment delivery will lead to some rather obvious, but important, conclusions:</simpara>
<itemizedlist>
<listitem>
<simpara>
Smaller payments have a better chance of successful delivery across a path.
</simpara>
</listitem>
<listitem>
<simpara>
Larger capacity channels will give us a better chance of payment delivery for a specific amount.
</simpara>
</listitem>
<listitem>
<simpara>
The more channels (hops), the lower the chance of success.
</simpara>
</listitem>
</itemizedlist>
<simpara>While these may be obvious, they have important implications, especially for the use of multipart payments (see <xref linkend="mpp"/>). The math is not difficult to follow.</simpara>
<simpara>Let&#8217;s use probability theory to see how we arrived at these conclusions.</simpara>
<simpara>First, let&#8217;s posit that a channel with capacity <emphasis>c</emphasis> has liquidity on one side with an unknown value in the range of (0, <emphasis>c</emphasis>) or "range between 0 and <emphasis>c</emphasis>." For example, if the capacity is 5, then the liquidity will be in the range (0, 5). Now, from this we see that if we want to send 5 satoshis, our chance of success is only 1 in 6 (16.66%), because we will only succeed if the liquidity is exactly 5.</simpara>
<simpara>More simply, if the possible values for the liquidity are 0, 1, 2, 3, 4, and 5, only one of those six possible values will be sufficient to send our payment. To continue this example, if our payment amount was 3, then we would succeed if the liquidity was 3, 4, or 5. So our chances of success are 3 in 6 (50%). Expressed in math, the success probability function for a single channel is:</simpara>
<informalequation>
<alt><![CDATA[\[$P_c(a) = (c + 1 - a) / (c + 1)$\]]]></alt>
<mediaobject><textobject><phrase></phrase></textobject></mediaobject>
</informalequation>
<simpara>where <emphasis>a</emphasis> is the amount and <emphasis>c</emphasis> is the capacity.</simpara>
<simpara>From the equation we see that if the amount is close to 0, the probability is close to 1, whereas if the amount exceeds the capacity, the probability is zero.</simpara>
<simpara>In other words: "Smaller payments have a better chance of successful delivery" or "Larger capacity channels give us better chances of delivery for a specific amount" and "You can&#8217;t send a payment on a channel with insufficient capacity."</simpara>
<simpara>Now let&#8217;s think about the probability of success across a path made of several channels. Let&#8217;s say our first channel has a 50% chance of success (<emphasis>P</emphasis> = 0.5). Then if our second channel has a 50% chance of success (<emphasis>P</emphasis> = 0.5), it is intuitive that our overall chance is 25% (<emphasis>P</emphasis> = 0.25).</simpara>
<simpara>We can express this as an equation that calculates the probability of a payment&#8217;s success as the product of probabilities for each channel in the path(s):</simpara>
<informalequation>
<alt><![CDATA[\[$P_{payment} = \prod_{i=1}^n P_i$\]]]></alt>
<mediaobject><textobject><phrase></phrase></textobject></mediaobject>
</informalequation>
<simpara>Where <emphasis>P</emphasis><subscript><emphasis>i</emphasis></subscript> is the probability of success over one path or channel, and <emphasis>P</emphasis><subscript><emphasis>payment</emphasis></subscript> is the overall probability of a successful payment over all the paths/channels.</simpara>
<simpara>From the equation we see that since the probability of success over a single channel is always less than or equal to 1, the  probability across many channels will <emphasis>drop exponentially</emphasis>.</simpara>
<simpara>In other words, "The more channels (hops) you use, the lower the chance of success."</simpara>
<note>
<simpara>There is a lot of mathematical theory and modeling behind the uncertainty of the liquidity in the channels. Fundamental work about modeling the uncertainty intervals of the channel liquidity can be found in the paper <ulink url="https://arxiv.org/abs/2103.08576">"Security and Privacy of Lightning Network Payments with Uncertain Channel Balances"</ulink> by (coauthor of this book) Pickhardt <span class="keep-together">et al</span>.</simpara>
</note>
</section>
<section id="_fees_and_other_channel_metrics">
<title>Fees and Other Channel Metrics</title>
<simpara><indexterm>
  <primary>channel graph</primary><secondary>fees and other channel metrics</secondary>
</indexterm>
<indexterm>
  <primary>fees and other channel metrics</primary>
</indexterm><indexterm>
  <primary>fees</primary><secondary>channel graph and</secondary>
</indexterm>
<indexterm>
  <primary>channel graph and</primary>
</indexterm>Next, our sender will add information to the graph from <literal>channel_update</literal> messages received from the intermediary nodes. As a reminder, the <literal>channel_update</literal> contains a wealth of information about a channel and the expectations of one of the channel partners.</simpara>
<simpara>In <xref linkend="channel_graph_3"/> we see how Selena can update the channel graph based on <literal>channel_update</literal> messages from A, B, X, and Y. Note that the channel ID and channel direction (included in <literal>channel_flags</literal>) tell Selena which channel and which direction this update refers to. Each channel partner gossips one or more <literal>channel_update</literal> messages to announce their fee expectations and other information about the channel. For example, in the top left we see the <literal>channel_update</literal> sent by Alice for the channel A&#8212;B and the direction A-to-B. With this update, Alice tells the network how much she will charge in fees to route an HTLC to Bob over that specific channel. Bob may announce a channel update (not shown in this diagram) for the opposite direction with completely different fee expectations. Any node may send a new <literal>channel_update</literal> to change the fees or timelock expectations at any time.</simpara>
<figure id="channel_graph_3"><title>Channel graph fees and other channel metrics</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1206.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1206.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>The fee and timelock information are very important, not just as path selection metrics. As we saw in <xref linkend="onion_routing"/>, the sender needs to add up fees and timelocks (<literal>cltv_expiry_delta</literal>) at each hop to make the onion. The process of calculating fees happens from the recipient to the sender <emphasis>backward</emphasis> along the path because each intermediary hop expects an incoming HTLC with higher amount and expiry timelock than the outgoing HTLC they will send to the next hop. So, for example, if Bob wants 1,000 satoshis in fees and 30 blocks of expiry timelock delta to send a payment to Rashid, then that amount and expiry delta must be added to the HTLC <emphasis>from Alice</emphasis>.</simpara>
<simpara>It is also important to note that a channel must have liquidity that is sufficient not only for the payment amount but also for the cumulative fees of all the subsequent hops. Even though Selena&#8217;s channel to Xavier (S&#8594;X) has enough liquidity for a 1M satoshi payment, it <emphasis>does not</emphasis> have enough liquidity once we consider fees. We need to know fees because only paths that have sufficient liquidity for <emphasis>both payment and all fees</emphasis> will be considered<indexterm>
</indexterm><indexterm>
</indexterm>.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_finding_candidate_paths">
<title>Finding Candidate Paths</title>
<simpara><indexterm>
  <primary>pathfinding</primary><secondary>finding candidate paths</secondary>
</indexterm>
<indexterm>
  <primary>finding candidate paths</primary>
</indexterm>Finding a suitable path through a directed graph like this is a well-studied computer science problem (known broadly as the <emphasis>shortest path problem</emphasis>), which can be solved by a variety of algorithms depending on the desired optimization and resource constraints.</simpara>
<simpara><indexterm>
  <primary>Dijkstra&apos;s algorithm</primary>
</indexterm>The most famous algorithm solving this problem was invented by Dutch mathematician E. W. Dijkstra in 1956, known simply as <ulink url="https://en.wikipedia.org/wiki/Dijkstra&#8217;s_algorithm"><emphasis>Dijkstra&#8217;s algorithm</emphasis></ulink>. In addition to the original Dijkstra&#8217;s algorithm, there are many variations and optimizations, such as <ulink url="https://en.wikipedia.org/wiki/A*_search_algorithm">A* ("A-star")</ulink>, which is a heuristic-based algorithm.</simpara>
<simpara>As mentioned previously, the "search" must be applied <emphasis>backward</emphasis> to account for fees that are accumulated from recipient to sender. Thus, Dijkstra, A*, or some other algorithm would search for a path from the recipient to the sender, using fees, estimated liquidity, and timelock delta (or some combination) as a cost function for each hop.</simpara>
<simpara>Using one such algorithm, Selena calculates several possible paths to Rashid, sorted by shortest path:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
S&#8594;A&#8594;B&#8594;R
</simpara>
</listitem>
<listitem>
<simpara>
S&#8594;X&#8594;Y&#8594;R
</simpara>
</listitem>
<listitem>
<simpara>
S&#8594;X&#8594;B&#8594;R
</simpara>
</listitem>
<listitem>
<simpara>
S&#8594;A&#8594;B&#8594;X&#8594;Y&#8594;R
</simpara>
</listitem>
</orderedlist>
<simpara>But, as we saw previously, the channel S&#8594;X does not have enough liquidity for a 1M satoshi payment once fees are considered. So Paths 2 and 3 are not viable. That leaves Paths 1 and 4 as possible paths for the payment.</simpara>
<simpara>With two possible paths, Selena is ready to attempt delivery!</simpara>
</section>
<section id="_payment_delivery_trial_and_error_loop">
<title>Payment Delivery (Trial-and-Error Loop)</title>
<simpara>Selena&#8217;s <indexterm>
  <primary>payment delivery</primary><secondary>trial-and error loop</secondary>
</indexterm>
<indexterm>
  <primary>trial-and error loop</primary>
</indexterm><indexterm>
  <primary>trial-and error loop</primary>
</indexterm>node starts the trial-and-error loop by constructing the HTLCs, building the onion, and attempting delivery of the payment. For each attempt, there are three possible outcomes:</simpara>
<itemizedlist role="pagebreak-before">
<listitem>
<simpara>
A successful result (<literal>update_fulfill_htlc</literal>)
</simpara>
</listitem>
<listitem>
<simpara>
An error (<literal>update_fail_htlc</literal>)
</simpara>
</listitem>
<listitem>
<simpara>
A "stuck" payment with no response (neither success nor failure)
</simpara>
</listitem>
</itemizedlist>
<simpara>If the payment fails, it can be retried via a different path by updating the graph (changing a channel&#8217;s metrics) and recalculating an alternative path.</simpara>
<simpara>We looked at what happens if the payment is "stuck" in <xref linkend="stuck_payments"/>. The important detail is that a stuck payment is the worst outcome because we cannot retry with another HTLC since both (the stuck one and the retry one) might go through eventually and cause a double payment.</simpara>
<section id="_first_attempt_path_1">
<title>First Attempt (Path #1)</title>
<simpara>Selena attempts the first path (S&#8594;A&#8594;B&#8594;R). She constructs the onion and sends it, but receives a failure code from Bob&#8217;s node. Bob reports back a <literal>temporary channel failure</literal> with a <literal>channel_update</literal> identifying the channel B&#8594;R as the one that can&#8217;t deliver. This attempt is shown in <xref linkend="path_1_fail"/>.</simpara>
<figure id="path_1_fail"><title>Path #1 attempt fails</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1207.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1207.png</phrase></textobject>
</mediaobject>
</figure>
<section id="_learning_from_failure">
<title>Learning from failure</title>
<simpara>From this failure code, Selena will deduce that Bob doesn&#8217;t have enough liquidity to deliver the payment to Rashid on that channel. Importantly, this failure narrows the uncertainty of the liquidity of that channel! Previously, Selena&#8217;s node assumed that the liquidity on Bob&#8217;s side of the channel was somewhere in the range (0, 4M). Now, she can assume that the liquidity is in the range (0, 999999). Similarly, Selena can now assume that the liquidity of that channel on Rashid&#8217;s side is in the range (1M, 4M), instead of (0, 4M). Selena has learned a lot from this failure.</simpara>
</section>
</section>
<section id="_second_attempt_path_4">
<title>Second Attempt (Path #4)</title>
<simpara>Now Selena attempts the fourth candidate path (S&#8594;A&#8594;B&#8594;X&#8594;Y&#8594;R). This is a longer path and will incur more fees, but it&#8217;s now the best option for delivery of the payment.</simpara>
<simpara>Fortunately, Selena receives an <literal>update_fulfill_htlc</literal> message from Alice, indicating that the payment was successful, as shown in <xref linkend="path_4_success"/>.</simpara>
<figure id="path_4_success"><title>Path #4 attempt succeeds</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1208.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1208.png</phrase></textobject>
</mediaobject>
</figure>
<section id="_learning_from_success">
<title>Learning from success</title>
<simpara>Selena has also learned a lot from this successful payment. She now knows that all the channels on the path S&#8594;A&#8594;B&#8594;X&#8594;Y&#8594;R  had enough liquidity to deliver the payment. Furthermore, she now knows that each of these channels has moved the HTLC amount (1M &#x2b; fees) to the other end of the channel. This allows Selena to recalculate the range of liquidity on the receiving side of all the channels in that path, replacing the minimum liquidity with 1M &#x2b; fees.</simpara>
</section>
<section id="_stale_knowledge">
<title>Stale knowledge?</title>
<simpara>Selena now has a much better "map" of the Lightning Network (at least as far as these seven channels go). This knowledge will be useful for any subsequent payments that Selena attempts to make.</simpara>
<simpara>However, this knowledge becomes somewhat "stale" as the other nodes send or route payments. Selena will never see any of these payments (unless she is the sender). Even if she is involved in routing payments, the onion routing mechanism means she can only see the changes for one hop (her own channels).</simpara>
<simpara>Therefore, Selena&#8217;s node must consider how long to keep this knowledge before assuming that it is stale and no longer useful<indexterm>
</indexterm><indexterm>
</indexterm>.</simpara>
</section>
</section>
</section>
<section id="mpp">
<title>Multipart Payments</title>
<simpara><indexterm>
  <primary>multipart payments (MPP)</primary>
</indexterm><indexterm>
  <primary>payment delivery</primary><secondary>multipart payments</secondary>
</indexterm>
<indexterm>
  <primary>multipart payments</primary>
</indexterm><emphasis>Multipart payments (MPP)</emphasis> are a feature that was introduced in the Lightning Network in 2020 and are already very widely available. Multipart payments allow a payment to be split into multiple <emphasis>parts</emphasis> which are sent as HTLCs over several different paths to the intended recipient, preserving the <emphasis>atomicity</emphasis> of the overall payment. In this context, atomicity means that either all the HTLC parts of a payment are eventually fulfilled or the  entire payment fails and all the HTLC parts fail. There is no possibility of a partially successful payment.</simpara>
<simpara>Multipart payments are a significant improvement in the Lightning Network because they make it possible to send amounts that won&#8217;t "fit" in any single channel by splitting them into smaller amounts for which there is sufficient liquidity. Furthermore, multipart payments have been shown to increase the probability of a successful payment, as compared to a single-path payment.</simpara>
<tip>
<simpara>Now that MPP is available, it is best to think of a single-path payment as a subcategory of an MPP. Essentially, a single-path is just a multipart of size one. All payments can be considered as multipart payments unless the size of the payment and liquidity available make it possible to deliver with a single part.</simpara>
</tip>
<section id="_using_mpp">
<title>Using MPP</title>
<simpara>MPP is not something that a user will select, but rather it is a node pathfinding and payment delivery strategy. The same basic steps are implemented: create a graph, select paths, and the trial-and-error loop. The difference is that during path selection we must also consider how to split the payment to optimize delivery.</simpara>
<simpara>In our example we can see some immediate improvements to our pathfinding problem that become possible with MPP. First, we can utilize the S&#8594;X channel that has known insufficient liquidity to transport 1M satoshis plus fees. By sending a smaller part along that channel, we can use paths that were previously unavailable. Second, we have the unknown liquidity of the B&#8594;R channel, which is insufficient to transport the 1M amount, but might be sufficient to transport a smaller amount.</simpara>
<section id="_splitting_payments">
<title>Splitting payments</title>
<simpara><indexterm>
  <primary>multipart payments (MPP)</primary><secondary>splitting payments</secondary>
</indexterm>
<indexterm>
  <primary>splitting payments</primary>
</indexterm><indexterm>
  <primary>payment</primary><secondary>splitting</secondary>
</indexterm>
<indexterm>
  <primary>splitting</primary>
</indexterm>The fundamental question is how to split the payments. More specifically, what are the optimal number of splits and the optimal amounts for each split?</simpara>
<simpara>This is an area of ongoing research where novel strategies are emerging. Multipart payments lead to a different algorithmic approach than single-path payments, even though single-path solutions can emerge from a multipart optimization (i.e., a single path may be the optimal solution suggested by a multipart pathfinding algorithm).</simpara>
<simpara>If you recall, we found that the uncertainty of liquidity/balances leads to some (somewhat obvious) conclusions that we can apply in MPP pathfinding, namely:</simpara>
<itemizedlist>
<listitem>
<simpara>
Smaller payments have a higher chance of succeeding.
</simpara>
</listitem>
<listitem>
<simpara>
The more channels you use, the chance of success becomes (exponentially) lower.
</simpara>
</listitem>
</itemizedlist>
<simpara>From the first of these insights, we might conclude that splitting a large payment (e.g., 1 million satoshis) into tiny payments increases the chance that each of those smaller payments will succeed. The number of possible paths with sufficient liquidity will be greater if we send smaller amounts.</simpara>
<simpara>To take this idea to an extreme, why not split the 1M satoshi payment into one million separate one-satoshi parts? Well, the answer lies in our second insight: since we would be using more channels/paths to send our million single-satoshi HTLCs, our chance of success would drop exponentially.</simpara>
<simpara>If it&#8217;s not obvious, the two preceding insights create a "sweet spot" where we can maximize our chances of success: splitting into smaller payments but not too many splits!</simpara>
<simpara>Quantifying this optimal balance of size/number of splits for a given channel graph is out of the scope of this book, but it is an active area of research. Some current implementations use a very simple strategy of splitting the payment in two halves, four quarters, etc.</simpara>
<note>
<simpara>To read more about the optimization problem known as minimum-cost flows involved when splitting payments into different sizes and allocating them to paths, see the paper <ulink url="https://arxiv.org/abs/2107.05322">"Optimally Reliable &amp; Cheap Payment Flows on the Lightning Network"</ulink> by (coauthor of this book) René Pickhardt and Stefan Richter.</simpara>
</note>
<simpara>In our example, Selena&#8217;s node will attempt to split the 1M satoshi payment into 2 parts with 600k and 400k satoshi, respectively, and send them on 2 different paths. This is shown in <xref linkend="mpp_paths"/>.</simpara>
<simpara>Because the S&#8594;X channel can now be utilized, and (luckily for Selena), the B&#8594;R channel has sufficient liquidity for 600k satoshis, the 2 parts are successful along paths that were previously not possible.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
<figure id="mpp_paths"><title>Sending two parts of a multipart payment</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1209.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1209.png</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section id="_trial_and_error_over_multiple_rounds">
<title>Trial and Error over Multiple "Rounds"</title>
<simpara><indexterm>
  <primary>multipart payments (MPP)</primary><secondary>trial-and error over multiple rounds</secondary>
</indexterm>
<indexterm>
  <primary>trial-and error over multiple rounds</primary>
</indexterm><indexterm>
  <primary>payment delivery</primary><secondary>trial-and error loop</secondary>
</indexterm>
<indexterm>
  <primary>trial-and error loop</primary>
</indexterm><indexterm>
  <primary>trial-and error loop</primary>
</indexterm>Multipart payments lead to a somewhat modified trial-and-error loop for payment delivery. Because we are attempting multiple paths in each attempt, we have four possible outcomes:</simpara>
<itemizedlist>
<listitem>
<simpara>
All parts succeed, the payment is successful
</simpara>
</listitem>
<listitem>
<simpara>
Some parts succeed, some fail with errors returned
</simpara>
</listitem>
<listitem>
<simpara>
All parts fail with errors returned
</simpara>
</listitem>
<listitem>
<simpara>
Some parts are "stuck," no errors are returned
</simpara>
</listitem>
</itemizedlist>
<simpara>In the second case, where some parts fail with errors returned and some parts succeed, we can now <emphasis>repeat</emphasis> the trial-and-error loop, but <emphasis>only for the residual amount</emphasis>.</simpara>
<simpara>Let&#8217;s assume for example that Selena had a much larger channel graph with hundreds of possible paths to reach Rashid. Her pathfinding algorithm might find an optimal payment split consisting of 26 parts of varying sizes. After attempting to send all 26 parts in the first round, 3 of those parts failed with errors.</simpara>
<simpara>If those 3 parts consisted of, say 155k satoshis, then Selena would restart the pathfinding effort, only for 155k satoshis. The next round could find completely different paths (optimized for the residual amount of 155k), and split the 155k amount into completely different splits!</simpara>
<tip>
<simpara>While it seems like 26 split parts are a lot, tests on the Lightning Network have successfully delivered a payment of 0.3679 BTC by splitting it into 345 parts.</simpara>
</tip>
<simpara>Furthermore, Selena&#8217;s node would update the channel graph using the information gleaned from the successes and errors of the first round to find the most optimal paths and splits for the second round.</simpara>
<simpara>Let&#8217;s say that Selena&#8217;s node calculates that the best way to send the 155k residual is 6 parts split as 80k, 42k, 15k, 11k, 6.5k, and 500 satoshis. In the next round, Selena gets only one error, indicating that the 11k satoshi part failed. Again, Selena updates the channel graph based on the information gleaned and runs the pathfinding again to send the 11k residual. This time, she succeeds with 2 parts of 6k and 5k satoshis, respectively.</simpara>
<simpara>This multiround example of sending a payment using MPP is shown in <xref linkend="mpp_rounds"/>.</simpara>
<figure id="mpp_rounds"><title>Sending a payment in multiple rounds with MPP</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1210.png"/>
  </imageobject>
  <textobject><phrase>images/mtln_1210.png</phrase></textobject>
</mediaobject>
</figure>
<simpara>In the end, Selena&#8217;s node used 3 rounds of pathfinding to send the 1M satoshis in 30 parts.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_conclusion_11">
<title>Conclusion</title>
<simpara>In this chapter we looked at pathfinding and payment delivery. We saw how to use the channel graph to find paths from a sender to a recipient. We also saw how the sender will attempt to deliver payments on a candidate path and repeat in a trial-and-error loop.</simpara>
<simpara>We also examined the uncertainty of channel liquidity (from the perspective of the sender) and the implications that has for pathfinding. We saw how we can quantify the uncertainty and use probability theory to draw some useful conclusions. We also saw how we can reduce uncertainty by learning from both successful and failed payments.</simpara>
<simpara>Finally, we saw how the newly deployed multipart payments feature allows us to split payments into parts, increasing the probability of success even for larger payments<indexterm>
</indexterm>.<indexterm>
</indexterm></simpara>
</section>
</chapter>
<chapter id="wire_protocol">
<title>Wire Protocol: Framing and Extensibility</title>
<simpara><indexterm>
  <primary>wire protocol</primary>
</indexterm>In this chapter, we dive into the wire protocol of the Lightning Network
and also cover all the various extensibility levers that have been built into
the protocol. By the end of this chapter, an ambitious reader should be able to
write their very own wire protocol parser for the Lightning Network. In addition
to being able to write a custom wire protocol parser, a reader of this chapter
will gain a deep understanding of the various upgrade mechanisms
that have been built into the protocol.</simpara>
<section id="_messaging_layer_in_the_lightning_protocol_suite">
<title>Messaging Layer in the Lightning Protocol Suite</title>
<simpara><indexterm>
  <primary>Lightning Network Protocol</primary><secondary>messaging layer</secondary>
</indexterm>
<indexterm>
  <primary>messaging layer</primary>
</indexterm><indexterm>
  <primary>wire protocol</primary><secondary>messaging layer in the Lightning Protocol Suite</secondary>
</indexterm>
<indexterm>
  <primary>messaging layer in the Lightning Protocol Suite</primary>
</indexterm>The messaging layer, which is detailed in this chapter, consists of "Framing and message format," "Type-Length-Value" encoding, and "Feature bits." These components are highlighted by an outline in the protocol suite, shown in <xref linkend="LN_protocol_wire_message_highlight"/>.</simpara>
<figure id="LN_protocol_wire_message_highlight"><title>Messaging layer in the Lightning protocol suite</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1301.png"/>
  </imageobject>
  <textobject><phrase>Messaging layer in the Lightning protocol suite</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_wire_framing">
<title>Wire Framing</title>
<simpara><indexterm>
  <primary>wire framing</primary>
</indexterm><indexterm>
  <primary>wire protocol</primary><secondary>wire framing</secondary>
</indexterm>
<indexterm>
  <primary>wire framing</primary>
</indexterm>We begin by describing the high-level structure of the wire <emphasis>framing</emphasis>
within the protocol. When we say framing, we mean the way that the bytes are
packed on the wire to <emphasis>encode</emphasis> a particular protocol message. Without knowledge
of the framing system used in the protocol, a string of bytes on the wire would
resemble a series of random bytes because no structure has been imposed. By applying
proper framing to decode these bytes on the wire, we&#8217;ll be able to extract
structure and finally parse this structure into protocol messages within our
higher-level language.</simpara>
<simpara>It&#8217;s important to note that the Lightning Network is an <emphasis>end-to-end
encrypted</emphasis> protocol, and the wire framing is itself encapsulated within an
<emphasis>encrypted</emphasis> message transport layer. As we see in <xref linkend="encrypted_message_transport"/>, the Lightning
Network uses a custom variant of the Noise Protocol to handle
transport encryption. Within this chapter, whenever we give an example of wire
framing, we assume the encryption layer has already been stripped away (when
decoding), or that we haven&#8217;t yet encrypted the set of bytes before we send
them on the wire (encoding).</simpara>
<section id="_high_level_wire_framing">
<title>High-Level Wire Framing</title>
<simpara><indexterm>
  <primary>wire framing</primary><secondary>high-level schema</secondary>
</indexterm>
<indexterm>
  <primary>high-level schema</primary>
</indexterm>With that said, we&#8217;re ready to describe the high-level schema used to
encode messages on the wire:</simpara>
<itemizedlist>
<listitem>
<simpara>
Messages on the wire begin with a <emphasis>2-byte</emphasis> type field, followed by a
    message payload.
</simpara>
</listitem>
<listitem>
<simpara>
The message payload itself can be up to 65 KB in size.
</simpara>
</listitem>
<listitem>
<simpara>
All integers are encoded in big-endian (network order).
</simpara>
</listitem>
<listitem>
<simpara>
Any bytes that follow after a defined message can be safely ignored.
</simpara>
</listitem>
</itemizedlist>
<simpara>Yep, that&#8217;s it. As the protocol relies on an <emphasis>encapsulating</emphasis> transport protocol
encryption layer, we don&#8217;t need an explicit length for each message type. This
is due to the fact that transport encryption works at the <emphasis>message</emphasis> level, so
by the time we&#8217;re ready to decode the next message, we already know the total
number of bytes of the message itself. Using 2 bytes for the message type
(encoded in big-endian) means that the protocol can have up to 2^16 – 1 or
65,535 distinct messages. Continuing, because we know all messages must be less than
65 KB, this simplifies our parsing as we can use a <emphasis>fixed-size</emphasis> buffer and
maintain strong bounds on the total amount of memory required to parse an
incoming wire message.</simpara>
<simpara>The final bullet point allows for a degree of <emphasis>backward</emphasis> compatibility  because new nodes are able to provide information in the wire messages that older nodes
(which may not understand them) can safely ignore. As we see subsequently, this
feature, combined with a very flexible wire message extensibility format, allows the protocol to achieve <emphasis>forward</emphasis> compatibility as well.</simpara>
</section>
<section id="_type_encoding">
<title>Type Encoding</title>
<simpara><indexterm>
  <primary>wire framing</primary><secondary>type encoding</secondary>
</indexterm>
<indexterm>
  <primary>type encoding</primary>
</indexterm>With this high-level background provided, we now start at the most primitive
layer: parsing primitive types. In addition to encoding integers, the Lightning
Protocol also allows for encoding of a vast array of types, including variable-length byte slices, elliptic curve public keys, Bitcoin addresses, and
signatures. When we describe the <emphasis>structure</emphasis> of wire messages later in this
chapter, we refer to the high-level type (the abstract type) rather than the
lower-level representation of said type. In this section, we peel back this
abstraction layer to ensure that our future wire parser is able to properly
encode/decode any of the higher-level types.</simpara>
<simpara>In <xref linkend="message_types"/>, we map the name of a given message type to the
high-level routine used to encode/decode the type.</simpara>
<table id="message_types"
frame="all"
rowsep="1" colsep="1"
>
<title>High-level message types</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"> High-level type </entry>
<entry align="left" valign="top"> Framing </entry>
<entry align="left" valign="top"> Comment</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>node_alias</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A 32-byte fixed-length byte slice</simpara></entry>
<entry align="left" valign="top"><simpara>When decoding, reject if contents are not a valid UTF-8 string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>channel_id</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A 32-byte fixed-length byte slice that maps an outpoint to a 32-byte value</simpara></entry>
<entry align="left" valign="top"><simpara>Given an outpoint, one can convert it to a <literal>channel_id</literal> by taking the TxID of the outpoint and XORing it with the index (interpreted as the lower 2 bytes)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>short_chan_id</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An unsigned 64-bit integer (<literal>uint64</literal>)</simpara></entry>
<entry align="left" valign="top"><simpara>Composed of the block height (24 bits), transaction index (24 bits), and output index (16 bits) packed into 8 bytes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>milli_satoshi</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An unsigned 64-bit integer (<literal>uint64</literal>)</simpara></entry>
<entry align="left" valign="top"><simpara>Represents 1000th of a satoshi</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>satoshi</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An unsigned 64-bit integer (<literal>uint64</literal>)</simpara></entry>
<entry align="left" valign="top"><simpara>The base unit of bitcoin</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pubkey</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An secp256k1 public key encoded in <emphasis>compressed</emphasis> format, occupying 33 bytes</simpara></entry>
<entry align="left" valign="top"><simpara>Occupies a fixed 33-byte length on the wire</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>sig</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An ECDSA signature of the secp256k1 elliptic curve</simpara></entry>
<entry align="left" valign="top"><simpara>Encoded as a <emphasis>fixed</emphasis> 64-byte byte slice, packed as <literal>R || S</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>uint8</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An 8-bit integer</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>uint16</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A 16-bit integer</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>uint64</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A 64-bit integer</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>[]byte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A variable-length byte slice</simpara></entry>
<entry align="left" valign="top"><simpara>Prefixed with a 16-bit integer denoting the length of the bytes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>color_rgb</literal></simpara></entry>
<entry align="left" valign="top"><simpara>RGB color encoding</simpara></entry>
<entry align="left" valign="top"><simpara>Encoded as a series of 8-bit integers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net_addr</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The encoding of a network address</simpara></entry>
<entry align="left" valign="top"><simpara>Encoded with a 1-byte prefix that denotes the type of address, followed by the address body</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>In the next section, we describe the structure of each wire message,
including the prefix type of the message along with the contents of its message
body.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="tlv_message_extensions">
<title>Type-Length-Value Message Extensions</title>
<simpara><indexterm>
  <primary>Type-Length-Value (TLV) message extensions</primary><secondary>message extensions in wire protocol</secondary>
</indexterm>
<indexterm>
  <primary>message extensions in wire protocol</primary>
</indexterm><indexterm>
  <primary>wire protocol</primary><secondary>TLV message extensions</secondary>
</indexterm>
<indexterm>
  <primary>TLV message extensions</primary>
</indexterm>Earlier in this chapter we mentioned that messages can be up to 65 KB in size,
and if while parsing a message, extra bytes are left over, then those bytes
are to be ignored. At an initial glance, this requirement may appear to be
somewhat arbitrary; however, this requirement allows for decoupled desynchronized evolution of the Lightning
Protocol itself. We discuss this more toward the end of the chapter. But first, we turn our attention to exactly what those "extra bytes" at
the end of a message can be used for.</simpara>
<section id="_the_protocol_buffers_message_format">
<title>The Protocol Buffers Message Format</title>
<simpara><indexterm>
  <primary>Protocol Buffers (Protobuf) message serialization format</primary>
</indexterm><indexterm>
  <primary>Type-Length-Value (TLV) message extensions</primary><secondary>Protocol Buffers message format</secondary>
</indexterm>
<indexterm>
  <primary>Protocol Buffers message format</primary>
</indexterm>The Protocol Buffers (Protobuf) message serialization format started out as an
internal format used at Google and has blossomed into one of the most popular
message serialization formats used by developers globally. The Protobuf format
describes how a message (usually some sort of data structure related to an API)
is encoded on the wire and decoded on the other end. Several "Protobuf
compilers" exists in dozens of languages which act as a bridge that allows any
language to encode a Protobuf that will be able to decode by a compliant decode
in another language. Such cross-language data structure compatibility allows
for a wide range of innovation because it&#8217;s possible to transmit structure and even
typed data structures across language and abstraction boundaries.</simpara>
<simpara>Protobufs are also known for their flexibility with respect to how they
handle changes in the underlying messages structure. As long as the field
numbering schema is adhered to, then it&#8217;s possible for a newer write of
Protobufs to include information within a Protobuf that may be unknown to any
older readers. When the old reader encounters the new serialized format, if
there are types/fields that it doesn&#8217;t understand, then it simply <emphasis>ignores</emphasis>
them. This allows old clients and new clients to coexist because all clients can
parse some portion of the newer message format.</simpara>
</section>
<section id="_forward_and_backward_compatibility">
<title>Forward and Backward Compatibility</title>
<simpara><indexterm>
  <primary>Protocol Buffers (Protobuf) message serialization format</primary>
</indexterm><indexterm>
  <primary>Type-Length-Value (TLV) message extensions</primary><secondary>forward/backward compatibility</secondary>
</indexterm>
<indexterm>
  <primary>forward/backward compatibility</primary>
</indexterm>Protobufs are extremely popular amongst developers because they have built-in
support for both forward and backward compatibility. Most developers are
likely familiar with the concept of backward compatibility. In simple terms,
the principle states that any changes to a message format or API should be
done in a manner that doesn&#8217;t break support for older clients. Within our preceding Protobuf extensibility examples, backward compatibility is achieved by
ensuring that new additions to the Protobuf format don&#8217;t break the known portions
of older readers. Forward compatibility, on the other hand, is just as important
for desynchronized updates; however, it&#8217;s less commonly known. For a change to
be forward compatible, clients are to simply ignore any information
they don&#8217;t understand. The soft fork mechanism of upgrading the Bitcoin
consensus system can be said to be both forward and backward compatible: any
clients that don&#8217;t update can still use Bitcoin, and if they encounter any
transactions they don&#8217;t understand, then they simply ignore them as their funds
aren&#8217;t using those new features.</simpara>
</section>
</section>
<section id="tlv">
<title>Type-Length-Value Format</title>
<simpara><indexterm>
  <primary>Type-Length-Value (TLV) format</primary>
</indexterm><indexterm>
  <primary>Type-Length-Value (TLV) format</primary><secondary>wire protocol and</secondary>
</indexterm>
<indexterm>
  <primary>wire protocol and</primary>
</indexterm><indexterm>
  <primary>wire protocol</primary><secondary>TLV format</secondary>
</indexterm>
<indexterm>
  <primary>TLV format</primary>
</indexterm>To be able to upgrade messages in a manner that is both forward and backward
compatible, in addition to feature bits (more on that later), the Lightning Network utilizes a custom message serialization format plainly called Type-Length-Value, or TLV for short. The format was inspired by the widely used Protobuf
format and borrows many concepts by significantly simplifying the
implementation as well as the software that interacts with message parsing. A
curious reader might ask, "why not just use Protobufs?" In response, the
Lightning developers would respond that we&#8217;re able to have the best of the
extensibility of Protobufs while also having the benefit of a smaller
implementation and thus smaller attack. As of version 3.15.6, the Protobuf
compiler weighs in at over 656,671 lines of code.  In comparison, LND&#8217;s
implementation of the TLV message format weighs in at only 2.3k lines of code
(including tests).</simpara>
<simpara>With the necessary background presented, we&#8217;re now ready to describe the TLV
format in detail. A TLV message extension is said to be a stream of
individual <span class="keep-together">TLV records</span>. A single TLV record has three components: the type of
the record, the length of the record, and finally the opaque value of the
record:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>type</literal>
</term>
<listitem>
<simpara>
An integer representing the name of the record being encoded
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>length</literal>
</term>
<listitem>
<simpara>
The length of the record
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>value</literal>
</term>
<listitem>
<simpara>
The opaque value of the record
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Both the <literal>type</literal> and <literal>length</literal> are encoded using a variable-sized integer that&#8217;s inspired by the variable-sized integer (varint) used in Bitcoin&#8217;s P2P protocol, called <literal>BigSize</literal> for short.</simpara>
<section id="_bigsize_integer_encoding">
<title>BigSize Integer Encoding</title>
<simpara><indexterm>
  <primary>BigSize integer encoding</primary>
</indexterm><indexterm>
  <primary>Type-Length-Value (TLV) format</primary><secondary>BigSize integer encoding</secondary>
</indexterm>
<indexterm>
  <primary>BigSize integer encoding</primary>
</indexterm>In its fullest form, a <literal>BigSize</literal>
integer can represent value up to 64 bits. In contrast to Bitcoin&#8217;s varint
format, the <literal>BigSize</literal> format instead encodes integers using a big-endian byte
ordering.</simpara>
<simpara>The <literal>BigSize</literal> varint has two components: the discriminant and the body. In the
context of the <literal>BigSize</literal> integer, the discriminant communicates to the decoder
the size of the variable-sized integer that follows. Remember that the unique thing about
variable-sized integers is that they allow a parser to use fewer bytes to encode
smaller integers than larger ones, saving space. Encoding of a <literal>BigSize</literal>
integer follows one of the four following options:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
If the value is less than <literal>0xfd</literal> (<literal>253</literal>): Then the discriminant isn&#8217;t really used, and the encoding is simply the integer itself. This allows us to encode very small integers with no additional overhead.
</simpara>
</listitem>
<listitem>
<simpara>
If the value is less than or equal to <literal>0xffff</literal> (<literal>65535</literal>): The discriminant is encoded as <literal>0xfd</literal>, which indicates that the value that follows is larger than <literal>0xfd</literal>, but smaller than <literal>0xffff</literal>. The number is then encoded as a 16-bit integer. Including the discriminant, we can encode a value that is greater than 253, but less than 65,535 using 3 bytes.
</simpara>
</listitem>
<listitem>
<simpara>
If the value is less than <literal>0xffffffff</literal> (<literal>4294967295</literal>): The discriminant is encoded as <literal>0xfe</literal>. The body is encoded using a 32-bit integer, including the discriminant, and we can encode a value that&#8217;s less than <literal>4,294,967,295</literal> using 5 bytes.
</simpara>
</listitem>
<listitem>
<simpara>
Otherwise, we just encode the value as a full-size 64-bit integer.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="_tlv_encoding_constraints">
<title>TLV Encoding Constraints</title>
<simpara><indexterm>
  <primary>Type-Length-Value (TLV) format</primary><secondary>encoding constraints</secondary>
</indexterm>
<indexterm>
  <primary>encoding constraints</primary>
</indexterm>Within the context of a TLV message, record types below <literal>2^16</literal> are said to be <emphasis>reserved</emphasis> for future use. Types beyond this
range are to be used for "custom" message extensions used by higher-level application protocols.</simpara>
<simpara>The <literal>value</literal> of a record depends on the <literal>type</literal>. In other words, it can take any form because parsers will attempt to interpret it depending on the context of the type itself.</simpara>
</section>
<section id="_tlv_canonical_encoding">
<title>TLV Canonical Encoding</title>
<simpara>One issue with the Protobuf format is that encodings of the same message may
output an entirely different set of bytes when encoded by two different
versions of the compiler. Such instances of a noncanonical encoding are not
acceptable within the context of Lightning, as many messages contain a
signature of the message digest. If it&#8217;s possible for a message to be encoded
in two different ways, then it would be possible to break the authentication of
a signature inadvertently by re-encoding a message using a slightly different
set of bytes on the wire.</simpara>
<simpara>To ensure that all encoded messages are canonical, the following
constraints are defined when encoding:</simpara>
<itemizedlist>
<listitem>
<simpara>
All records within a TLV stream must be encoded in order of strictly
    increasing type.
</simpara>
</listitem>
<listitem>
<simpara>
All records must minimally encode the <literal>type</literal> and <literal>length</literal> fields. In other words, the smallest <literal>BigSize</literal> representation for an integer must be used at all times.
</simpara>
</listitem>
<listitem>
<simpara>
Each <literal>type</literal> may only appear once within a given TLV stream.
</simpara>
</listitem>
</itemizedlist>
<simpara>In addition to these encoding constraints, a series of higher-level
interpretation requirements is also defined based on the <emphasis>arity</emphasis> of a given <literal>type</literal> integer. We dive further into these details toward the end of the
chapter once we describe how the Lightning Protocol is upgraded in practice and
in theory.<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="feature_bits">
<title>Feature Bits and Protocol Extensibility</title>
<simpara><indexterm>
  <primary>feature bits</primary>
</indexterm><indexterm>
  <primary>wire protocol</primary><secondary>feature bits/protocol extensibility</secondary>
</indexterm>
<indexterm>
  <primary>feature bits/protocol extensibility</primary>
</indexterm>Because the Lightning Network is a decentralized system, no single entity can enforce a
protocol change or modification upon all the users of the system. This
characteristic is also seen in other decentralized networks such as Bitcoin.
However, unlike Bitcoin, overwhelming consensus <emphasis>is not</emphasis> required to change a
subset of the Lightning Network. Lightning is able to evolve at will without a
strong requirement of coordination because, unlike Bitcoin, there is no global consensus required in the Lightning Network. Due to this fact and the several
upgrade mechanisms embedded in the Lightning Network, only the
participants that wish to use these new Lightning Network features need to
upgrade, and then they are able to interact with each other.</simpara>
<simpara>In this section, we explore the various ways that developers and users are
able to design and deploy new features to the Lightning Network. The
designers of the original Lightning Network knew that there were many possible future directions for the network and the underlying protocol. As a result, they made sure to implement several
extensibility mechanisms within the system, which can be used to upgrade it partially or fully in a decoupled, desynchronized, and decentralized
manner.</simpara>
<section id="_feature_bits_as_an_upgrade_discoverability_mechanism">
<title>Feature Bits as an Upgrade Discoverability Mechanism</title>
<simpara><indexterm>
  <primary>feature bits</primary><secondary>upgrade discoverability mechanism</secondary>
</indexterm>
<indexterm>
  <primary>upgrade discoverability mechanism</primary>
</indexterm>An astute reader may have noticed the various locations where feature bits are
included within the Lightning Protocol. A <emphasis>feature bit</emphasis> is a bitfield that can
be used to advertise understanding or adherence to a possible network protocol
update. Feature bits are commonly assigned in pairs, meaning that each
potential new feature/upgrade always defines two bits within the bitfield.
One bit signals that the advertised feature is <emphasis>optional</emphasis>, meaning that the
node knows about the feature and can use it, but doesn&#8217;t
consider it required for normal operation. The other bit signals that the
feature is instead <emphasis>required</emphasis>, meaning that the node will not continue
operation if a prospective peer doesn&#8217;t understand that feature.</simpara>
<simpara>Using these two bits (optional and required), we can construct a simple
compatibility matrix that nodes/users can consult to determine if a peer is compatible with a desired feature, as shown in <xref linkend="table1302"/>.</simpara>
<table id="table1302"
frame="all"
rowsep="1" colsep="1"
>
<title>Feature bit compatibility matrix</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Bit type</entry>
<entry align="left" valign="top">Remote optional</entry>
<entry align="left" valign="top">Remote required</entry>
<entry align="left" valign="top">Remote unknown</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Local optional</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Local required</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>❌</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Local unknown</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>❌</simpara></entry>
<entry align="left" valign="top"><simpara>❌</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>From this simplified compatibility matrix, we can see that as long as the other
party knows about our feature bit, then we can interact with them using the
protocol. If the party doesn&#8217;t even know about what bit we&#8217;re referring to
<emphasis>and</emphasis> they require the feature, then we are incompatible with them. Within the
network, optional features are signaled using an <emphasis>odd bit number</emphasis>, while
required features are signaled using an <emphasis>even bit number</emphasis>. As an example, if a peer signals that they know of a feature that uses bit <literal>15</literal>, then we know that
this is an optional feature, and we can interact with them or respond to
their messages even if we don&#8217;t know about the feature. If
they instead signaled the feature using bit <literal>16</literal>, then we know this is a
required feature, and we can&#8217;t interact with them unless our node also
understands that feature.</simpara>
<simpara>The Lightning developers have come up with an easy-to-remember phrase that
encodes this matrix: "it&#8217;s OK to be odd." This simple rule  allows for a
rich set of interactions within the protocol, as a simple bitmask operation
between two feature bit vectors allows peers to determine if certain
interactions are compatible with each other or not. In other words, feature
bits are used as an upgrade discoverability mechanism: they easily allow to
peers to understand if they are compatible or not based on the concepts of
optional, required, and unknown feature bits.</simpara>
<simpara>Feature bits are found in the <literal>node_announcement</literal>, <literal>channel_announcement</literal>, and
<literal>init</literal> messages within the protocol. As a result, these three messages can be
used to signal the knowledge and/or understanding of in-flight protocol
updates within the network. The feature bits found in the <literal>node_announcement</literal>
message can allow a peer to determine if their <emphasis>connections</emphasis> are compatible or
not. The feature bits within the <literal>channel_announcement</literal> messages allow a peer
to determine if a given payment type or HTLC can transit through a given peer or
not. The feature bits within the <literal>init</literal> message allow peers to understand if
they can maintain a connection, and also which features are negotiated for the
lifetime of a given connection.</simpara>
</section>
<section id="_tlv_for_forward_and_backward_compatibility">
<title>TLV for Forward and Backward Compatibility</title>
<simpara><indexterm>
  <primary>feature bits</primary><secondary>TLV for forward/backward compatibility</secondary>
</indexterm>
<indexterm>
  <primary>TLV for forward/backward compatibility</primary>
</indexterm><indexterm>
  <primary>Type-Length-Value (TLV) format</primary><secondary>forward/backward compatibility and</secondary>
</indexterm>
<indexterm>
  <primary>forward/backward compatibility and</primary>
</indexterm><indexterm>
  <primary>wire protocol</primary><secondary>TLV for forward/backward compatibility</secondary>
</indexterm>
<indexterm>
  <primary>TLV for forward/backward compatibility</primary>
</indexterm>As we learned earlier in the chapter, TLV records can be
used to extend messages in a forward and backward compatible manner.
Over time, these records have been used to extend existing messages without
breaking the protocol by utilizing the "undefined" area within a message beyond
that set of known bytes.</simpara>
<simpara>As an example, the original Lightning Protocol didn&#8217;t have a concept of the
"largest amount HTLC" that could traverse through a channel as dictated by a routing
policy. Later on, the <literal>max_htlc</literal> field was added to the <literal>channel_update</literal>
message to phase in this concept over time. Peers that receive a
<literal>channel_update</literal> that sets such a field but don&#8217;t even know the upgrade existed
are unaffected by the change, but have their HTLCs rejected if they are
beyond the limit. Newer peers, on the other hand, are able to parse, verify,
and utilize the new field.</simpara>
<simpara>Those familiar with the concept of soft forks in Bitcoin may now see some
similarities between the two mechanisms.  Unlike Bitcoin consensus-level
soft forks, upgrades to the Lightning Network don&#8217;t require overwhelming
consensus to be adopted. Instead, at minimum, only two peers within the
network need to understand a new upgrade to start using it. Commonly these two peers may be the recipient and sender of a
payment, or may be the channel partners of a new payment channel.</simpara>
</section>
<section id="_a_taxonomy_of_upgrade_mechanisms">
<title>A Taxonomy of Upgrade Mechanisms</title>
<simpara><indexterm>
  <primary>Lightning Network (generally)</primary><secondary>taxonomy of upgrade mechanisms</secondary>
</indexterm>
<indexterm>
  <primary>taxonomy of upgrade mechanisms</primary>
</indexterm><indexterm>
  <primary>upgrades</primary><secondary>taxonomy of upgrade mechanisms</secondary>
</indexterm>
<indexterm>
  <primary>taxonomy of upgrade mechanisms</primary>
</indexterm><indexterm>
  <primary>wire protocol</primary><secondary>taxonomy of upgrade mechanisms</secondary>
</indexterm>
<indexterm>
  <primary>taxonomy of upgrade mechanisms</primary>
</indexterm>Rather than there being a single widely utilized upgrade mechanism within the
network (such as soft forks for Bitcoin), there exist several possible upgrade mechanisms within the Lightning Network. In this
section, we enumerate these upgrade mechanisms and
provide a real-world example of their use in the past.</simpara>
<section id="_internal_network_upgrades">
<title>Internal network upgrades</title>
<simpara><indexterm>
  <primary>upgrades</primary><secondary>internal network</secondary>
</indexterm>
<indexterm>
  <primary>internal network</primary>
</indexterm>We start with the upgrade type that requires the most protocol-level
coordination: internal network upgrades. An internal network upgrade is
characterized by one that requires <emphasis>every single node</emphasis> within a prospective payment path to understand the new feature. Such an upgrade is similar to any
upgrade within the internet that requires hardware-level upgrades within
the core-relay portion of the upgrade. In the context of the Lightning Network, however, we deal
with pure software, so such upgrades are easier to deploy, yet they still
require much more coordination than any other upgrade mechanism in the
network.</simpara>
<simpara>One example of such an upgrade within the network was the introduction of a TLV
encoding for the routing information encoded within the onion
packets. The prior format used a hardcoded fixed-length message
format to communicate information such as the next hop.
Because this format was fixed, it meant that new protocol-level upgrades  weren&#8217;t possible. The move to the more flexible TLV
format meant that after this upgrade, any sort of feature that
modified the type of information communicated at each hop could be rolled out at will.</simpara>
<simpara>It&#8217;s worth mentioning that the TLV onion upgrade was a sort of "soft" internal
network upgrade, in that if a payment wasn&#8217;t using any new feature beyond
that new routing information encoding, then a payment could be transmitted
using a mixed set of nodes.</simpara>
</section>
<section id="_end_to_end_upgrades">
<title>End-to-end upgrades</title>
<simpara><indexterm>
  <primary>upgrades</primary><secondary>end-to-end</secondary>
</indexterm>
<indexterm>
  <primary>end-to-end</primary>
</indexterm>To contrast the internal network upgrade, in this section we describe the
<emphasis>end-to-end</emphasis> network upgrade. This upgrade mechanism differs from the internal
network upgrade in that it only requires the "ends" of the payment, the sender
and recipient, to upgrade.</simpara>
<simpara>This type of upgrade allows
for a wide array of unrestricted innovation within the network. Because of the
onion encrypted nature of payments within the network, those forwarding HTLCs
within the center of the network may not even know that new features are being
utilized.</simpara>
<simpara>One example of an end-to-end upgrade within the network was the rollout of multipart payments (MPP). MPP is a protocol-level feature that enables a
single payment to be split into multiple parts or paths, to be assembled at the
recipient for settlement. The rollout of MPP was coupled with a new
<literal>node_announcement</literal> level feature bit that indicates that the recipient knows
how to handle partial payments. Assuming a sender and recipient know about each
other (possibly via a BOLT #11 invoice), then they&#8217;re able to use the new
feature without any further negotiation.</simpara>
<simpara>Another example of an end-to-end upgrade are the various types of
<emphasis>spontaneous</emphasis> payments deployed within the network. One early type of
spontaneous payments called <emphasis>keysend</emphasis> worked by simply placing the preimage of a payment within the encrypted onion. Upon receipt, the destination would decrypt the
preimage, then use that to settle the payment. Because the entire packet is end-to-end encrypted, this payment type was safe, since none of the intermediate nodes
are able to fully unwrap the onion to uncover the payment preimage.</simpara>
</section>
</section>
<section id="_channel_construction_level_updates">
<title>Channel Construction-Level Updates</title>
<simpara><indexterm>
  <primary>wire protocol</primary><secondary>channel construction-level updates</secondary>
</indexterm>
<indexterm>
  <primary>channel construction-level updates</primary>
</indexterm>The final broad category of updates are those that happen at
the channel construction level, but which don&#8217;t modify the structure of the HTLC used widely within the network. When we say channel construction, we mean
how the channel is funded or created. As an example, the eltoo channel type
can be rolled out within the network using a new <literal>node_announcement</literal> level
feature bit as well as a <literal>channel_announcement</literal> level feature bit. Only the two
peers on the sides of the channels need to understand and advertise these new
features. This channel pair can then be used to forward any payment type
granted the channel supports it.</simpara>
<simpara>Another is the <emphasis>anchor outputs</emphasis> channel format which allows the commitment fee to be
bumped via Bitcoin&#8217;s Child-Pays-For-Parent (CPFP) fee management mechanism<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm>.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_conclusion_12">
<title>Conclusion</title>
<simpara>Lightning&#8217;s wire protocol is incredibly flexible and allows for rapid innovation and interoperability without strict consensus. It is one of the reasons that the Lightning Network is experiencing much faster development and is attractive to many developers, who might otherwise find Bitcoin&#8217;s development style too conservative and slow.<indexterm>
</indexterm></simpara>
</section>
</chapter>
<chapter id="encrypted_message_transport">
<title>Lightning&#8217;s Encrypted Message Transport</title>
<simpara><indexterm>
  <primary>Lightning encrypted transport protocol</primary>
</indexterm>In this chapter we will review the Lightning Network&#8217;s <emphasis>encrypted message
transport</emphasis>, sometimes referred to as the <indexterm>
  <primary>Brontide Protocol</primary>
</indexterm><emphasis>Brontide Protocol</emphasis>, which allows peers to
establish end-to-end encrypted communication, authentication, and integrity
checking.</simpara>
<note>
<simpara>Part of this chapter includes some highly technical detail about the encryption protocol and encryption algorithms used in the Lightning encrypted transport. You may decide to skip that section if you are not interested in those details.</simpara>
</note>
<section id="_encrypted_transport_in_the_lightning_protocol_suite">
<title>Encrypted Transport in the Lightning Protocol Suite</title>
<simpara><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>Lightning Protocol Suite and</secondary>
</indexterm>
<indexterm>
  <primary>Lightning Protocol Suite and</primary>
</indexterm>The transport component of the Lightning Network and its several components are shown in the leftmost part of the network connection layer in  <xref linkend="LN_protocol_encrypted_transport_highlight"/>.</simpara>
<figure id="LN_protocol_encrypted_transport_highlight"><title>Encrypted message transport in the Lightning protocol suite</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1401.png"/>
  </imageobject>
  <textobject><phrase>Encrypted message transport in the Lightning protocol suite</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_introduction">
<title>Introduction</title>
<simpara>Unlike the vanilla Bitcoin P2P network, every node in the Lightning Network is
identified by a unique public key which serves as its identity. By default, this
public key is used to end-to-end encrypt <emphasis>all</emphasis> communication within the
network. Encryption by default at the lowest level of the protocol ensures that
all messages are authenticated, are immune to man-in-the-middle (MITM) attacks and snooping by third parties, and ensures privacy at the fundamental transport
level. In this chapter, we&#8217;ll learn about the encryption protocol used by the
Lightning Network in detail. Upon completion of this chapter, the reader will
be familiar with the state of the art in encrypted messaging protocols, as well
as the various properties such a protocol provides to the network. It&#8217;s worth
mentioning that the core of the encrypted message transport is <emphasis>agnostic</emphasis> to
its usage within the context of the Lightning Network. As a result, the
custom encrypted message transport that Lightning uses can be dropped into any context
that requires encrypted communication between two parties.</simpara>
</section>
<section id="_the_channel_graph_as_decentralized_public_key_infrastructure">
<title>The Channel Graph as Decentralized Public Key Infrastructure</title>
<simpara><indexterm>
  <primary>channel graph</primary><secondary>decentralized public key infrastructure</secondary>
</indexterm>
<indexterm>
  <primary>decentralized public key infrastructure</primary>
</indexterm><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>channel graph as decentralized public key infrastructure</secondary>
</indexterm>
<indexterm>
  <primary>channel graph as decentralized public key infrastructure</primary>
</indexterm><indexterm>
  <primary>PKI (public key infrastructure)</primary>
</indexterm><indexterm>
  <primary>public key infrastructure (PKI)</primary>
</indexterm>As we learned in <xref linkend="routing"/>, every node has a long-term
identity that is used as the identifier for a vertex during pathfinding and
also used in the asymmetric cryptographic operations related to the creation of
onion encrypted routing packets. This public key, which serves as a node&#8217;s
long-term identity, is included in the DNS bootstrapping response, as well as
embedded within the channel graph. As a result, before a node attempts to
connect out to another node on the P2P network, it already knows the public key
of the node it wishes to connect to.</simpara>
<simpara>Additionally, if the node being connected to already has a series of public
channels within the graph, then the connecting node is able to further verify the identity of the node. Because the entire channel graph is fully
authenticated, one can view it as a sort of decentralized public key
infrastructure (PKI): to register a key, a public channel in the Bitcoin
blockchain must be opened, and once a node no longer has any public channels, then
they&#8217;ve effectively been removed from the PKI.</simpara>
<simpara>Because Lightning is a decentralized network, it&#8217;s imperative that no one central
party is designated the power to provision a public key identity within the
network. In place of a central party, the Lightning Network uses the Bitcoin
blockchain as a Sybil mitigation mechanism because gaining an identity on the
network has a tangible cost: the fee needed to create a channel in the
blockchain, as well as the opportunity cost of the capital allocated to their
channels. In the process of essentially rolling a domain-specific PKI, the
Lightning Network is able to significantly simplify its encrypted transport
protocol as it doesn&#8217;t need to deal with all the complexities that come along
with TLS, the Transport Layer Security protocol.</simpara>
</section>
<section id="_why_not_tls">
<title>Why Not TLS?</title>
<simpara><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>TLS vulnerabilities/limitations</secondary>
</indexterm>
<indexterm>
  <primary>TLS vulnerabilities/limitations</primary>
</indexterm><indexterm>
  <primary>TLS (Transport Layer Security protocol)</primary>
</indexterm><indexterm>
  <primary>Transport Layer Security protocol (TLS)</primary>
</indexterm>Readers familiar with the TLS system may be wondering at this point: why wasn&#8217;t
TLS used in spite of the drawbacks of the existing PKI system? It is indeed a
fact that "self-signed certificates" can be used to effectively sidestep the
existing global PKI system by simply asserting to the identity of a given
public key amongst a set of peers. However, even with the existing PKI system
out of the way, TLS has several drawbacks that prompted the creators of the Lightning Network
to instead opt for a more compact custom encryption protocol.</simpara>
<simpara>To start with, TLS is a protocol that has been around for several decades and
as a result has evolved over time as new advances have been made in the space
of transport encryption. However, over time this evolution has caused the
protocol to balloon in size and complexity. Over the past few decades, several
vulnerabilities in TLS have been discovered and patched, with each evolution
further increasing the complexity of the protocol. As a result of the age of
the protocol, several versions and iterations exist, meaning a client needs to
understand many of the prior iterations of the protocol to communicate
with a large portion of the public internet, further increasing implementation
complexity.</simpara>
<simpara>In the past, several memory safety vulnerabilities have been discovered in
widely used implementations of SSL/TLS. Packaging such a protocol within every
Lightning node would serve to increase the attack surface of nodes exposed to the public peer-to-peer network. To increase the security of the
network as a whole and minimize exploitable attack surface, the creators of
the Lightning Network instead opted to adopt the Noise Protocol Framework. Noise as a protocol
internalizes several of the security and privacy lessons learned over time due
to continual scrutiny of the TLS protocol over decades. In a way, the existence
of Noise allows the community to effectively "start over," with a more compact,
simplified protocol that retains all the added benefits of TLS.</simpara>
</section>
<section id="_the_noise_protocol_framework">
<title>The Noise Protocol Framework</title>
<simpara><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>Noise Protocol Framework</secondary>
</indexterm>
<indexterm>
  <primary>Noise Protocol Framework</primary>
</indexterm><indexterm>
  <primary>Noise Protocol Framework</primary><secondary>encrypted message transport and</secondary>
</indexterm>
<indexterm>
  <primary>encrypted message transport and</primary>
</indexterm>The Noise Protocol Framework is a modern, extensible, and flexible message
encryption protocol designed by the creators of the Signal Protocol. The Signal Protocol is one of the most widely used message encryption protocols in the
world. It&#8217;s used by both Signal and Whatsapp, which cumulatively are used by
over a billion people around the world. The Noise framework is the result of
decades of evolution both within academia as well as the industry of message
encryption protocols. Lightning uses the Noise Protocol Framework to implement
a <emphasis>message-oriented</emphasis> encryption protocol used by all nodes to communicate with
each other.</simpara>
<simpara>A communication session using Noise has two distinct phases: the handshake
phase and the messaging phase. Before two parties can communicate with each
other, they first need to arrive at a shared secret known only to them which
will be used to encrypt and authenticate messages sent to each other. <indexterm>
  <primary>handshake</primary><secondary>defined</secondary>
</indexterm>
<indexterm>
  <primary>defined</primary>
</indexterm>A flavor
of an authenticated key agreement is used to arrive at a final shared key
between the two parties. In the context of the Noise protocol, this
authenticated key agreement is referred to as a <emphasis>handshake</emphasis>. Once that
handshake has been completed, both nodes can now being to send each other
encrypted messages. Each time peers need to connect or reconnect to each
other, a fresh iteration of the handshake protocol is executed, ensuring that
forward secrecy is achieved (leaking the key of a prior transcript doesn&#8217;t compromise any
future transcripts).</simpara>
<simpara>Because the Noise Protocol allows a protocol designer to choose from several
cryptographic primitives, such as symmetric encryption and public key
cryptography, it&#8217;s customary that each flavor of the Noise Protocol is referred
to by a unique name. In the spirit of "Noise," each flavor of the protocol
selects a name derived from some sort of "noise." In the context of the
<indexterm>
  <primary>Brontide Protocol</primary>
</indexterm>Lightning Network, the flavor of the Noise Protocol used is sometimes referred to
as Brontide. A <emphasis>brontide</emphasis> is a low billowing noise, similar to what one would
hear during a thunderstorm when very far away.</simpara>
</section>
<section id="_lightning_encrypted_transport_in_detail">
<title>Lightning Encrypted Transport in Detail</title>
<simpara><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>elements of</secondary>
</indexterm>
<indexterm>
  <primary>elements of</primary>
</indexterm>In this section we will break down the Lightning encrypted transport protocol and delve into the details of the cryptographic algorithms and protocol used to establish encrypted, authenticated, and integrity-assured communications between peers. Feel free to skip this section if you find this level of detail daunting.</simpara>
<section id="_noise_xk_lightning_network_8217_s_noise_handshake">
<title>Noise_XK: Lightning Network&#8217;s Noise Handshake</title>
<simpara><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>Noise_XK</secondary>
</indexterm>
<indexterm>
  <primary>Noise_XK</primary>
</indexterm><indexterm>
  <primary>Noise Protocol Framework</primary><secondary>Noise_XK</secondary>
</indexterm>
<indexterm>
  <primary>Noise_XK</primary>
</indexterm><indexterm>
  <primary>Noise_XK</primary>
</indexterm>The Noise Protocol is extremely flexible in that it advertises several
handshakes, each with different security and privacy properties for a would-be
protocol implementer to select from. A deep exploration of each of the
handshakes and their various trade-offs is out of the scope of this chapter.
With that said, the Lightning Network uses a specific handshake referred to as
<literal>Noise_XK</literal>. <indexterm>
  <primary>identity hiding</primary>
</indexterm>The unique property provided by this handshake is <emphasis>identity hiding</emphasis>: in order for a node to initiate a connection with another node, it
must first know its public key. Mechanically, this means that the public key
of the responder is actually never transmitted during the context of the
handshake. Instead, a clever series of Elliptic Curve Diffie–Hellman (ECDH) and
message authentication code (MAC) checks are used to authenticate the
responder.</simpara>
</section>
<section id="_handshake_notation_and_protocol_flow">
<title>Handshake Notation and Protocol Flow</title>
<simpara><indexterm>
  <primary>handshake</primary><secondary>notation and protocol flow</secondary>
</indexterm>
<indexterm>
  <primary>notation and protocol flow</primary>
</indexterm><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>handshake notation and protocol flow</secondary>
</indexterm>
<indexterm>
  <primary>handshake notation and protocol flow</primary>
</indexterm><indexterm>
  <primary>Noise_XK</primary><secondary>handshake notation and protocol flow</secondary>
</indexterm>
<indexterm>
  <primary>handshake notation and protocol flow</primary>
</indexterm>Each handshake typically consists of several steps. At each step some
(possibly) encrypted material is sent to the opposite party, an ECDH (or
several) is performed, with the result of the handshake being "mixed" into a
protocol <emphasis>transcript</emphasis>. This transcript serves to authenticate each step of the
protocol and helps thwart a flavor of man-in-the-middle attacks. At the
end of the handshake, two keys, <literal>ck</literal> and <literal>k</literal>, are produced which are used to
encrypt messages (<literal>k</literal>) and rotate keys (<literal>ck</literal>) throughout the lifetime of
the session.</simpara>
<simpara>In the context of a handshake, <literal>s</literal> is usually a long-term static public key.
In our case, the public key crypto system used is an elliptic curve one,
instantiated with the <literal>secp256k1</literal> curve, which is used elsewhere in Bitcoin.
Several ephemeral keys are generated throughout the handshake. We use <literal>e</literal> to
refer to a new ephemeral key. ECDH operations between two keys are notated as
the concatenation of two keys. As an example, <literal>ee</literal> represents an ECDH operation
between two ephemeral keys.</simpara>
</section>
<section id="_high_level_overview">
<title>High-Level Overview</title>
<simpara><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>high-level overview</secondary>
</indexterm>
<indexterm>
  <primary>high-level overview</primary>
</indexterm><indexterm>
  <primary>Noise_XK</primary><secondary>high-level overview</secondary>
</indexterm>
<indexterm>
  <primary>high-level overview</primary>
</indexterm>Using the notation laid out earlier, we can succinctly describe the <literal>Noise_XK</literal>
as <span class="keep-together">follows</span>:
```
    Noise_XK(s, rs):
       &#8592; rs
       &#8230;
       &#8594; e, e(rs)
       &#8592; e, ee
       &#8594; s, se
```</simpara>
<simpara>The protocol begins with the "pretransmission" of the responder&#8217;s static key
(<literal>rs</literal>) to the initiator. Before executing the handshake, the initiator is to
generate its own static key (<literal>s</literal>). During each step of the handshake, all
material sent across the wire and the keys sent/used are incrementally
hashed into a <emphasis>handshake digest</emphasis>, <literal>h</literal>. This digest is never sent across the
wire during the handshake, and is instead used as the "associated data" when
AEAD (authenticated encryption with associated data) is sent across the wire.
<indexterm>
  <primary>AD (associated data)</primary>
</indexterm><indexterm>
  <primary>associated data (AD)</primary>
</indexterm><emphasis>Associated data</emphasis> (AD) allows an encryption protocol to authenticate additional
information alongside a cipher text packet. In other domains, the AD may be a
domain name, or plain-text portion of the packet.</simpara>
<simpara>The existence of <literal>h</literal> ensures that if a portion of a transmitted handshake
message is replaced, then the other side will notice. At each step, a MAC
digest is checked. If the MAC check succeeds, then the receiving party knows
that the handshake has been successful up until that point. Otherwise, if a MAC
check ever fails, then the handshake process has failed, and the connection
should be terminated.</simpara>
<simpara>The protocol also adds a new piece of data to each handshake message: a protocol
version. The initial protocol version is <literal>0</literal>. At the time of writing, no new
protocol versions have been created. As a result, if a peer receives a version
other than <literal>0</literal>, then they should reject the handshake initiation attempt.</simpara>
<simpara>As far as cryptographic primitives, SHA-256 is used as the hash function of
choice, <literal>secp256k1</literal> as the elliptic curve, and <literal>ChaChaPoly-130</literal> as the AEAD
(symmetric encryption) construction.</simpara>
<simpara>Each variant of the Noise Protocol has a unique ASCII string used to refer to it. To ensure that two parties are using the same protocol
variant, the ASCII string is hashed into a digest, which is used to initialize
the starting handshake state. In the context of the Lightning Network, the ASCII
string describing the protocol is <literal>Noise_XK_secp256k1_ChaChaPoly_SHA256</literal>.</simpara>
</section>
<section id="_handshake_in_three_acts">
<title>Handshake in Three Acts</title>
<simpara><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>handshake in three acts</secondary>
</indexterm>
<indexterm>
  <primary>handshake in three acts</primary>
</indexterm><indexterm>
  <primary>Noise_XK</primary><secondary>handshake in three acts</secondary>
</indexterm>
<indexterm>
  <primary>handshake in three acts</primary>
</indexterm>The handshake portion can be separated into three distinct "acts."
The entire handshake takes 1.5 round trips between the initiator and responder.
At each act, a single message is sent between both parties. The handshake
message is a fixed-size payload prefixed by the protocol version.</simpara>
<simpara>The Noise Protocol uses an object-oriented inspired notation to describe the
protocol at each step. During setup of the handshake state, each side will
initialize the following variables:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>ck</literal>
</term>
<listitem>
<simpara>
The <emphasis>chaining key</emphasis>. This value is the accumulated hash of all
   previous ECDH outputs. At the end of the handshake, <literal>ck</literal> is used to derive
   the encryption keys for Lightning messages.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>h</literal>
</term>
<listitem>
<simpara>
The <emphasis>handshake hash</emphasis>. This value is the accumulated hash of <emphasis>all</emphasis>
   handshake data that has been sent and received so far during the handshake
   process.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>temp_k1</literal>, <literal>temp_k2</literal>, <literal>temp_k3</literal>
</term>
<listitem>
<simpara>
The <emphasis>intermediate keys</emphasis>. These are used to
   encrypt and decrypt the zero-length AEAD payloads at the end of each handshake
   message.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>e</literal>
</term>
<listitem>
<simpara>
A party&#8217;s <emphasis>ephemeral keypair</emphasis>. For each session, a node must generate a
   new ephemeral key with strong cryptographic randomness.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>s</literal>
</term>
<listitem>
<simpara>
A party&#8217;s <emphasis>static keypair</emphasis> (<literal>ls</literal> for local, <literal>rs</literal> for remote).
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Given this handshake plus messaging session state, we&#8217;ll then define a series of
functions that will operate on the handshake and messaging state. When
describing the handshake protocol, we&#8217;ll use these variables in a manner
similar to pseudocode to reduce the verbosity of the explanation of
each step in the protocol. We&#8217;ll define the <emphasis>functional</emphasis> primitives of the
handshake as:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>ECDH(k, rk)</literal>
</term>
<listitem>
<simpara>
Performs an Elliptic Curve Diffie–Hellman operation using
    <literal>k</literal>, which is a valid <literal>secp256k1</literal> private key, and <literal>rk</literal>, which is a valid public key.
</simpara>
<simpara>The returned value is the SHA-256 of the compressed format of the
      generated point.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>HKDF(salt,ikm)</literal>
</term>
<listitem>
<simpara>
A function defined in <literal>RFC 5869</literal>,
    evaluated with a zero-length <literal>info</literal> field.
</simpara>
<simpara>All invocations of <literal>HKDF</literal> implicitly return 64 bytes of
       cryptographic randomness using the extract-and-expand component of the
       <literal>HKDF</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>encryptWithAD(k, n, ad, plaintext)</literal>
</term>
<listitem>
<simpara>
Outputs <literal>encrypt(k, n, ad, plaintext)</literal>.
</simpara>
<simpara>Where <literal>encrypt</literal> is an evaluation of <literal>ChaCha20-Poly1305</literal> (Internet Engineering Task Force variant)
       with the passed arguments, with nonce <literal>n</literal> encoded as 32 zero bits,
       followed by a <emphasis>little-endian</emphasis> 64-bit value. Note: this follows the Noise
       Protocol convention, rather than our normal endian.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>decryptWithAD(k, n, ad, ciphertext)</literal>
</term>
<listitem>
<simpara>
Outputs <literal>decrypt(k, n, ad, ciphertext)</literal>.
</simpara>
<simpara>Where <literal>decrypt</literal> is an evaluation of <literal>ChaCha20-Poly1305</literal> (IETF variant)
       with the passed arguments, with nonce <literal>n</literal> encoded as 32 zero bits,
       followed by a <emphasis>little-endian</emphasis> 64-bit value.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>generateKey()</literal>
</term>
<listitem>
<simpara>
Generates and returns a fresh <literal>secp256k1</literal> keypair.
</simpara>
<simpara>Where the object returned by <literal>generateKey</literal> has two attributes:<literal>.pub</literal>, which returns an abstract object representing the public key; and <literal>.priv</literal>, which represents the private key used to generate the public key</simpara>
<simpara>Where the object also has a single method: <literal>.serializeCompressed()</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>a || b</literal>
</term>
<listitem>
<simpara>
This denotes the concatenation of two byte strings <literal>a</literal> and <literal>b</literal>.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<section id="_handshake_session_state_initialization">
<title>Handshake session state initialization</title>
<simpara><indexterm>
  <primary>handshake</primary><secondary>session state initialization</secondary>
</indexterm>
<indexterm>
  <primary>session state initialization</primary>
</indexterm><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>handshake session state initialization</secondary>
</indexterm>
<indexterm>
  <primary>handshake session state initialization</primary>
</indexterm><indexterm>
  <primary>Noise_XK</primary><secondary>handshake session state initialization</secondary>
</indexterm>
<indexterm>
  <primary>handshake session state initialization</primary>
</indexterm>Before starting the handshake process, both sides need to initialize the
starting state that they&#8217;ll use to advance the handshake process. To start,
both sides need to construct the initial handshake digest <literal>h</literal>.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<literal>h = SHA-256(<emphasis>protocolName</emphasis>)</literal>
</simpara>
<simpara>Where <literal><emphasis>protocolName</emphasis> = "Noise_XK_secp256k1_ChaChaPoly_SHA256"</literal> encoded as
      an ASCII string.</simpara>
</listitem>
<listitem>
<simpara>
<literal>ck = h</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>h = SHA-256(h || <emphasis>prologue</emphasis>)</literal>
</simpara>
<simpara>Where <literal><emphasis>prologue</emphasis></literal> is the ASCII string: <literal>lightning</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>In addition to the protocol name, we also add in an extra "prologue" that is
used to further bind the protocol context to the Lightning Network.</simpara>
<simpara>To conclude the initialization step, both sides mix the responder&#8217;s public key
into the handshake digest. Because this digest is used while the associated data with a
zero-length ciphertext (only the MAC) is sent, this ensures that the initiator
does indeed know the public key of the responder.</simpara>
<itemizedlist>
<listitem>
<simpara>
The initiating node mixes in the responding node&#8217;s static public key
   serialized in Bitcoin&#8217;s compressed format: <literal>h = SHA-256(h || rs.pub.serializeCompressed())</literal>
</simpara>
</listitem>
<listitem>
<simpara>
The responding node mixes in their local static public key serialized in
   Bitcoin&#8217;s compressed format: <literal>h = SHA-256(h || ls.pub.serializeCompressed())</literal>
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_handshake_acts">
<title>Handshake acts</title>
<simpara><indexterm>
  <primary>handshake</primary><secondary>acts</secondary>
</indexterm>
<indexterm>
  <primary>acts</primary>
</indexterm><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>handshake acts</secondary>
</indexterm>
<indexterm>
  <primary>handshake acts</primary>
</indexterm><indexterm>
  <primary>Noise_XK</primary><secondary>handshake acts</secondary>
</indexterm>
<indexterm>
  <primary>handshake acts</primary>
</indexterm>After the initial handshake initialization, we can begin the actual execution
of the handshake process. The handshake is composed of a series of
three messages sent between the initiator and responder, henceforth referred to as
"acts." Because each act is a single message sent between the parties, a handshake
is completed in a total of 1.5 round trips (0.5 for each act).</simpara>
<simpara><indexterm>
  <primary>Diffie-Hellman Key Exchange (DHKE)</primary>
</indexterm>The first act completes the initial portion of the incremental triple Diffie–Hellman (DH) key exchange (using a new ephemeral key generated by the initiator)
and also ensures that the initiator actually knows the long-term public key of
the responder. During the second act, the responder transmits the ephemeral key
they wish to use for the session to the initiator, and once again incrementally
mixes this new key into the triple DH handshake. During the third and final
act, the initiator transmits their long-term static public key to the
responder and executes the final DH operation to mix that into the final
resulting shared secret.</simpara>
<simpara>====== Act One</simpara>
<simpara>```
    &#8594; e, es
```</simpara>
<simpara>Act One is sent from initiator to responder. During Act One, the initiator
attempts to satisfy an implicit challenge by the responder. To complete this
challenge, the initiator must know the static public key of the responder.</simpara>
<simpara>The handshake message is <emphasis>exactly</emphasis> 50 bytes: 1 byte for the handshake
version, 33 bytes for the compressed ephemeral public key of the initiator,
and 16 bytes for the <literal>poly1305</literal> tag.</simpara>
<simpara>Sender actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<literal>e = generateKey()</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>h = SHA-256(h || e.pub.serializeCompressed())</literal>
</simpara>
<simpara>The newly generated ephemeral key is accumulated into the running
       handshake digest.
3. <literal>es = ECDH(e.priv, rs)</literal></simpara>
<simpara>The initiator performs an ECDH between its newly generated ephemeral
       key and the remote node&#8217;s static public key.
4. <literal>ck, temp_k1 = HKDF(ck, es)</literal></simpara>
<simpara>A new temporary encryption key is generated, which is
       used to generate the authenticating MAC.
5. <literal>c = encryptWithAD(temp_k1, 0, h, zero)</literal></simpara>
<simpara>Where <literal>zero</literal> is a zero-length plain text.
6. <literal>h = SHA-256(h || c)</literal></simpara>
<simpara>Finally, the generated ciphertext is accumulated into the authenticating
       handshake digest.
7. Send <literal>m = 0 || e.pub.serializeCompressed() || c</literal> to the responder over the network buffer.</simpara>
</listitem>
</orderedlist>
<simpara>Receiver actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Read <emphasis>exactly</emphasis> 50 bytes from the network buffer.
</simpara>
</listitem>
<listitem>
<simpara>
Parse the read message (<literal>m</literal>) into <literal>v</literal>, <literal>re</literal>, and <literal>c</literal>:
</simpara>
<itemizedlist>
<listitem>
<simpara>
Where <literal>v</literal> is the <emphasis>first</emphasis> byte of <literal>m</literal>, <literal>re</literal> is the next 33
      bytes of <literal>m</literal>, and <literal>c</literal> is the last 16 bytes of <literal>m</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
The raw bytes of the remote party&#8217;s ephemeral public key (<literal>re</literal>) are to be
      deserialized into a point on the curve using affine coordinates as encoded
      by the key&#8217;s serialized composed format.
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
If <literal>v</literal> is an unrecognized handshake version, then the responder must
    abort the connection attempt.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>h = SHA-256(h || re.serializeCompressed())</literal>
</simpara>
<simpara>The responder accumulates the initiator&#8217;s ephemeral key into the authenticating
      handshake digest.
5. <literal>es = ECDH(s.priv, re)</literal></simpara>
<simpara>The responder performs an ECDH between its static private key and the
      initiator&#8217;s ephemeral public key.
6. <literal>ck, temp_k1 = HKDF(ck, es)</literal></simpara>
<simpara>A new temporary encryption key is generated, which will
      shortly be used to check the authenticating MAC.
7. <literal>p = decryptWithAD(temp_k1, 0, h, c)</literal></simpara>
<simpara>If the MAC check in this operation fails, then the initiator does <emphasis>not</emphasis>
      know the responder&#8217;s static public key. If this is the case, then the
      responder must terminate the connection without any further messages.
8. <literal>h = SHA-256(h || c)</literal></simpara>
<simpara>The received ciphertext is mixed into the handshake digest. This step serves
       to ensure the payload wasn&#8217;t modified by a MITM.</simpara>
</listitem>
</orderedlist>
<simpara>====== Act Two</simpara>
<simpara>```
   &#8592; e, ee
```</simpara>
<simpara>Act Two is sent from the responder to the initiator. Act Two will <emphasis>only</emphasis>
take place if Act One was successful. Act One was successful if the
responder was able to properly decrypt and check the MAC of the tag sent at
the end of Act One.</simpara>
<simpara>The handshake is <emphasis>exactly</emphasis> 50 bytes: 1 byte for the handshake version, 33
bytes for the compressed ephemeral public key of the responder, and 16 bytes
for the <literal>poly1305</literal> tag.</simpara>
<simpara>Sender actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<literal>e = generateKey()</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>h = SHA-256(h || e.pub.serializeCompressed())</literal>
</simpara>
<simpara>The newly generated ephemeral key is accumulated into the running
       handshake digest.
3. <literal>ee = ECDH(e.priv, re)</literal></simpara>
<simpara>Where <literal>re</literal> is the ephemeral key of the initiator, which was received
       during Act One.
4. <literal>ck, temp_k2 = HKDF(ck, ee)</literal></simpara>
<simpara>A new temporary encryption key is generated, which is
       used to generate the authenticating MAC.
5. <literal>c = encryptWithAD(temp_k2, 0, h, zero)</literal></simpara>
<simpara>Where <literal>zero</literal> is a zero-length plain text.
6. <literal>h = SHA-256(h || c)</literal></simpara>
<simpara>Finally, the generated ciphertext is accumulated into the authenticating
       handshake digest.
7. Send <literal>m = 0 || e.pub.serializeCompressed() || c</literal> to the initiator over the network buffer.</simpara>
</listitem>
</orderedlist>
<simpara>Receiver actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Read <emphasis>exactly</emphasis> 50 bytes from the network buffer.
</simpara>
</listitem>
<listitem>
<simpara>
Parse the read message (<literal>m</literal>) into <literal>v</literal>, <literal>re</literal>, and <literal>c</literal>:
</simpara>
<simpara>Where <literal>v</literal> is the <emphasis>first</emphasis> byte of <literal>m</literal>, <literal>re</literal> is the next 33
      bytes of <literal>m</literal>, and <literal>c</literal> is the last 16 bytes of <literal>m</literal>.
3. If <literal>v</literal> is an unrecognized handshake version, then the responder must
    abort the connection attempt.
4. <literal>h = SHA-256(h || re.serializeCompressed())</literal>
5. <literal>ee = ECDH(e.priv, re)</literal></simpara>
<simpara>Where <literal>re</literal> is the responder&#8217;s ephemeral public key.</simpara>
<simpara>The raw bytes of the remote party&#8217;s ephemeral public key (<literal>re</literal>) are to be
      deserialized into a point on the curve using affine coordinates as encoded
      by the key&#8217;s serialized composed format.
6. <literal>ck, temp_k2 = HKDF(ck, ee)</literal></simpara>
<simpara>A new temporary encryption key is generated, which is
       used to generate the authenticating MAC.
7. <literal>p = decryptWithAD(temp_k2, 0, h, c)</literal></simpara>
<simpara>If the MAC check in this operation fails, then the initiator must
      terminate the connection without any further messages.
8. <literal>h = SHA-256(h || c)</literal></simpara>
<simpara>The received ciphertext is mixed into the handshake digest. This step serves
       to ensure the payload wasn&#8217;t modified by a MITM.</simpara>
</listitem>
</orderedlist>
<simpara>====== Act Three</simpara>
<simpara>```
   &#8594; s, se
```</simpara>
<simpara>Act Three is the final phase in the authenticated key agreement described in
this section. This act is sent from the initiator to the responder as a
concluding step. Act Three is executed <emphasis>if and only if</emphasis> Act Two was successful.
During Act Three, the initiator transports its static public key to the
responder encrypted with <emphasis>strong</emphasis> forward secrecy, using the accumulated <literal>HKDF</literal>
derived secret key at this point of the handshake.</simpara>
<simpara>The handshake is <emphasis>exactly</emphasis> 66 bytes: 1 byte for the handshake version, 33
bytes for the static public key encrypted with the <literal>ChaCha20</literal> stream
cipher, 16 bytes for the encrypted public key&#8217;s tag generated via the AEAD
construction, and 16 bytes for a final authenticating tag.</simpara>
<simpara>Sender actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<literal>c = encryptWithAD(temp_k2, 1, h, s.pub.serializeCompressed())</literal>
</simpara>
<simpara>Where <literal>s</literal> is the static public key of the initiator.
2. <literal>h = SHA-256(h || c)</literal>
3. <literal>se = ECDH(s.priv, re)</literal></simpara>
<simpara>Where <literal>re</literal> is the ephemeral public key of the responder.
4. <literal>ck, temp_k3 = HKDF(ck, se)</literal></simpara>
<simpara>The final intermediate shared secret is mixed into the running chaining key.
5. <literal>t = encryptWithAD(temp_k3, 0, h, zero)</literal></simpara>
<simpara>Where <literal>zero</literal> is a zero-length plain text.
6. <literal>sk, rk = HKDF(ck, zero)</literal></simpara>
<simpara>Where <literal>zero</literal> is a zero-length plain text,
       <literal>sk</literal> is the key to be used by the initiator to encrypt messages to the
       responder,
       and <literal>rk</literal> is the key to be used by the initiator to decrypt messages sent by
       the responder.</simpara>
<simpara>The final encryption keys, to be used for sending and
       receiving messages for the duration of the session, are generated.
7. <literal>rn = 0, sn = 0</literal></simpara>
<simpara>The sending and receiving nonces are initialized to 0.
8. Send <literal>m = 0 || c || t</literal> over the network buffer.</simpara>
</listitem>
</orderedlist>
<simpara>Receiver actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Read <emphasis>exactly</emphasis> 66 bytes from the network buffer.
</simpara>
</listitem>
<listitem>
<simpara>
Parse the read message (<literal>m</literal>) into <literal>v</literal>, <literal>c</literal>, and <literal>t</literal>:
</simpara>
<simpara>Where <literal>v</literal> is the <emphasis>first</emphasis> byte of <literal>m</literal>, <literal>c</literal> is the next 49
      bytes of <literal>m</literal>, and <literal>t</literal> is the last 16 bytes of <literal>m</literal>.
3. If <literal>v</literal> is an unrecognized handshake version, then the responder must
    abort the connection attempt.
4. <literal>rs = decryptWithAD(temp_k2, 1, h, c)</literal></simpara>
<simpara>At this point, the responder has recovered the static public key of the
       initiator.
5. <literal>h = SHA-256(h || c)</literal>
6. <literal>se = ECDH(e.priv, rs)</literal></simpara>
<simpara>Where <literal>e</literal> is the responder&#8217;s original ephemeral key.
7. <literal>ck, temp_k3 = HKDF(ck, se)</literal>
8. <literal>p = decryptWithAD(temp_k3, 0, h, t)</literal></simpara>
<simpara>If the MAC check in this operation fails, then the responder must
       terminate the connection without any further messages.
9. <literal>rk, sk = HKDF(ck, zero)</literal></simpara>
<simpara>Where <literal>zero</literal> is a zero-length plain text,
       <literal>rk</literal> is the key to be used by the responder to decrypt the messages sent
       by the initiator,
       and <literal>sk</literal> is the key to be used by the responder to encrypt messages to
       the initiator.</simpara>
<simpara>The final encryption keys, to be used for sending and
       receiving messages for the duration of the session, are generated.
10. <literal>rn = 0, sn = 0</literal></simpara>
<simpara>The sending and receiving nonces are initialized to 0.<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</listitem>
</orderedlist>
</section>
<section id="_transport_message_encryption">
<title>Transport message encryption</title>
<simpara><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>transport message encryption</secondary>
</indexterm>
<indexterm>
  <primary>transport message encryption</primary>
</indexterm><indexterm>
  <primary>Noise_XK</primary><secondary>transport message encryption</secondary>
</indexterm>
<indexterm>
  <primary>transport message encryption</primary>
</indexterm>At the conclusion of Act Three, both sides have derived the encryption keys, which
will be used to encrypt and decrypt messages for the remainder of the
session.</simpara>
<simpara>The actual Lightning Protocol messages are encapsulated within AEAD ciphertexts.
Each message is prefixed with another AEAD ciphertext, which encodes the total
length of the following Lightning message (not including its MAC).</simpara>
<simpara>The <emphasis>maximum</emphasis> size of <emphasis>any</emphasis> Lightning message must not exceed 65,535 bytes. A
maximum size of 65,535 simplifies testing, makes memory management easier, and
helps mitigate memory-exhaustion attacks.</simpara>
<simpara>To make traffic analysis more difficult, the length prefix for all
encrypted Lightning messages is also encrypted. Additionally a 16-byte
<literal>Poly-1305</literal> tag is added to the encrypted length prefix to ensure that
the packet length hasn&#8217;t been modified when in flight and also to avoid
creating a decryption oracle.</simpara>
<simpara>The structure of packets on the wire resembles the diagram in <xref linkend="noise_encrypted_packet"/>.</simpara>
<figure id="noise_encrypted_packet"><title>Encrypted packet structure</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1402.png"/>
  </imageobject>
  <textobject><phrase>Encrypted Packet Structure</phrase></textobject>
</mediaobject>
</figure>
<simpara>The prefixed message length is encoded as a 2-byte big-endian integer, for a
total maximum packet length of <span>2 + 16 + 65,535 + 16 = 65,569</span> bytes.</simpara>
<simpara>====== Encrypting and sending messages</simpara>
<simpara>To encrypt and send a Lightning message (<literal>m</literal>) to the network stream,
given a sending key (<literal>sk</literal>) and a nonce (<literal>sn</literal>), the following steps are
completed:</simpara>
<orderedlist role="pagebreak-before" numeration="arabic">
<listitem>
<simpara>
Let <literal>l = len(m)</literal>.
</simpara>
<simpara>Where <literal>len</literal> obtains the length in bytes of the Lightning message.
2. Serialize <literal>l</literal> into 2 bytes encoded as a big-endian integer.
3. Encrypt <literal>l</literal> (using <literal>ChaChaPoly-1305</literal>, <literal>sn</literal>, and <literal>sk</literal>), to obtain <literal>lc</literal>
    (18 bytes).
    * The nonce <literal>sn</literal> is encoded as a 96-bit little-endian number. As the
      decoded nonce is 64 bits, the 96-bit nonce is encoded as 32 bits
      of leading zeros followed by a 64-bit value.
        * The nonce <literal>sn</literal> must be incremented after this step.
    * A zero-length byte slice is to be passed as the AD (associated data).
4. Finally, encrypt the message itself (<literal>m</literal>) using the same procedure used to
    encrypt the length prefix. Let this encrypted ciphertext be known <span class="keep-together">as <code>c</code></span>.</simpara>
<simpara>The nonce <literal>sn</literal> must be incremented after this step.
5. Send <literal>lc || c</literal> over the network buffer.</simpara>
</listitem>
</orderedlist>
<simpara>====== Receiving and decrypting messages</simpara>
<simpara>To decrypt the <emphasis>next</emphasis> message in the network stream, the following
steps are completed:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Read <emphasis>exactly</emphasis> 18 bytes from the network buffer.
</simpara>
</listitem>
<listitem>
<simpara>
Let the encrypted length prefix be known as <literal>lc</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Decrypt <literal>lc</literal> (using <literal>ChaCha20-Poly1305</literal>, <literal>rn</literal>, and <literal>rk</literal>) to obtain the size of
    the encrypted packet <literal>l</literal>.
</simpara>
<itemizedlist>
<listitem>
<simpara>
A zero-length byte slice is to be passed as the AD (associated data).
</simpara>
</listitem>
<listitem>
<simpara>
The nonce <literal>rn</literal> must be incremented after this step.
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Read <emphasis>exactly</emphasis> <literal>l + 16</literal> bytes from the network buffer, and let the bytes be
    known <span class="keep-together">as <code>c</code></span>.
</simpara>
</listitem>
<listitem>
<simpara>
Decrypt <literal>c</literal> (using <literal>ChaCha20-Poly1305</literal>, <literal>rn</literal>, and <literal>rk</literal>) to obtain decrypted
    plain-text packet <literal>p</literal>.
</simpara>
<simpara>The nonce <literal>rn</literal> must be incremented after this step.</simpara>
</listitem>
</orderedlist>
</section>
<section id="_lightning_message_key_rotation">
<title>Lightning message key rotation</title>
<simpara><indexterm>
  <primary>Lightning encrypted transport protocol</primary><secondary>Lightning message key rotation</secondary>
</indexterm>
<indexterm>
  <primary>Lightning message key rotation</primary>
</indexterm><indexterm>
  <primary>Noise_XK</primary><secondary>Lightning message key rotation</secondary>
</indexterm>
<indexterm>
  <primary>Lightning message key rotation</primary>
</indexterm>Changing keys regularly and forgetting previous keys is useful to prevent the
decryption of old messages, in the case of later key leakage (i.e.,  backward
secrecy).</simpara>
<simpara>Key rotation is performed for <emphasis>each</emphasis> key (<literal>sk</literal> and <literal>rk</literal>) <emphasis>individually</emphasis>. A key
is to be rotated after a party encrypts or decrypts 1,000 times with it (i.e.,
every 500 messages).  This can be properly accounted for by rotating the key
once the nonce dedicated to it exceeds 1,000.</simpara>
<simpara>Key rotation for a key <literal>k</literal> is performed according to the following steps<indexterm>
</indexterm><indexterm>
</indexterm>:<indexterm>
</indexterm></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Let <literal>ck</literal> be the chaining key obtained at the end of Act Three.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>ck', k' = HKDF(ck, k)</literal>
</simpara>
</listitem>
<listitem>
<simpara>
Reset the nonce for the key to <literal>n = 0</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>k = k'</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>ck = ck'</literal>
</simpara>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section id="_conclusion_13">
<title>Conclusion</title>
<simpara>Lightning&#8217;s underlying transport encryption is based on the Noise Protocol and offers strong security guarantees of privacy, authenticity, and integrity for all communications between Lightning peers.</simpara>
<simpara>Unlike Bitcoin where peers often communicate "in the clear" (without encryption), all Lightning communications are encrypted peer-to-peer. In addition to transport encryption (peer-to-peer), in the Lightning Network, payments are <emphasis>also</emphasis> encrypted into onion packets (hop-to-hop) and payment details are sent out-of-band between the sender and recipient (end-to-end). The combination of all these security mechanisms is cumulative and provides a layered defense against de-anonymization, man-in-the-middle attacks, and network surveillance.</simpara>
<simpara>Of course, no security is perfect and we will see in <xref linkend="security_and_privacy"/> that these properties can be degraded and attacked. However, the Lightning Network significantly improves upon the privacy of Bitcoin.<indexterm>
</indexterm></simpara>
</section>
</chapter>
<chapter id="invoices">
<title>Lightning Payment Requests</title>
<simpara><indexterm>
  <primary>Lightning invoices</primary>
</indexterm>In this chapter we will look at <emphasis>Lightning payment requests</emphasis>, or as they are more commonly known, <emphasis>Lightning invoices</emphasis>.</simpara>
<section id="_invoices_in_the_lightning_protocol_suite">
<title>Invoices in the Lightning Protocol Suite</title>
<simpara><indexterm>
  <primary>Lightning invoices</primary><secondary>Lightning Protocol suite and</secondary>
</indexterm>
<indexterm>
  <primary>Lightning Protocol suite and</primary>
</indexterm><indexterm>
  <primary>Lightning Network Protocol</primary><secondary>Lightning invoices in</secondary>
</indexterm>
<indexterm>
  <primary>Lightning invoices in</primary>
</indexterm><emphasis>Payment requests</emphasis>, aka <emphasis>invoices</emphasis>, are part of the payment layer and are shown in the upper left of <xref linkend="LN_payment_request_highlight"/>.</simpara>
<figure id="LN_payment_request_highlight"><title>Payment requests in the Lightning protocol suite</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1501.png"/>
  </imageobject>
  <textobject><phrase>Payment requests in the Lightning protocol suite</phrase></textobject>
</mediaobject>
</figure>
</section>
<section id="_introduction_2">
<title>Introduction</title>
<simpara>As we&#8217;ve learned throughout the book, minimally two pieces of data are required
to complete a Lightning payment: a payment hash and a destination. As
SHA-256 is used in the Lightning Network to implement HTLCs, this information
requires 32 bytes to communicate. Destinations, on the other hand, are
simply the <literal>secp256k1</literal> public key of the node that wishes to receive a payment.
The purpose of a payment request in the context of the Lightning Network is to
communicate these two pieces of information from sender to receiver. The QR-code-friendly format for communicating the information required
to complete a payment from receiver to sender is described in <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/11-payment-encoding.md">BOLT #11: Invoice Protocol for Lightning Payments</ulink>. In practice, more than just the
payment hash and destination are communicated in a payment request to
make the encoding more fully featured.</simpara>
</section>
<section id="_lightning_payment_requests_versus_bitcoin_addresses">
<title>Lightning Payment Requests Versus Bitcoin Addresses</title>
<simpara><indexterm>
  <primary>Bitcoin addresses, Lightning invoices versus</primary>
</indexterm><indexterm>
  <primary>Lightning invoices</primary><secondary>Bitcoin addresses versus</secondary>
</indexterm>
<indexterm>
  <primary>Bitcoin addresses versus</primary>
</indexterm>A commonly asked question when people first encounter a Lightning Payment
request is: why can&#8217;t a normal static address format be used instead?</simpara>
<simpara>To answer this question, you must first internalize how Lightning
differs from base layer Bitcoin as a payment method. Compared to a Bitcoin
address which may be used to make a potentially unbounded number of payments
(though reusing a Bitcoin address may degrade one&#8217;s privacy), a Lightning
payment request should only ever be used <emphasis>once</emphasis>.  This is due to the fact that
sending a payment to a Bitcoin address essentially uses a public key
cryptosystem to "encode" the payment in a manner that only the true "owner" of
that Bitcoin address can redeem it.</simpara>
<simpara>In contrast, to complete a Lightning payment, the recipient must
reveal a "secret" to the entire payment route, including the sender. This can be
interpreted as usage of a kind of domain-specific symmetric cryptography because
the payment preimage is for practical purposes a nonce (number only used
once). If the sender attempts to make another payment using that identical
payment hash, then they risk losing funds because the payment may not actually be
delivered to the destination. It&#8217;s safe to assume that after a preimage has
been revealed, all nodes in the path will keep it around forever, then rather
than forward the HTLC to collect a routing fee if the payment is
completed, they can simply settle the payment at that instance and gain the
entire payment amount in return. As a result, it&#8217;s unsafe to ever use a payment
request more than once.</simpara>
<simpara>New variants of the original Lightning payment request exist that allow the sender to reuse them as many times as they want. These variants flip the normal payment flow as the sender transmits a preimage within the encrypted onion payload to the receiver, who is the only
one that is able to decrypt it and settle the payment. Alternatively, assuming
a mechanism that allows a sender to typically request a new payment request
from the receiver, then an interactive protocol can be used to allow a
degree of payment request reuse.</simpara>
</section>
<section id="_bolt_11_lightning_payment_request_serialization_span_class_keep_together_and_interpretation_span">
<title>BOLT #11: Lightning Payment Request Serialization <span class="keep-together">and Interpretation</span></title>
<simpara><indexterm>
  <primary>BOLT (Basis of Lightning Technology) standards documents</primary><secondary>Lightning payment request serialization/interpretation</secondary>
</indexterm>
<indexterm>
  <primary>Lightning payment request serialization/interpretation</primary>
</indexterm><indexterm>
  <primary>Lightning invoices</primary><secondary>payment request serialization/interpretation</secondary>
</indexterm>
<indexterm>
  <primary>payment request serialization/interpretation</primary>
</indexterm>In this section, we&#8217;ll describe the mechanism used to encode the set of
information required to complete a payment on the Lightning Network. As
mentioned earlier, the payment hash and destination is the minimum amount of
information required to complete a payment. However, in practice, more
information such as timelock information, payment request expiration, and
possibly an on-chain fallback address are also communicated. The full specification document is <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/11-payment-encoding.md">BOLT #11: Invoice Protocol for Lightning Payments</ulink>.</simpara>
<section id="_payment_request_encoding_in_practice">
<title>Payment Request Encoding in Practice</title>
<simpara><indexterm>
  <primary>Lightning invoices</primary><secondary>payment request encoding in practice</secondary>
</indexterm>
<indexterm>
  <primary>payment request encoding in practice</primary>
</indexterm>First, let&#8217;s examine what a real payment request looks like in practice. The
following is a valid payment request that could have been used to complete a
payment on the mainnet Lightning Network at the time it was created:</simpara>
<screen>lnbc2500u1pvjluezpp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqdq5xysx
xatsyp3k7enxv4jsxqzpuaztrnwngzn3kdzw5hydlzf03qdgm2hdq27cqv3agm2awhz5se903vruatf
hq77w3ls4evs3ch9zw97j25emudupq63nyw24cg27h2rspfj9srp</screen>
</section>
<section id="_the_human_readable_prefix">
<title>The Human-Readable Prefix</title>
<simpara><indexterm>
  <primary>human-readable prefixes</primary>
</indexterm><indexterm>
  <primary>Lightning invoices</primary><secondary>human-readable prefix</secondary>
</indexterm>
<indexterm>
  <primary>human-readable prefix</primary>
</indexterm>Looking at the string, we can tease out a portion that we can parse with our
eyes, while the rest of it just looks like a random set of strings. The part
that is somewhat parsable by a human is referred to as the <emphasis>human-readable prefix</emphasis>. It allows a human to quickly extract some relevant information from a
payment request at a glance. In this case, we can see that this payment is for
the mainnet instance of the Lightning Network (<literal>lnbc</literal>), and is requesting 2,500
uBTC (microbitcoin), or 25,000,000 satoshis. The latter potion is referred
to as the data portion and uses an extensible format to encode the
information required to complete a payment.</simpara>
<simpara>Each version of instance of the Lightning Network (mainnet, testnet, etc.) has
its own human-readable prefix (see <xref linkend="table1501"/>). This allows client software and also humans to
quickly determine if a payment request can be satisfied by their node or not.</simpara>
<table id="table1501" role="pagebreak-before less_space"
frame="all"
rowsep="1" colsep="1"
>
<title>BOLT #11 network prefixes</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Network       </entry>
<entry align="left" valign="top">BOLT #11 prefix</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>mainnet</simpara></entry>
<entry align="left" valign="top"><simpara><literal>lnbc</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>testnet</simpara></entry>
<entry align="left" valign="top"><simpara><literal>lntb</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>simnet/regtest</simpara></entry>
<entry align="left" valign="top"><simpara><literal>lnbcrt</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The first portion of the human-readable prefix is a <emphasis>compact</emphasis> expression of the
amount of the payment request. The compact amount is encoded in two parts. First, an integer is used as the <emphasis>base</emphasis> amount. This is then followed by a
multiplier that allows us to specify distinct order of magnitude increases
offset by the base amount. If we return to our initial example, then we can
take the <literal>2500u</literal> portion and decrease it by a factor of 1,000 to instead use
<literal>2500m</literal> or (2,500 mBTC).  As a rule of thumb, to ascertain the amount
of an invoice at a glance, take the base factor and multiply it by the
multiplier.</simpara>
<simpara>A full list of the currently defined multipliers is given in <xref linkend="table1502"/>.</simpara>
<table id="table1502"
frame="all"
rowsep="1" colsep="1"
>
<title>BOLT #11 amount multipliers</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Multiplier</entry>
<entry align="left" valign="top">Bitcoin unit</entry>
<entry align="left" valign="top">Multiplication factor</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>m</literal></simpara></entry>
<entry align="left" valign="top"><simpara>milli</simpara></entry>
<entry align="left" valign="top"><simpara>0.001</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>u</literal></simpara></entry>
<entry align="left" valign="top"><simpara>micro</simpara></entry>
<entry align="left" valign="top"><simpara>0.000001</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara>nano</simpara></entry>
<entry align="left" valign="top"><simpara>0.000000001</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>p</literal></simpara></entry>
<entry align="left" valign="top"><simpara>pico</simpara></entry>
<entry align="left" valign="top"><simpara>0.000000000001</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="_bech32_and_the_data_segment">
<title>bech32 and the Data Segment</title>
<simpara><indexterm>
  <primary>bech32, Lightning invoices and</primary>
</indexterm><indexterm>
  <primary>Lightning invoices</primary><secondary>bech32 and data segment</secondary>
</indexterm>
<indexterm>
  <primary>bech32 and data segment</primary>
</indexterm>If the "unreadable" portion looks familiar, then that&#8217;s because it uses the
very same encoding scheme as SegWit compatible Bitcoin addresses use today,
namely bech32. Describing the bech32 encoding scheme is outside the scope
of this chapter. In brief, it&#8217;s a sophisticated way to encode short strings
that has very good error correction as well as detection properties.</simpara>
<simpara>The data portion can be separated into three sections:</simpara>
<itemizedlist>
<listitem>
<simpara>
The timestamp
</simpara>
</listitem>
<listitem>
<simpara>
Zero or more tagged key-value pairs
</simpara>
</listitem>
<listitem>
<simpara>
The signature of the entire invoice
</simpara>
</listitem>
</itemizedlist>
<simpara>The timestamp is expressed in seconds since the year 1970, or the Unix Epoch. This
timestamp allows the sender to gauge how old the invoice is, and as we&#8217;ll see
later, allows the receiver to force an invoice to only be valid for a period of
time if they wish.</simpara>
<simpara>Similar to the TLV format we learned about in <xref linkend="tlv"/>, the BOLT #11 invoice
format uses a series of extensible key-value pairs to encode information
needed to satisfy a payment. Because key-value pairs are used, it&#8217;s easy to add
new values in the future if a new payment type or additional
requirement/functionality is introduced.</simpara>
<simpara>Finally, a signature is included that covers the entire invoice signed by the
destination of the payment. This signature allows the sender to verify that the
payment request was indeed created by the destination of the payment. Unlike
Bitcoin payment requests which aren&#8217;t signed, this allows us to ensure that a
particular entity signed the payment request. The signature itself is encoded
using a recovery ID, which allows a more compact signature to be used that
allows public key extraction. When verifying the signature, the recovery ID
extracts the public key, then verifies that against the public key included in
the invoice.</simpara>
<section id="_tagged_invoice_fields">
<title>Tagged invoice fields</title>
<simpara><indexterm>
  <primary>Lightning invoices</primary><secondary>tagged invoice fields</secondary>
</indexterm>
<indexterm>
  <primary>tagged invoice fields</primary>
</indexterm>The tagged invoice fields are encoded in the main body of the invoice. These
fields represent different key-value pairs that express either additional
information that may help complete the payment or information which is
<emphasis>required</emphasis> to complete the payment. Because a slight variant of bech32 is
utilized, each of these fields are actually in the "base 5" domain.</simpara>
<simpara>A given tag field is comprised of three components:</simpara>
<itemizedlist>
<listitem>
<simpara>
The <literal>type</literal> of the field (5 bits)
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>length</literal> of the data of the field (10 bits)
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>data</literal> itself, which is <literal>length * 5 bytes</literal> in size
</simpara>
</listitem>
</itemizedlist>
<simpara>A full list of all the currently defined tagged fields is given in <xref linkend="table1503"/>.</simpara>
<table id="table1503"
frame="all"
rowsep="1" colsep="1"
>
<title>BOLT #11 tagged invoice fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><span class="keep-together">Field tag</span></entry>
<entry align="left" valign="top"><span class="keep-together">Data length</span></entry>
<entry align="left" valign="top">Usage</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>p</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>52</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The SHA-256 payment hash.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>s</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>52</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A 256-bit secret that increases the end-to-end privacy of a payment by mitigating probing by intermediate nodes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>d</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Variable</simpara></entry>
<entry align="left" valign="top"><simpara>The description, a short UTF-8 string of the purpose of the payment.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>53</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The public key of the destination node.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>h</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>52</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A hash that represents a description of the payment itself. This can be used to commit to a description that&#8217;s over 639 bytes in length.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>x</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Variable</simpara></entry>
<entry align="left" valign="top"><simpara>The expiry time, in seconds, of the payment. The default is 1 hour (3,600) if not specified.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>c</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Variable</simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>min_cltv_expiry</literal> to use for the final hop in the route. The default is 9 if not specified.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>f</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Variable</simpara></entry>
<entry align="left" valign="top"><simpara>A fallback on-chain address to be used to complete the payment if the payment cannot be completed over the Lightning Network.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>r</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Variable</simpara></entry>
<entry align="left" valign="top"><simpara>One or more entries that allow a receiver to give the sender additional ephemeral edges to complete the payment.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>9</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Variable</simpara></entry>
<entry align="left" valign="top"><simpara>A set of 5-bit values that contain the feature bits that are required in order to complete the payment.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The elements contained in the field <literal>r</literal> are commonly referred to as <emphasis>routing hints</emphasis>. They allow the receiver to communicate an extra set of edges that may
help the sender complete their payment. The hints are usually used when the
receiver has some/all private channels, and they wish to guide the sender into
this "unmapped" portion of the channel graph. A routing hint encodes
effectively the same information that a normal <literal>channel_update</literal> message does.
The update is itself packed into a single value with the following fields:</simpara>
<itemizedlist>
<listitem>
<simpara>
The <literal>pubkey</literal> of the outgoing node in the edge (264 bits)
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>short_channel_id</literal> of the "virtual" edge (64 bits)
</simpara>
</listitem>
<listitem>
<simpara>
The base fee (<literal>fee_base_msat</literal>) of the edge (32 bits)
</simpara>
</listitem>
<listitem>
<simpara>
The proportional fee (<literal>fee_proportional_millionths</literal>) (32 bits)
</simpara>
</listitem>
<listitem>
<simpara>
The CLTV expiry delta (<literal>cltv_expiry_delta</literal>) (16 bits)
</simpara>
</listitem>
</itemizedlist>
<simpara>The final portion of the data segment is the set of feature bits that
communicate to the sender the functionality needed to complete a
payment. As an example, if a new payment type is added in the future that isn&#8217;t
backward compatible with the original payment type, then the receiver can set
a <emphasis>required</emphasis> feature bit to communicate that the payer needs to
understand that feature to complete the payment.</simpara>
</section>
</section>
</section>
<section id="_conclusion_14">
<title>Conclusion</title>
<simpara>As we have seen, invoices are a lot more than just a request for an amount. They contain critical information about <emphasis>how</emphasis> to make the payment, such as routing hints, the destination node&#8217;s public key, ephemeral keys to increase security, and much more.<indexterm>
</indexterm></simpara>
</section>
</chapter>
<chapter id="security_and_privacy">
<title>Security and Privacy of the <span class="keep-together">Lightning Network</span></title>
<simpara><indexterm>
  <primary>security and privacy</primary>
</indexterm>In this chapter, we look at some of the most important issues related to the security and privacy of the Lightning Network. First, we&#8217;ll consider privacy, what it means, how to evaluate it, and some things you can do to protect your own privacy while using the Lightning Network. Then we&#8217;ll explore some common attacks and mitigation techniques.</simpara>
<section id="_why_is_privacy_important">
<title>Why Is Privacy Important?</title>
<simpara><indexterm>
  <primary>security and privacy</primary><secondary>importance of privacy</secondary>
</indexterm>
<indexterm>
  <primary>importance of privacy</primary>
</indexterm>The key value proposition of cryptocurrency is censorship resistant money. Bitcoin offers participants the possibility of storing and transferring their wealth without interference by governments, banks, or corporations. The Lightning Network continues this mission.</simpara>
<simpara>Unlike trivial scaling solutions like custodial Bitcoin banks, the Lightning Network aims to scale Bitcoin without compromising on self custody, which should lead to greater censorship resistance in the Bitcoin ecosystem. However, the Lightning Network operates under a different security model, which introduces novel security and privacy challenges.</simpara>
</section>
<section id="_definitions_of_privacy">
<title>Definitions of Privacy</title>
<simpara><indexterm>
  <primary>security and privacy</primary><secondary>definitions of privacy</secondary>
</indexterm>
<indexterm>
  <primary>definitions of privacy</primary>
</indexterm>The question, "Is Lightning private?" has no direct answer. Privacy is a complex topic; it is often difficult to precisely define what we mean by privacy, particularly if you are not a privacy researcher. Fortunately, privacy researchers use processes to analyze and evaluate the privacy characteristics of systems, and we can use them too! Let&#8217;s look at how a security researcher might seek to answer the question, "Is Lightning private?" in two general steps.</simpara>
<simpara>First, a privacy researcher would define a <emphasis>security model</emphasis> that specifies what an adversary is capable of and aims to achieve.
Then, they would describe the relevant properties of the system and check whether it conforms to the requirements.</simpara>
</section>
<section id="_process_to_evaluate_privacy">
<title>Process to Evaluate Privacy</title>
<simpara><indexterm>
  <primary>security and privacy</primary><secondary>evaluation process for privacy</secondary>
</indexterm>
<indexterm>
  <primary>evaluation process for privacy</primary>
</indexterm><indexterm>
  <primary>security assumptions</primary>
</indexterm>A security model is based on a set of underlying <emphasis>security assumptions</emphasis>.
In cryptographic systems, these assumptions are often centered around the mathematical properties of the cryptographic primitives, such as ciphers, signatures, and hash functions.
The security assumptions of the Lightning Network are that the ECDSA signatures, SHA-256 hash function, and other cryptographic functions used in the protocol behave within their security definitions.
For example, we assume that it is practically impossible to find a preimage (and second preimage) of a hash function.
This allows the Lightning Network to rely on the HTLC mechanism (which uses the preimage of a hash function) for the atomicity of multihop payments: nobody except the final recipient can reveal the payment secret and resolve the HTLC.
We also assume a degree of connectivity in the network, namely that Lightning channels form a connected graph. Therefore, it is possible to find a path from any sender to any receiver. Finally, we assume network messages are propagated within certain timeouts.</simpara>
<simpara>Now that we&#8217;ve identified some of our underlying assumptions, let&#8217;s consider some possible adversaries.</simpara>
<simpara>Here are some possible models of adversaries in the Lightning Network.
An "honest-but-curious" forwarding node can observe payment amounts, the immediately preceding and following nodes, and the graph of announced channels with their capacities.
A very well-connected node can do the same but to a larger extent.
For example, consider the developers of a popular wallet who maintain a node that their users connect to by default.
This node would be responsible for routing a large share of payments to and from the users of that wallet.
What if multiple nodes are under adversarial control?
If two colluding nodes happen to be on the same payment path, they would understand that they are forwarding HTLCs belonging to the same payment because HTLCs have the same payment hash.</simpara>
<note>
<simpara>Multipart payments (see <xref linkend="mpp"/>) enable users to obfuscate their payment amounts given their nonuniform split sizes.</simpara>
</note>
<simpara>What may be the goals of a Lightning attacker?
Information security is often described in terms of three main properties: confidentiality, integrity, and availability.</simpara>
<variablelist>
<varlistentry>
<term>
Confidentiality
</term>
<listitem>
<simpara>
The information only gets to intended recipients.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Integrity
</term>
<listitem>
<simpara>
The information does not get altered in transit.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Availability
</term>
<listitem>
<simpara>
The system is functioning most of the time.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The important properties of the Lightning Network are mostly centered around confidentiality and availability. Some of the most important properties to protect include:</simpara>
<itemizedlist>
<listitem>
<simpara>
Only the sender and the receiver know the payment amount.
</simpara>
</listitem>
<listitem>
<simpara>
No one can link senders and receivers.
</simpara>
</listitem>
<listitem>
<simpara>
An honest user cannot be blocked from sending and receiving payments.
</simpara>
</listitem>
</itemizedlist>
<simpara>For each privacy goal and security model, there is a certain probability that an attacker succeeds.
This probability depends on various factors, such as the size and structure of the network.
Other things being equal, it is generally easier to successfully attack a small network rather than a large one.
Similarly, the more centralized the network is, the more capable an attacker can be if "central" nodes are under their control.
Of course, the term centralization must be defined precisely to build security models around it, and there are many possible definitions of how centralized a network is.
Finally, as a payment network, the Lightning Network depends on economic stimuli.
The size and structure of fees affect the routing algorithm, and therefore can either aid the attacker by forwarding most payments through their nodes or prevent this from happening.<indexterm>
</indexterm></simpara>
</section>
<section id="_anonymity_set">
<title>Anonymity Set</title>
<simpara><indexterm>
  <primary>anonymity set</primary>
</indexterm><indexterm>
  <primary>de-anonymization</primary>
</indexterm><indexterm>
  <primary>security and privacy</primary><secondary>anonymity set</secondary>
</indexterm>
<indexterm>
  <primary>anonymity set</primary>
</indexterm>What does it mean to de-anonymize someone?
In simple terms, de-anonymization implies linking some action with a person&#8217;s real-world identity, such as their name or physical address.
In privacy research, the notion of de-anonymization is more nuanced.
First, we are not necessarily talking about names and addresses.
Discovering someone&#8217;s IP address or telephone number may also be considered de-anonymization.
A piece of information that allows linking a user&#8217;s action to their previous actions is referred to as <emphasis>identity</emphasis>.
Second, de-anonymization is not binary; a user is neither fully anonymous nor completely de-anonymized.
Instead, privacy research looks at anonymity compared to the anonymity set.</simpara>
<simpara>The <emphasis>anonymity set</emphasis> is a central notion in privacy research.
It refers to the set of identities such that, from an attacker&#8217;s viewpoint, a given action could correspond to anyone in the set.
Consider a real-life example.
Imagine you meet a person on a city street.
What is their anonymity set from your point of view?
If you don&#8217;t know them personally, and without any additional information, their anonymity set roughly equals the city&#8217;s population, including travelers.
If you additionally consider their appearance, you may be able to roughly estimate their age and exclude the city residents who are obviously older or younger than the person in question from the anonymity set.
Furthermore, if you notice that the person walks into the office of Company X using an electronic badge, the anonymity set shrinks to the number <span class="keep-together">of Company</span> X&#8217;s employees and visitors.
Finally, you may notice the license number of the car they used to arrive at the place.
If you are a casual observer, this doesn&#8217;t give you much.
However, if you are a city official and have access to the database that matches license plate numbers with names, you can narrow down the anonymity set to just a few people: the car owner and any close friends and relatives that may have borrowed the car.</simpara>
<simpara>This example illustrates a few important points.
First, every bit of information may bring the adversary closer to their goal.
It may not be necessary to shrink the anonymity set to the size of one.
For instance, if the adversary plans a targeted denial-of-service (DoS) attack and can take down 100 servers, the anonymity set of 100 suffices.
Second, the adversary can cross-correlate information from different sources.
Even if a privacy leak looks relatively benign, we never know what it can achieve in combination with other data sources.
Finally, especially in cryptographic settings, the attacker always has the "last resort" of a brute-force search.
Cryptographic primitives are designed so that it is practically impossible to guess a secret such as a private key.
Nevertheless, each bit of information brings the adversary closer to this goal, and at some point, it becomes attainable.</simpara>
<simpara>In terms of Lightning, de-anonymizing generally means deriving a correspondence between payments and users identified by node IDs.
Each payment may be assigned a sender anonymity set and a receiver anonymity set.
Ideally, the anonymity set consists of all the users of the network.
This assures that the attacker has no information whatsoever.
However, the real network leaks information that allows an attacker to narrow down the search.
The smaller the anonymity set, the higher the chance of successful de-anonymization.</simpara>
</section>
<section id="_differences_between_the_lightning_network_and_bitcoin_in_terms_of_privacy" role="pagebreak-before less_space">
<title>Differences Between the Lightning Network and Bitcoin in Terms of Privacy</title>
<simpara><indexterm>
  <primary>security and privacy</primary><secondary>differences between Lightning Network and Bitcoin in terms of privacy</secondary>
</indexterm>
<indexterm>
  <primary>differences between Lightning Network and Bitcoin in terms of privacy</primary>
</indexterm>While it&#8217;s true that transactions on the Bitcoin network do not associate real-world identities with Bitcoin addresses, all transactions are broadcast in cleartext and can be analyzed.
Multiple companies have been established to de-anonymize users of Bitcoin and other cryptocurrencies.</simpara>
<simpara>At first glance, Lightning provides better privacy than Bitcoin because Lightning payments are not broadcast to the whole network.
While this improves the privacy baseline, other properties of the Lightning protocol may make anonymous payments more challenging.
For instance, larger payments may have fewer routing options.
This may allow an adversary who controls well-capitalized nodes to route most large payments and discover payment amounts and probably other details. Over time, as the Lightning Network grows, this may become less of a problem.</simpara>
<simpara>Another relevant difference between Lightning and Bitcoin is that Lightning nodes maintain a permanent identity, whereas Bitcoin nodes do not.
A sophisticated Bitcoin user can easily switch nodes used to receive blockchain data and broadcast transactions.
A Lightning user, on the contrary, sends and receives payments through the nodes they have used to open their payment channels.
Moreover, the Lightning protocol assumes that routing nodes announce their IP address in addition to their node ID.
This creates a permanent link between node IDs and IP addresses, which may be dangerous, considering that an IP address is often an intermediary step in anonymity attacks linked to the user&#8217;s physical location and, in most cases, real-world identity.
It is possible to use Lightning over Tor, but many nodes do not use this functionality, as can be seen from <ulink url="https://1ml.com/statistics">statistics collected from node announcements</ulink>.</simpara>
<simpara>A Lightning user, when sending a payment, has its neighbors in its anonymity set.
Specifically, a routing node only knows the immediately preceding and following nodes.
The routing node does not know whether its immediate neighbors in the payment route are the ultimate sender or receiver.
Therefore, the anonymity set of a node in Lightning roughly equals its neighbors (see <xref linkend="anonymity_set"/>).</simpara>
<figure id="anonymity_set"><title>The anonymity set of Alice and Bob constitutes their neighbors</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1601.png"/>
  </imageobject>
  <textobject><phrase>The anonymity set of Alice and Bob constitutes their neighbors</phrase></textobject>
</mediaobject>
</figure>
<simpara>Similar logic applies to payment receivers.
Many users open only a handful of payment channels, therefore limiting their anonymity sets.
Moreover, in Lightning, the anonymity set is static or at least slowly changing.
In contrast, one can achieve significantly larger anonymity sets in on-chain CoinJoin transactions.
CoinJoin transactions with anonymity sets larger than 50 are quite frequent.
Typically, the anonymity sets in a CoinJoin transaction correspond to a dynamically changing set of users.</simpara>
<simpara>Finally, Lightning users can also be denied service, having their channels blocked or depleted by an attacker.
Forwarding payments requires capital—a scarce resource!—to be temporarily blocked in HTLCs along the route.
An attacker may send many payments but fail to finalize them, occupying honest users' capital for long periods.
This attack vector is not present (or at least not as obvious) in Bitcoin.</simpara>
<simpara>In summary, while some aspects of the Lightning Network&#8217;s architecture suggest that it is a step forward in terms of privacy compared to Bitcoin, other properties of the protocol may make attacks on privacy easier. Thorough research is needed to evaluate what privacy guarantees the Lightning Network provides and improve the state of affairs.</simpara>
<simpara>The issues discussed in this part of the chapter summarize research available in mid-2021. However, this area of research and development is growing quickly. We are happy to report that the authors are aware of multiple research teams currently working on Lightning privacy.</simpara>
<simpara>Now let&#8217;s review some of the attacks on LN privacy that have been described in academic literature.<indexterm>
</indexterm></simpara>
</section>
<section id="_attacks_on_lightning">
<title>Attacks on Lightning</title>
<simpara><indexterm>
  <primary>security and privacy</primary><secondary>attacks on Lightning</secondary>
</indexterm>
<indexterm>
  <primary>attacks on Lightning</primary>
</indexterm>Recent research describes various ways in which the security and privacy of the Lightning Network may be compromised.</simpara>
<section id="_observing_payment_amounts">
<title>Observing Payment Amounts</title>
<simpara><indexterm>
  <primary>breaches of privacy</primary><secondary>observing payment amounts</secondary>
</indexterm>
<indexterm>
  <primary>observing payment amounts</primary>
</indexterm>One of the goals for a privacy-preserving payment system is to hide the payment amount from uninvolved parties.
The Lightning Network is an improvement over Layer 1 in this regard.
While Bitcoin transactions are broadcast in cleartext and can be observed by anyone, Lightning payments only travel through a few nodes along the payment path.
However, intermediary nodes do see the payment amount, although this payment amount might not correspond to the actual total payment amount (see <xref linkend="mpp"/>).
This is necessary to create a new HTLC at every hop.
The availability of payment amounts to intermediary nodes do not present an immediate threat.
However, an <emphasis>honest-but-curious</emphasis> intermediary node may use it as a part of a larger attack.</simpara>
</section>
<section id="_linking_senders_and_receivers">
<title>Linking Senders and Receivers</title>
<simpara><indexterm>
  <primary>breaches of privacy</primary><secondary>linking senders and receivers</secondary>
</indexterm>
<indexterm>
  <primary>linking senders and receivers</primary>
</indexterm>An attacker might be interested in learning the sender and/or the receiver of a payment to reveal certain economic relationships.
This breach of privacy could harm censorship resistance, as an intermediary node could censor payments to or from certain receivers or senders.
Ideally, linking senders to receivers should not be possible to anyone other than the sender and the receiver.</simpara>
<simpara>In the following sections, we will consider two types of adversaries: the off-path adversary and the on-path adversary.
An off-path adversary tries to assess the sender and the receiver of a payment without participating in the payment routing process.
An on-path adversary can leverage any information it might gain by routing the payment of interest.</simpara>
<simpara><indexterm>
  <primary>off-path adversary</primary>
</indexterm>First, consider the <emphasis>off-path adversary</emphasis>.
In the first step of this attack scenario, a potent off-path adversary deduces the individual balances in each payment channel via probing (described in a subsequent section) and forms a network snapshot at time <emphasis>t<subscript>1</subscript></emphasis>. For simplicity&#8217;s sake, let&#8217;s make <emphasis>t<subscript>1</subscript></emphasis> equal 12:05.
It then probes the network again at sometime later at time <emphasis>t<subscript>2</subscript></emphasis>, which we&#8217;ll make 12:10. The attacker would then compare the snapshots at 12:10 and 12:05 and use the differences between the two snapshots to infer information about payments that took place by looking at paths that have changed.
In the simplest case, if only one payment occurred between 12:10 and 12:05, the adversary would observe a single path where the balances have changed by the same amounts.
Thus, the adversary learns almost everything about this payment: the sender, the recipient, and the amount.
If multiple payment paths overlap, the adversary needs to apply heuristics to identify such overlap and separate the payments.</simpara>
<simpara><indexterm>
  <primary>on-path adversary</primary>
</indexterm>Now, we turn our attention to an <emphasis>on-path adversary</emphasis>.
Such an adversary might seem convoluted.
However, in June 2020, researchers noted that the single most central node <ulink url="https://arxiv.org/pdf/2006.12143.pdf">observed close to 50% of all LN payments</ulink>, while the four most central nodes <ulink url="https://arxiv.org/pdf/1909.06890.pdf">observed an average of 72% payments</ulink>.
These findings emphasize the relevance of the on-path attacker model.
Even though intermediaries in a payment path only learn their successor and predecessor, there are several leakages that a malicious or honest-but-curious intermediary might use to infer the sender and the receiver.</simpara>
<simpara>The on-path adversary can observe the amount of any routed payment as well as timelock deltas (see <xref linkend="onion_routing"/>).
Hence, the adversary can exclude any nodes from the sender&#8217;s or the receiver&#8217;s anonymity set with capacities lower than the routed amount.
Therefore, we observe a trade-off between privacy and payment amounts.
Typically, the larger the payment amount is, the smaller the anonymity sets are.
We note that this leakage could be minimized with multipart payments or with large capacity payment channels.
Similarly, payment channels with small timelock deltas could be excluded from a payment path.
More precisely, a payment channel cannot pertain to a payment if the remaining time the payment might be locked for is larger than what the forwarding node would be willing to accept.
This leakage could be evicted by adhering to the so-called shadow routes.</simpara>
<simpara>One of the most subtle and yet powerful leakages an on-path adversary can foster is the timing analysis.
An on-path adversary can keep a log for every routed payment, along with the amount of time it takes for a node to respond to an HTLC request.
Before starting the attack, the attacker learns every node&#8217;s latency characteristics in the Lightning Network by sending them requests.
Naturally, this can aid in establishing the adversary&#8217;s precise position in the payment path.
Even more, as it was recently shown, an attacker can successfully determine the sender and the receiver of a payment from a set of possible senders and receivers using time-based estimators.</simpara>
<simpara>Finally, it&#8217;s important to recognize that unknown or unstudied leakages probably exist that could aid de-anonymizing attempts. For instance, because different Lightning wallets apply different routing algorithms, even knowing the applied routing algorithm could help exclude certain nodes from being a sender and/or receiver of a payment.<indexterm>
</indexterm></simpara>
</section>
<section id="_revealing_channel_balances_probing">
<title>Revealing Channel Balances (Probing)</title>
<simpara><indexterm>
  <primary>breaches of privacy</primary><secondary>revealing channel balances</secondary>
</indexterm>
<indexterm>
  <primary>revealing channel balances</primary>
</indexterm><indexterm>
  <primary>channel balances, revealing</primary>
</indexterm><indexterm>
  <primary>channel probing</primary>
</indexterm><indexterm>
  <primary>probing attack</primary>
</indexterm>The balances of Lightning channels are supposed to be hidden for privacy and efficiency reasons.
A Lightning node only knows the balances of its adjacent channels.
The protocol provides no standard way to query the balance of a remote channel.</simpara>
<simpara>However, an attacker can reveal the balance of a remote channel in a <emphasis>probing attack</emphasis>.
In information security, probing refers to the technique of sending requests to a targeted system and making conclusions about its private state based on the received responses.</simpara>
<simpara>Lightning channels are prone to probing.
Recall that a standard Lightning payment starts with the receiver creating a random payment secret and sending its hash to the sender.
Note that for the intermediary nodes, all hashes look random.
There is no way to tell whether a hash corresponds to a real secret or was generated randomly.</simpara>
<simpara>The probing attack proceeds as follows.
Say the attacker Mallory wants to reveal Alice&#8217;s balance of a public channel between Alice and Bob.
Suppose the total capacity of that channel is 1 million satoshis.
Alice&#8217;s balance could be anything from zero to 1 million satoshis (to be precise, the estimate is a bit tighter due to channel reserve, but we don&#8217;t account for it here for simplicity).
Mallory opens a channel with Alice with 1 million satoshis and sends 500,000 satoshis to Bob via Alice using a <emphasis>random number</emphasis> as the payment hash.
Of course, this number does not correspond to any known payment secret.
Therefore, the payment will fail.
The question is: how exactly will it fail?</simpara>
<simpara>There are two scenarios.
If Alice has more than 500,000 satoshis on her side of the channel to Bob, she forwards the payment.
Bob decrypts the payment onion and realizes that the payment is intended for him.
He looks up his local store of payment secrets and searches for the preimage that corresponds to the payment hash, but does not find one.
Following the protocol, Bob returns the "unknown payment hash" error to Alice, who relays it back to Mallory.
As a result, Mallory knows that the payment <emphasis>could have succeeded</emphasis> if the payment hash was real.
Therefore, Mallory can update her estimation of Alice&#8217;s balance from "between zero and 1 million" to "between 500,000 and 1 million."
Another scenario happens if Alice&#8217;s balance is lower than 500,000 satoshis.
In that case, Alice is unable to forward the payment and returns the "insufficient balance" error to Mallory.
Mallory updates her estimation from "between zero and 1 million" to "between zero and 500,000."</simpara>
<simpara>Note that in any case, Mallory&#8217;s estimation becomes twice as precise after just one probing!
She can continue probing, choosing the next probing amount such that it divides the current estimation interval in half.
<indexterm>
  <primary>binary search</primary>
</indexterm>This well-known search technique is called <emphasis>binary search</emphasis>.
With binary search, the number of probes is <emphasis>logarithmic</emphasis> in the desired precision.
For example, to obtain Alice&#8217;s balance in a channel of 1 million satoshis up to a single satoshi, Mallory would only have to perform log<subscript>2</subscript> (1,000,000) &asymp; 20 probings.
If one probing takes 3 seconds, one channel can be precisely probed in only about a minute!</simpara>
<simpara>Channel probing can be made even more efficient.
In its simplest variant, Mallory directly connects to the channel she wants to probe.
Is it possible to probe a channel without opening a channel to one of its endpoints?
Imagine Mallory now wants to probe a channel between Bob and Charlie but doesn&#8217;t want to open another channel, which requires paying on-chain fees and waiting for confirmations of the funding transactions.
Instead, Mallory reuses her existing channel to Alice and sends a probe along the route Mallory &#8594; Alice &#8594; Bob &#8594; Charlie.
Mallory can interpret the "unknown payment hash" error in the same way as before: the probe has reached the destination; therefore, all channels along the route have sufficient balances to forward it.
But what if Mallory receives the "insufficient balance" error?
Does it mean that the balance is insufficient between Alice and Bob or between Bob and Charlie?</simpara>
<simpara>In the current Lightning protocol, error messages report not only <emphasis>which</emphasis> error occurred but also <emphasis>where</emphasis> it happened.
So, with more careful error handling, Mallory now knows which channel failed.
If this is the target channel, she updates her estimates; if not, she chooses another route to the target channel.
She even gets <emphasis>additional</emphasis> information about the balances of intermediary channels, on top of that of the target channel.</simpara>
<simpara>The probing attack can be further used to link senders and receivers, as described in the previous section.</simpara>
<simpara>At this point, you may ask: why does the Lightning Network do such a poor job at protecting its users' private data?
Wouldn&#8217;t it be better to not reveal to the sender why and where the payment has failed?
Indeed, this could be a potential countermeasure, but it has significant drawbacks.
Lightning has to strike a careful balance between privacy and efficiency.
Remember that regular nodes don&#8217;t know balance distributions in remote channels.
Therefore, payments can (and often do) fail because of insufficient balance at an intermediary hop.
Error messages allow the sender to exclude the failing channel from consideration when constructing another route.
One popular Lightning wallet even performs probing internally to check whether a constructed route can really handle a payment.</simpara>
<simpara>There are other potential countermeasures against channel probing.
First, it is hard for an attacker to target unannounced channels.
Second, nodes that implement just-in-time (JIT) routing may be less prone to the attack.
Finally, as multipart payments make the problem of insufficient capacity less severe, the protocol developers may consider hiding some of the error details without harming efficiency.<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
<section id="denial_of_service">
<title>Denial of Service</title>
<simpara><indexterm>
  <primary>breaches of privacy</primary><secondary>denial-of-service attacks</secondary>
</indexterm>
<indexterm>
  <primary>denial-of-service attacks</primary>
</indexterm><indexterm>
  <primary>denial-of-service (DoS) attacks</primary>
</indexterm>When resources are made publicly available, there is a risk that attackers may attempt to make that resource unavailable by executing a denial-of-service (DoS) attack.
Generally, this is achieved by the attacker bombarding a resource with requests, which are indistinguishable from legitimate queries.
The attacks seldom result in the target suffering financial loss, aside from the opportunity cost of their service being down, and are merely intended to aggrieve the target.</simpara>
<simpara>Typical mitigations for DoS attacks require authentication for requests to separate legitimate users from malicious ones. These mitigations incur a trivial cost to regular users but will act as a sufficient deterrent to an attacker launching requests at scale.
Anti-denial-of-service measures can be seen everywhere on the internet—websites apply rate limits to ensure that no one user can consume all of their server&#8217;s attention, film review sites require login authentication to keep angry r/prequelmemes (Reddit group) members at bay, and data services sell API keys to limit the number of queries.</simpara>
<section id="_dos_in_bitcoin">
<title>DoS in bitcoin</title>
<simpara><indexterm>
  <primary>Bitcoin (system)</primary><secondary>DoS attacks</secondary>
</indexterm>
<indexterm>
  <primary>DoS attacks</primary>
</indexterm><indexterm>
  <primary>denial-of-service (DoS) attacks</primary><secondary>DoS in Bitcoin</secondary>
</indexterm>
<indexterm>
  <primary>DoS in Bitcoin</primary>
</indexterm>In Bitcoin, the bandwidth that nodes use to relay transactions and the space that they avail to the network in the form of their mempool are publicly available resources.
Any node on the network can consume bandwidth and mempool space by sending a valid transaction.
If this transaction is mined in a valid block, they will pay transaction fees, which adds a cost to using these shared network resources.</simpara>
<simpara>In the past, the Bitcoin network faced an attempted DoS attack where attackers spammed the network with low-fee transactions.
Many of these transactions were not selected by miners due to their low transaction fees, so the attackers could consume network resources without paying the fees.
To address this issue, a minimum transaction relay fee that set a threshold fee that nodes require to propagate transactions was set.
This measure largely ensured that the transactions that consume network resources will eventually pay their chain fees.
The minimum relay fee is acceptable to regular users but would hurt attackers financially if they tried to spam the network.
While some transactions may not make it into valid blocks within high-fee environments, these measures have largely been effective at deterring this type of spam.</simpara>
</section>
<section id="_dos_in_lightning">
<title>DoS in Lightning</title>
<simpara><indexterm>
  <primary>denial-of-service (DoS) attacks</primary><secondary>DoS in Lightning</secondary>
</indexterm>
<indexterm>
  <primary>DoS in Lightning</primary>
</indexterm>Similarly to Bitcoin, the Lightning Network charges fees for the use of its public resources, but in this case, the resources are public channels, and the fees come in the form of routing fees.
The ability to route payments through nodes in exchange for fees provides the network with a large scalability benefit—nodes that are not directly connected can still transact—but it comes at the cost of exposing a public resource that must be protected against DoS attacks.</simpara>
<simpara>When a Lightning node forwards a payment on your behalf, it uses data and payment bandwidth to update its commitment transaction, and the amount of the payment is reserved in their channel balance until it is settled or failed.
In successful payments, this is acceptable because the node is eventually paid out its fees.
Failed payments do not incur fees in the current protocol.
This allows nodes to costlessly route failed payments through any channels.
This is great for legitimate users, who wouldn&#8217;t like to pay for failed attempts, but also allows attackers to costlessly consume nodes' resources—much like the low-fee transactions on Bitcoin that never end up paying miner fees.</simpara>
<simpara>At the time of writing, a discussion is <ulink url="https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002734.html">ongoing</ulink> on the lightning-dev mailing list as to how best address this issue.</simpara>
</section>
<section id="_known_dos_attacks">
<title>Known DoS attacks</title>
<simpara><indexterm>
  <primary>denial-of-service (DoS) attacks</primary><secondary>known DoS attacks</secondary>
</indexterm>
<indexterm>
  <primary>known DoS attacks</primary>
</indexterm>There are two known DoS attacks on public LN channels which render a target channel, or a set of target channels, unusable.
Both attacks involve routing payments through a public channel, then holding them until their timeout, thus maximizing the attack&#8217;s duration.
The requirement to fail payments to not pay fees is fairly simple to meet because malicious nodes can simply reroute payments to themselves.
In the absence of fees for failed payments, the only cost to the attacker is the on-chain cost of opening a channel to dispatch these payments through, which can be trivial in low-fee environments.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_commitment_jamming">
<title>Commitment Jamming</title>
<simpara><indexterm>
  <primary>breaches of privacy</primary><secondary>commitment jamming</secondary>
</indexterm>
<indexterm>
  <primary>commitment jamming</primary>
</indexterm><indexterm>
  <primary>commitment jamming</primary>
</indexterm>Lightning nodes update their shared state using asymmetric commitment transactions, on which HTLCs are added and removed to facilitate payments.
Each party is limited to a total of <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/c053ce7afb4cbf88615877a0d5fc7b8dbe2b9ba0/02-peer-protocol.md#the-open_channel-message">483</ulink> HTLCs in the commitment transaction at a time.
A channel jamming attack allows an attacker to render a channel unusable by routing 483 payments through the target channel and holding them until they time out.</simpara>
<simpara>It should be noted that this limit was chosen in the specification to ensure that all the HTLCs can be swept in a <ulink url="https://github.com/lightningnetwork/lightning-rfc/blob/master/05-onchain.md#penalty-transaction-weight-calculation">single justice transaction</ulink>.
While this limit <emphasis>may</emphasis> be increased, transactions are still limited by the block size, so the number of slots available is likely to remain limited.</simpara>
</section>
<section id="_channel_liquidity_lockup">
<title>Channel Liquidity Lockup</title>
<simpara><indexterm>
  <primary>breaches of privacy</primary><secondary>channel liquidity lockup</secondary>
</indexterm>
<indexterm>
  <primary>channel liquidity lockup</primary>
</indexterm><indexterm>
  <primary>channel liquidity lockup</primary>
</indexterm>A channel liquidity lockup attack is comparable to a channel jamming attack in that it routes payments through a channel and holds them so that the channel is unusable.
Rather than locking up slots on the channel commitment, this attack routes large HTLCs through a target channel, consuming all the channel&#8217;s available bandwidth.
This attack&#8217;s capital commitment is higher than the commitment jamming attack because the attacking node needs more funds to route failed payments through the target.<indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_cross_layer_de_anonymization">
<title>Cross-Layer De-Anonymization</title>
<simpara><indexterm>
  <primary>breaches of privacy</primary><secondary>cross-layer de-anonymization</secondary>
</indexterm>
<indexterm>
  <primary>cross-layer de-anonymization</primary>
</indexterm><indexterm>
  <primary>cross-layer de-anonymization</primary>
</indexterm><indexterm>
  <primary>security and privacy</primary><secondary>cross-layer de-anonymization</secondary>
</indexterm>
<indexterm>
  <primary>cross-layer de-anonymization</primary>
</indexterm>Computer networks are often layered.
Layering allows for separation of concerns and makes the whole system manageable.
No one could design a website if it required understanding all the TCP/IP stack up to the physical encoding of bits in an optical cable.
Every layer is supposed to provide the functionality to the layer above in a clean way.
Ideally, the upper layer should perceive a lower layer as a black box.
In reality, though, implementations are not ideal, and the details <emphasis>leak</emphasis> into the upper layer.
This is the problem of leaky abstractions.</simpara>
<simpara>In the context of Lightning, the LN protocol relies on the Bitcoin protocol and the LN P2P network.
Up to this point, we only considered the privacy guarantees offered by the Lightning Network in isolation.
However, creating and closing payment channels are inherently performed on the Bitcoin blockchain.
Consequently, for a complete analysis of the Lightning Network&#8217;s privacy provisions, one needs to consider every layer of the technological stack users might interact with.
Specifically, a de-anonymizing adversary can and will use off-chain and on-chain data to cluster or link LN nodes to corresponding Bitcoin addresses.</simpara>
<simpara>Attackers attempting to de-anonymize LN users may have various goals, in a cross-layer context:</simpara>
<itemizedlist>
<listitem>
<simpara>
Cluster Bitcoin addresses owned by the same user (Layer 1). We call these Bitcoin entities.
</simpara>
</listitem>
<listitem>
<simpara>
Cluster LN nodes owned by the same user (Layer 2).
</simpara>
</listitem>
<listitem>
<simpara>
Unambiguously link sets of LN nodes to the sets of Bitcoin entities that control them.
</simpara>
</listitem>
</itemizedlist>
<simpara>There are several heuristics and usage patterns that allow an adversary to cluster Bitcoin addresses and LN nodes owned by the same LN users.
Moreover, these clusters can be linked across layers using other powerful cross-layer linking heuristics.
The last type of heuristics, cross-layer linking techniques, emphasizes the need for a holistic view of privacy. Specifically, we must consider privacy in the context of both layers together.</simpara>
<section id="_on_chain_bitcoin_entity_clustering">
<title>On-Chain Bitcoin Entity Clustering</title>
<simpara><indexterm>
  <primary>Bitcoin entities</primary><secondary>entity clustering</secondary>
</indexterm>
<indexterm>
  <primary>entity clustering</primary>
</indexterm><indexterm>
  <primary>cross-layer de-anonymization</primary><secondary>on-chain Bitcoin entity clustering</secondary>
</indexterm>
<indexterm>
  <primary>on-chain Bitcoin entity clustering</primary>
</indexterm><indexterm>
  <primary>on-chain Bitcoin entity clustering</primary>
</indexterm>Lightning Network blockchain interactions are permanently reflected in the Bitcoin entity graph.
Even if a channel is closed, an attacker can observe which address funded the channel and where the coins are spent after closing it.
For this analysis, let&#8217;s consider four separate entities.
Opening a channel causes a monetary flow from a <emphasis>source entity</emphasis> to a <emphasis>funding entity</emphasis>; closing a channel causes a flow from a <emphasis>settlement entity</emphasis> to a <emphasis>destination entity</emphasis>.</simpara>
<simpara>In early 2021, <ulink url="https://arxiv.org/pdf/2007.00764.pdf">Romiti et al.</ulink> identified four heuristics that allow the clustering of these entities.
Two of them capture certain leaky funding behavior and two describe leaky settlement behaviors.</simpara>
<variablelist>
<varlistentry>
<term>
Star heuristic (funding)
</term>
<listitem>
<simpara>
If a component contains one source entity that forwards funds to one or more funding entities, these funding entities are likely controlled by the same user.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Snake heuristic (funding)
</term>
<listitem>
<simpara>
If a component contains one source entity that forwards funds to one or more entities, which themselves are used as source and funding entities, then all these entities are likely controlled by the same user.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Collector heuristic (settlement)
</term>
<listitem>
<simpara>
If a component contains one destination entity that receives funds from one or more settlement entities, these settlement entities are likely controlled by the same user.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Proxy heuristic (settlement)
</term>
<listitem>
<simpara>
If a component contains one destination entity that receives funds from one or more entities, which themselves are used as settlement and destination entities, then these entities are likely controlled by the same user.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>It is worthwhile pointing out that these heuristics might produce false positives.
For instance, if transactions of several unrelated users are combined in a CoinJoin transaction, then the star or the proxy heuristic can produce false positives.
This could happen if users are funding a payment channel from a CoinJoin transaction.
Another potential source of false positives could be that an entity could represent several users if clustered addresses are controlled by a service (e.g., exchange) or on behalf of their users (custodial wallet).
However, these false positives can effectively be filtered out.</simpara>
<section id="_countermeasures">
<title>Countermeasures</title>
<simpara>If outputs of funding transactions are not reused for opening other channels, the snake heuristic does not work.
If users refrain from funding channels from a single external source and avoid collecting funds in a single external destination entity, the other heuristics would not yield any significant results.</simpara>
</section>
</section>
<section id="_off_chain_lightning_node_clustering">
<title>Off-Chain Lightning Node Clustering</title>
<simpara><indexterm>
  <primary>cross-layer de-anonymization</primary><secondary>off-chain Lightning node clustering</secondary>
</indexterm>
<indexterm>
  <primary>off-chain Lightning node clustering</primary>
</indexterm><indexterm>
  <primary>Lightning node clustering</primary>
</indexterm><indexterm>
  <primary>off-chain Lightning node clustering</primary>
</indexterm>LN nodes advertise aliases, for instance, <emphasis>LNBig.com</emphasis>.
Aliases can improve the usability of the system.
However, users tend to use similar aliases for their own different nodes.
For example, <emphasis>LNBig.com Billing</emphasis> is likely owned by the same user as the node with alias <emphasis>LNBig.com</emphasis>.
Given this observation, one can cluster LN nodes by applying their node aliases.
Specifically, one clusters LN nodes into a single address if their aliases are similar with respect to some string similarity metric.</simpara>
<simpara>Another method to cluster LN nodes is applying their IP or Tor addresses.
If the same IP or Tor addresses correspond to different LN nodes, these nodes are likely controlled by the same user.</simpara>
<section id="_countermeasures_2">
<title>Countermeasures</title>
<simpara>For more privacy, aliases should be sufficiently different from one another.
While the public announcement of IP addresses may be unavoidable for those nodes that wish to have incoming channels in the Lightning Network, linkability across nodes of the same user can be mitigated if the clients for each node are hosted with different service providers and thus IP addresses.</simpara>
</section>
</section>
<section id="_cross_layer_linking_lightning_nodes_and_bitcoin_entities">
<title>Cross-Layer Linking: Lightning Nodes and Bitcoin Entities</title>
<simpara><indexterm>
  <primary>Bitcoin entities</primary><secondary>cross-layer linking to Lightning nodes</secondary>
</indexterm>
<indexterm>
  <primary>cross-layer linking to Lightning nodes</primary>
</indexterm><indexterm>
  <primary>breaches of privacy</primary><secondary>cross-layer linking: Lightning nodes and Bitcoin entities</secondary>
</indexterm>
<indexterm>
  <primary>cross-layer linking: Lightning nodes and Bitcoin entities</primary>
</indexterm><indexterm>
  <primary>cross-layer de-anonymization</primary><secondary>cross-layer linking: Lightning nodes and Bitcoin entities</secondary>
</indexterm>
<indexterm>
  <primary>cross-layer linking: Lightning nodes and Bitcoin entities</primary>
</indexterm><indexterm>
  <primary>Lightning node operation</primary><secondary>cross-layer linking to Bitcoin entities</secondary>
</indexterm>
<indexterm>
  <primary>cross-layer linking to Bitcoin entities</primary>
</indexterm>Associating LN nodes to Bitcoin entities is a serious breach of privacy that is exacerbated by the fact that most LN nodes publicly expose their IP addresses.
Typically, an IP address can be considered as a unique identifier of a user.
Two widely observed behavior patterns reveal links between LN nodes and Bitcoin entities:</simpara>
<variablelist>
<varlistentry>
<term>
Coin reuse
</term>
<listitem>
<simpara>
Whenever users close payment channels, they get back their corresponding coins. However, many users reuse those coins in opening a new channel.
Those coins can effectively be linked to a common LN node.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Entity reuse
</term>
<listitem>
<simpara>
Typically, users fund their payment channels from Bitcoin addresses corresponding to the same Bitcoin entity.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>These cross-layer linking algorithms could be foiled if users possess multiple unclustered addresses or use multiple wallets to interact with the Lightning Network.</simpara>
<simpara>The possible de-anonymization of Bitcoin entities illustrates how important it is to consider the privacy of both layers simultaneously instead of one at a time.<indexterm>
</indexterm><indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
<section id="_lightning_graph">
<title>Lightning Graph</title>
<simpara><indexterm>
  <primary>Lightning graph</primary>
</indexterm><indexterm>
  <primary>security and privacy</primary><secondary>Lightning graph</secondary>
</indexterm>
<indexterm>
  <primary>Lightning graph</primary>
</indexterm>The Lightning Network, as the name suggests, is a peer-to-peer network of payment channels.
Therefore, many of its properties (privacy, robustness, connectivity, routing efficiency) are influenced and characterized by its network nature.</simpara>
<simpara>In this section, we discuss and analyze the Lightning Network from the point of view of network science.
We are particularly interested in understanding the LN channel graph, its robustness, connectivity, and other important characteristics.</simpara>
<section id="_how_does_the_lightning_graph_look_in_reality">
<title>How Does the Lightning Graph Look in Reality?</title>
<simpara><indexterm>
  <primary>Lightning graph</primary><secondary>reality versus theoretical appearance of</secondary>
</indexterm>
<indexterm>
  <primary>reality versus theoretical appearance of</primary>
</indexterm>One could have expected that the Lightning Network is a random graph, where edges are randomly formed between nodes.
If this was the case, then the Lightning Network&#8217;s degree distribution would follow a Gaussian normal distribution.
In particular, most of the nodes would have approximately the same degree, and we would not expect nodes with extraordinarily large degrees.
This is because the normal distribution exponentially decreases for values outside of the interval around the average value of the distribution.
The depiction of a random graph (as we saw in <xref linkend="lngraph"/>) looks like a mesh network topology.
It looks decentralized and nonhierarchical: every node seems to have equal importance.
Additionally, random graphs have a large diameter.
In particular, routing in such graphs is challenging because the shortest path between any two nodes is moderately long.</simpara>
<simpara>However, in stark contrast, the LN graph is completely different.</simpara>
<section id="_lightning_graph_today">
<title>Lightning graph today</title>
<simpara>Lightning is a financial network.
Thus, the growth and formation of the network are also influenced by economic incentives.
Whenever a node joins the Lightning Network, it may want to maximize its connectivity to other nodes in order to increase its routing efficiency. This phenomenon is called preferential attachment.
These economic incentives result in a fundamentally different network than a random graph.</simpara>
<simpara>Based on snapshots of publicly announced channels, the degree distribution of the Lightning Network follows a power-law function.
In such a graph, the vast majority of nodes have very few connections to other nodes, while only a handful of nodes have numerous connections.
At a high level, this graph topology resembles a star: the network has a well-connected core and a loosely connected periphery.
Networks with power-law degree distribution are also called scale-free networks.
This topology is advantageous for routing payments efficiently but prone to certain topology-based attacks.</simpara>
</section>
<section id="_topology_based_attacks">
<title>Topology-based attacks</title>
<simpara><indexterm>
  <primary>Lightning graph</primary><secondary>topology-based attacks</secondary>
</indexterm>
<indexterm>
  <primary>topology-based attacks</primary>
</indexterm><indexterm>
  <primary>topology-based attacks</primary>
</indexterm>An adversary might want to disrupt the Lightning Network and may decide its goal is to dismantle the whole network into many smaller components, making payment routing practically impossible in the whole network.
A less ambitious, but still malicious and severe goal might be to only take down certain network nodes.
Such a disruption might occur on the node level or on the edge level.</simpara>
<simpara>Let&#8217;s suppose an adversary can take down any node in the Lightning Network.
For instance, it can attack them with a distributed denial of service (DDoS) attack or make them nonoperational by any means.
It turns out that if the adversary chooses nodes randomly, then scale-free networks like the Lightning Network are robust against node-removal attacks.
This is because a random node lies on the periphery with a small number of connections, therefore playing a negligible role in the network&#8217;s connectivity.
However, if the adversary is more prudent, it can target the most well-connected nodes.
Not surprisingly, the Lightning Network and other scale-free networks are <emphasis>not</emphasis> robust against targeted node-removal attacks.</simpara>
<simpara>On the other hand, the adversary could be more stealthy.
Several topology-based attacks target a single node or a single payment channel.
For example, an adversary might be interested in exhausting a certain payment channel&#8217;s capacity on purpose.
More generally, an adversary can deplete all the outgoing capacity of a node to knock it down from the routing market.
This could be easily obtained by routing payments through the victim node with amounts equalling the outgoing capacity of each payment channel.
After completing this so-called node isolation attack, the victim cannot send or route payments anymore unless it receives a payment or rebalances its channels.</simpara>
<simpara>To conclude, even by design, it is possible to remove edges and nodes from the routable Lightning Network.
However, depending on the utilized attack vector, the adversary may have to provide more or fewer resources to carry out the attack.</simpara>
</section>
<section id="_temporality_of_the_lightning_network">
<title>Temporality of the Lightning Network</title>
<simpara><indexterm>
  <primary>Lightning graph</primary><secondary>temporality of Lightning Network and</secondary>
</indexterm>
<indexterm>
  <primary>temporality of Lightning Network and</primary>
</indexterm><indexterm>
  <primary>temporality of Lightning Network</primary>
</indexterm>The Lightning Network is a dynamically changing, permissionless network.
Nodes can freely join or leave the network, they can open and create payment channels anytime they want.
Therefore, a single static snapshot of the LN graph is misleading. We need to consider the temporality and ever-changing nature of the network. For now, the LN graph is growing in terms of the number of nodes and payment channels.
Its effective diameter is also shrinking; that is, nodes become closer to each other, as we can see in <xref linkend="temporal_ln"/>.</simpara>
<figure id="temporal_ln"><title>The steady growth of the Lightning Network in nodes, channels, and locked capacity (as of September 2021)</title>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/mtln_1602.png"/>
  </imageobject>
  <textobject><phrase>The steady growth of the Lightning Network in terms of nodes, channels, and locked capacity (as of September 2021)</phrase></textobject>
</mediaobject>
</figure>
<simpara>In social networks, triangle closing behavior is common.
Specifically, in a graph where nodes represent people and friendships are represented as edges, it is somewhat expected that triangles will emerge in the graph.
A triangle, in this case, represents pairwise friendships between three people.
For instance, if Alice knows Bob and Bob knows Charlie, then it is likely that at some point Bob will introduce Alice to Charlie.
However, this behavior would be strange in the Lightning Network.
Nodes are simply not incentivized to close triangles because they could have just routed payments instead of opening a new payment channel.
Surprisingly, triangle closing is a common practice in the Lightning Network.
The number of triangles was steadily growing before the implementation of multipart payments.
This is counterintuitive and surprising given that nodes could have just routed payments through the two sides of the triangle instead of opening the third channel.
This may mean that routing inefficiencies incentivized users to close triangles and not fall back on routing.
Hopefully, multipart payments will help increase the effectiveness of payment routing<indexterm>
</indexterm>.<indexterm>
</indexterm><indexterm>
</indexterm></simpara>
</section>
</section>
</section>
<section id="_centralization_in_the_lightning_network">
<title>Centralization in the Lightning Network</title>
<simpara><indexterm>
  <primary>betweenness centrality</primary>
</indexterm><indexterm>
  <primary>central point dominance</primary>
</indexterm><indexterm>
  <primary>centralization, Lightning Network and</primary>
</indexterm><indexterm>
  <primary>security and privacy</primary><secondary>centralization in Lightning Network</secondary>
</indexterm>
<indexterm>
  <primary>centralization in Lightning Network</primary>
</indexterm>A common metric to assess the centrality of a node in a graph is its <emphasis>betweenness centrality</emphasis>. Central point dominance is a metric derived from betweenness centrality, used to assess the centrality of a network.
For a precise definition of central point dominance, the reader is referred to <ulink url="https://doi.org/10.2307/3033543">Freeman&#8217;s work</ulink>.</simpara>
<simpara>The larger the central point dominance of a network is, the more centralized the network is.
We can observe that the Lightning Network has a greater central point dominance (i.e., it is more centralized) than a random graph (Erdős–Rényi graph) or a scale-free graph (Barabási–Albert graph) of equal size.</simpara>
<simpara>In general, our understanding of the dynamic nature of the LN channel graph is rather limited.
It is fruitful to analyze how protocol changes like multipart payments can affect the dynamics of the Lightning Network.
It would be beneficial to explore the temporal nature of the LN graph in more depth.</simpara>
</section>
<section id="_economic_incentives_and_graph_structure">
<title>Economic Incentives and Graph Structure</title>
<simpara><indexterm>
  <primary>Lightning graph</primary><secondary>economic incentives and graph structure</secondary>
</indexterm>
<indexterm>
  <primary>economic incentives and graph structure</primary>
</indexterm><indexterm>
  <primary>security and privacy</primary><secondary>economic incentives and graph structure</secondary>
</indexterm>
<indexterm>
  <primary>economic incentives and graph structure</primary>
</indexterm>The LN graph forms spontaneously, and nodes connect to each other based on mutual interest.
As a result, incentives drive graph development.
Let&#8217;s look at some of the relevant incentives:</simpara>
<itemizedlist>
<listitem>
<simpara>
Rational incentives:
</simpara>
<itemizedlist>
<listitem>
<simpara>
Nodes establish channels to send, receive, and route payments (earn fees).
</simpara>
</listitem>
<listitem>
<simpara>
What makes a channel more likely to be established between two nodes that act rationally?
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Altruistic incentives:
</simpara>
<itemizedlist>
<listitem>
<simpara>
Nodes establish channels "for the good of the network."
</simpara>
</listitem>
<listitem>
<simpara>
While we should not base our security assumptions on altruism, to a certain extent, altruistic behavior drives Bitcoin (accepting incoming connections, serving blocks).
</simpara>
</listitem>
<listitem>
<simpara>
What role does it play in Lightning?
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>In the early stages of the Lightning Network, many node operators have claimed that the earned routing fees do not compensate for the opportunity costs stemming from liquidity lock-up. This would indicate that operating a node may be driven mostly by altruistic incentives "for the good of the network."
This might change in the future if the Lightning Network has significantly larger traffic or if a market for routing fees emerges.
On the other hand, if a node wishes to optimize its routing fees, it would minimize the average shortest path lengths to every other node.
Put differently, a profit-seeker node will try to locate itself in the <emphasis>center</emphasis> of the channel graph or close <span class="keep-together">to it</span>.</simpara>
</section>
<section id="_practical_advice_for_users_to_protect_their_privacy">
<title>Practical Advice for Users to Protect Their Privacy</title>
<simpara><indexterm>
  <primary>security and privacy</primary><secondary>practical advice for users to protect privacy</secondary>
</indexterm>
<indexterm>
  <primary>practical advice for users to protect privacy</primary>
</indexterm>We&#8217;re still in the early stages of the Lightning Network.
Many of the concerns listed in this chapter are likely to be addressed as it matures and grows.
In the meantime, there are some measures that you can take to guard your node against malicious users; something as simple as updating the default parameters that your node runs with can go a long way in hardening your node.</simpara>
</section>
<section id="_unannounced_channels">
<title>Unannounced Channels</title>
<simpara><indexterm>
  <primary>payment channel</primary><secondary>unannounced channels</secondary>
</indexterm>
<indexterm>
  <primary>unannounced channels</primary>
</indexterm><indexterm>
  <primary>security and privacy</primary><secondary>unannounced channels</secondary>
</indexterm>
<indexterm>
  <primary>unannounced channels</primary>
</indexterm><indexterm>
  <primary>unannounced channels</primary>
</indexterm>If you intend to use the Lightning Network to send and receive funds between nodes and wallets you control, and have no interest in routing other users' payments, there is little need to announce your channels to the rest of the network.
You could open a channel between, say, your desktop PC running a full node and your mobile phone running a Lightning wallet, and simply forgo the channel announcement discussed in <xref linkend="ch03_How_Lightning_Works"/>.
These are sometimes called "private" channels; however, it is more correct to refer to them as "unannounced" channels because they are not strictly private.</simpara>
<simpara>Unannounced channels will not be known to the rest of the network and won&#8217;t normally be used to route other users' payments.
They can still be used to route payments if other nodes are made aware of them; for example, an invoice could contain routing hints which suggests a path with an unannounced channel.
However, assuming that you&#8217;ve only opened an unannounced channel with yourself, you do gain some measure of privacy.
Since you are not exposing your channel to the network, you lower the risk of a denial-of-service attack on your node.
You can also more easily manage the capacity of this channel, since it will only be used to receive or send directly to your node.</simpara>
<simpara>There are also advantages to opening an unannounced channel with a known party that you transact with frequently.
For example, if Alice and Bob frequently play poker for bitcoin, they could open a channel to send their winnings back and forth.
Under normal conditions, this channel will not be used to route payments from other users or collect fees.
And since the channel will not be known to the rest of the network, any payments between Alice and Bob cannot be inferred by tracking changes in the channel&#8217;s routing capacity.
This confers some privacy to Alice and Bob; however, if one of them decides to make other users aware of the channel, such as by including it in the routing hints of an invoice, then this privacy is lost.</simpara>
<simpara>It should also be noted that to open an unannounced channel, a public transaction must be made on the Bitcoin blockchain.
Hence it is possible to infer the existence and size of the channel if a malicious party is monitoring the blockchain for channel opening transactions and attempting to match them to channels on the network.
Furthermore, when the channel is closed, the final balance of the channel will be made public once it&#8217;s committed to the Bitcoin blockchain.
However, since the opening and commitment transactions are pseudonymous, it will not be a simple matter to connect it back to Alice or Bob.
In addition, the Taproot update of 2021 makes it difficult to distinguish between channel opening and closing transactions and other specific kinds of Bitcoin transactions.
Hence, while unannouned channels are not completely private, they do provide some privacy benefits when used carefully.</simpara>
</section>
<section id="routing_considerations">
<title>Routing Considerations</title>
<simpara><indexterm>
  <primary>denial-of-service (DoS) attacks</primary><secondary>protecting against</secondary>
</indexterm>
<indexterm>
  <primary>protecting against</primary>
</indexterm><indexterm>
  <primary>routing</primary><secondary>security/privacy considerations</secondary>
</indexterm>
<indexterm>
  <primary>security/privacy considerations</primary>
</indexterm><indexterm>
  <primary>security and privacy</primary><secondary>routing considerations</secondary>
</indexterm>
<indexterm>
  <primary>routing considerations</primary>
</indexterm>As covered in <xref linkend="denial_of_service"/>, nodes that open public channels expose themselves to the risk of a series of attacks on their channels.
While mitigations are being developed on the protocol level, there are many steps that a node can take to protect against denial of service attacks on their public channels:</simpara>
<variablelist>
<varlistentry>
<term>
Minimum HTLC size
</term>
<listitem>
<simpara>
On channel open, your node can set the minimum HTLC size that it will accept.
Setting a higher value ensures that each of your available channel slots cannot be occupied by a very small payment.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Rate limiting
</term>
<listitem>
<simpara>
Many node implementations allow nodes to dynamically accept or reject HTLCs that are forwarded through your node.
Some useful guidelines for a custom rate limiter are as follows:
</simpara>
<itemizedlist>
<listitem>
<simpara>
Limit the number of commitment slots a single peer may consume
</simpara>
</listitem>
<listitem>
<simpara>
Monitor failure rates from a single peer, and rate limit if their failures spike suddenly
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
Shadow channels
</term>
<listitem>
<simpara>
Nodes that wish to open large channels to a single target can instead open a single public channel to the target and support it with further private channels called <a href='https://anchor.fm/tales-from-the-crypt/episodes/197-Joost-Jager-ekghn6'>shadow channels</a>. These channels can still be used for routing but are not announced to potential attackers.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<section id="_accepting_channels">
<title>Accepting Channels</title>
<simpara><indexterm>
  <primary>routing</primary><secondary>accepting channels</secondary>
</indexterm>
<indexterm>
  <primary>accepting channels</primary>
</indexterm>At present, Lightning nodes struggle with bootstrapping inbound liquidity. While there are some paid
solutions to acquiring inbound liquidity, like swap services, channel markets, and paid channel opening services from known hubs, many nodes will gladly accept any legitimate looking channel opening request to increase their inbound liquidity.</simpara>
<simpara>Stepping back to the context of Bitcoin, this can be compared to the way that Bitcoin Core treats its incoming and outgoing connections differently out of concern that the node may be eclipsed.
If a node opens an incoming connection to your Bitcoin node, you have no way of knowing whether the initiator randomly selected you or is specifically targeting your node with malicious intent.
Your outgoing connections do not need to be treated with such suspicion because either the node was selected randomly from a pool of many potential peers or you intentionally connected to the peer manually.</simpara>
<simpara>The same can be said in Lightning.
When you open a channel, it is done with intention, but when a remote party opens a channel to your node, you have no way of knowing whether this channel will be used to attack your node or not.
As several papers note, the relatively low cost of spinning up a node and opening channels to targets is one of the significant factors that make attacks easy.
If you accept incoming channels, it is prudent to place some restrictions on the nodes you accept incoming channels from.
Many implementations expose channel acceptance hooks that allow you to tailor your channel acceptance policies to your preferences.</simpara>
<simpara>The question of accepting and rejecting channels is a philosophical one.
What if we end up with a Lightning Network where new nodes cannot participate because they cannot open any channels?
Our suggestion is not to set an exclusive list of "mega-hubs" from which you will accept channels, but rather to accept channels in a manner that suits your risk preference.</simpara>
<simpara>Some potential strategies are:</simpara>
<variablelist>
<varlistentry>
<term>
No risk
</term>
<listitem>
<simpara>
Do not accept any incoming channels.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Low risk
</term>
<listitem>
<simpara>
Accept channels from a known set of nodes that you have previously had successful channels open with.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Medium risk
</term>
<listitem>
<simpara>
Only accept channels from nodes that have been present in the graph for a longer period and have some long-lived channels.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Higher risk
</term>
<listitem>
<simpara>
Accept any incoming channels, and implement the mitigations described in <xref linkend="routing_considerations"/>.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="_conclusion_15">
<title>Conclusion</title>
<simpara>In summary, privacy and security are nuanced, complex topics, and while many researchers and developers are looking for network-wide improvements, it&#8217;s important for everyone participating in the network to understand what they can do to protect their own privacy and increase security on an individual node level.</simpara>
</section>
<section id="_references_and_further_reading">
<title>References and Further Reading</title>
<simpara>In this chapter, we used many references from ongoing research on Lightning security. You may find these useful articles and papers listed by topic in the following lists.</simpara>
<section id="_privacy_and_probing_attacks">
<title>Privacy and probing attacks</title>
<itemizedlist>
<listitem>
<simpara>
Jordi Herrera-Joancomartí et al. <ulink url="https://eprint.iacr.org/2019/328">"On the Difficulty of Hiding the Balance of Lightning Network Channels"</ulink>. <emphasis>Asia CCS '19: Proceedings of the 2019 ACM Asia Conference on Computer and Communications Security</emphasis> (July 2019): 602–612.
</simpara>
</listitem>
<listitem>
<simpara>
Utz Nisslmueller et al. "Toward Active and Passive Confidentiality Attacks on Cryptocurrency Off-Chain Networks." arXiv preprint, <ulink url="https://arxiv.org/abs/2003.00003">https://arxiv.org/abs/2003.00003</ulink> (2020).
</simpara>
</listitem>
<listitem>
<simpara>
Sergei Tikhomirov et al. "Probing Channel Balances in the Lightning Network." arXiv preprint, <ulink url="https://arxiv.org/abs/2004.00333">https://arxiv.org/abs/2004.00333</ulink> (2020).
</simpara>
</listitem>
<listitem>
<simpara>
George Kappos et al. "An Empirical Analysis of Privacy in the Lightning Network." arXiv preprint, <ulink url="https://arxiv.org/abs/2003.12470">https://arxiv.org/abs/2003.12470</ulink> (2021).
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/LN-Zap/zap-desktop/blob/v0.7.2-beta/services/grpc/router.methods.js">Zap source code with the probing function</ulink>.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_congestion_attacks">
<title>Congestion attacks</title>
<itemizedlist>
<listitem>
<simpara>
Ayelet Mizrahi and Aviv Zohar. "Congestion Attacks in Payment Channel Networks." arXiv preprint, <ulink url="https://arxiv.org/abs/2002.06564">https://arxiv.org/abs/2002.06564</ulink> (2020).
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_routing_considerations">
<title>Routing considerations</title>
<itemizedlist>
<listitem>
<simpara>
Marty Bent, interview with Joost Jager, <emphasis>Tales from the Crypt</emphasis>, podcast audio, October 2, 2020, <ulink url="https://anchor.fm/tales-from-the-crypt/episodes/197-Joost-Jager-ekghn6">https://anchor.fm/tales-from-the-crypt/episodes/197-Joost-Jager-ekghn6</ulink>.<indexterm>
</indexterm>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter id="conclusion_chapter">
<title>Conclusion</title>
<simpara><indexterm>
  <primary>innovations in Lightning</primary>
</indexterm>In just a few years, the Lightning Network has gone from a whitepaper to a rapidly growing global network. As Bitcoin&#8217;s second layer, it has delivered on the promise of fast, inexpensive, and private payments. Additionally, it has started a tsunami of innovation, as it unleashes developers from the constraints of lockstep consensus that exist in Bitcoin development.</simpara>
<simpara>Innovation in the Lightning Network is happening in several different levels:</simpara>
<itemizedlist>
<listitem>
<simpara>
At Bitcoin&#8217;s Core protocol, providing use and demand for new Bitcoin Script opcodes, signing algorithms, and optimizations
</simpara>
</listitem>
<listitem>
<simpara>
At the Lightning protocol level, with new features deployed rapidly network wide
</simpara>
</listitem>
<listitem>
<simpara>
At the payment channel level, with new channel constructs and enhancements
</simpara>
</listitem>
<listitem>
<simpara>
As distinct opt-in features deployed end-to-end by independent implementations that senders and recipients can use if they want
</simpara>
</listitem>
<listitem>
<simpara>
With new and exciting Lightning Applications (LApps) build on top of the clients and protocols
</simpara>
</listitem>
</itemizedlist>
<simpara>Let&#8217;s look at how these innovations are changing Lightning now and in the near future.</simpara>
<section id="_decentralized_and_asynchronous_innovation">
<title>Decentralized and Asynchronous Innovation</title>
<simpara><indexterm>
  <primary>innovations in Lightning</primary><secondary>decentralized/asynchronous nature of</secondary>
</indexterm>
<indexterm>
  <primary>decentralized/asynchronous nature of</primary>
</indexterm>Lightning isn&#8217;t bound by lockstep consensus, as is the case with Bitcoin. That means that different Lightning clients can implement different features and negotiate their interactions (see <xref linkend="feature_bits"/>). As a result, innovation in the Lightning Network is occurring at a much faster rate than in Bitcoin.</simpara>
<simpara>Not only is Lightning advancing rapidly, but it is creating demand for new features in the Bitcoin system. Many recent and planned innovations in Bitcoin are both motivated and justified by their use in the Lightning Network. In fact, the Lightning Network is often mentioned as an example use case for many of the new features.</simpara>
<section id="bitcoin_prot_17">
<title>Bitcoin Protocol and Bitcoin Script Innovation</title>
<simpara><indexterm>
  <primary>Bitcoin (system)</primary><secondary>innovations motivated by Lightning Network use cases</secondary>
</indexterm>
<indexterm>
  <primary>innovations motivated by Lightning Network use cases</primary>
</indexterm><indexterm>
  <primary>Bitcoin script</primary><secondary>innovations motivated by Lightning Network use cases</secondary>
</indexterm>
<indexterm>
  <primary>innovations motivated by Lightning Network use cases</primary>
</indexterm><indexterm>
  <primary>innovations in Lightning</primary><secondary>Bitcoin innovations motivated by Lightning Network use cases</secondary>
</indexterm>
<indexterm>
  <primary>Bitcoin innovations motivated by Lightning Network use cases</primary>
</indexterm>The Bitcoin system is, by necessity, a conservative system that has to preserve compatibility with consensus rules to avoid unplanned forks of the blockchain or partitions of the P2P network. As a result, new features require a lot of coordination and testing before they are implemented in mainnet, the live production system.</simpara>
<simpara>Here are some of the current or proposed innovations in Bitcoin that are motivated by use cases in the Lightning Network:</simpara>
<variablelist>
<varlistentry>
<term>
Neutrino
</term>
<listitem>
<simpara>
A lightweight client protocol with improved privacy features over the legacy SPV protocol. Neutrino is mostly used by Lightning clients to access the Bitcoin blockchain.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Schnorr signatures
</term>
<listitem>
<simpara>
Introduced as part of the <emphasis>Taproot</emphasis> soft fork, Schnorr signatures will enable flexible Point Time-Locked Contracts (PTLCs) for channel construction in Lightning. This might in particular make use of revocable signatures instead of revocable transactions.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Taproot
</term>
<listitem>
<simpara>
Also part of the November 2021 soft fork that introduces Schnorr signatures, Taproot allows complex scripts to appear as single-payer, single-payee payments, and indistinguishable from the most common type of payment on Bitcoin. This will allow Lightning channel cooperative (mutual) closure transactions to appear indistinguishable from simple payments and increase privacy for LN users.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Input rebinding
</term>
<listitem>
<simpara>
Also known by the names SIGHAS_NOINPUT or SIGHASH_ANYPREVOUT, this planned upgrade to the Bitcoin Script language is primarily motivated by advanced smart contracts such as the eltoo channel protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Covenants
</term>
<listitem>
<simpara>
Currently in the early stages of research, covenants allow transactions to create outputs that constrain future transactions which spend them. This mechanism could increase security for Lightning channels by making it possible to enforce address whitelisting in commitment transactions.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_lightning_protocol_innovation">
<title>Lightning Protocol Innovation</title>
<simpara><indexterm>
  <primary>innovations in Lightning</primary><secondary>Lightning P2P protocol</secondary>
</indexterm>
<indexterm>
  <primary>Lightning P2P protocol</primary>
</indexterm><indexterm>
  <primary>Lightning Network Protocol</primary><secondary>innovations in</secondary>
</indexterm>
<indexterm>
  <primary>innovations in</primary>
</indexterm>The Lightning P2P protocol is highly extensible and has undergone a lot of change since its inception. The "It&#8217;s OK to be odd" rule used in feature bits (see <xref linkend="feature_bits"/>) ensures that nodes can negotiate the features they support, enabling multiple independent upgrades to the protocol.</simpara>
</section>
<section id="_tlv_extensibility">
<title>TLV Extensibility</title>
<simpara><indexterm>
  <primary>innovations in Lightning</primary><secondary>TLV extensibility</secondary>
</indexterm>
<indexterm>
  <primary>TLV extensibility</primary>
</indexterm><indexterm>
  <primary>Type-Length-Value (TLV) format</primary><secondary>innovations in</secondary>
</indexterm>
<indexterm>
  <primary>innovations in</primary>
</indexterm>The Type-Length-Value (see <xref linkend="tlv"/>) mechanism for extending the messaging protocol is extremely powerful and has already enabled the introduction of several new capabilities in Lightning while maintaining both forward and backward compatibility.
A prominent example, which is currently being developed and makes use of this, is path blinding and trampoline payments. This allows a recipient to hide itself from the sender, but also allows mobile clients to send payments without the necessity of storing the full channel graph on their devices by using a third party to which they don&#8217;t need to reveal the final recipient.</simpara>
</section>
<section id="_payment_channel_construction">
<title>Payment Channel Construction</title>
<simpara><indexterm>
  <primary>innovations in Lightning</primary><secondary>payment channel construction</secondary>
</indexterm>
<indexterm>
  <primary>payment channel construction</primary>
</indexterm><indexterm>
  <primary>payment channel</primary><secondary>innovations in construction</secondary>
</indexterm>
<indexterm>
  <primary>innovations in construction</primary>
</indexterm>Payment channels are an abstraction that is operated by two channel partners. As long as those two are willing to run new code, they can implement a variety of channel mechanisms simultaneously. In fact, recent research suggests that channels could even be upgraded to a new mechanism dynamically, without closing the old channel and opening a new channel type.</simpara>
<variablelist>
<varlistentry>
<term>
eltoo
</term>
<listitem>
<simpara>
A proposed channel mechanism that uses input-rebinding to significantly simplify the operation of payment channels and remove the need for the penalty mechanism. It needs a new Bitcoin signature type before it can be implemented
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_opt_in_end_to_end_features">
<title>Opt-In End-to-End Features</title>
<variablelist>
<varlistentry>
<term>
<indexterm>
  <primary>innovations in Lightning</primary><secondary>opt-in end-to-end features</secondary>
</indexterm>
<indexterm>
  <primary>opt-in end-to-end features</primary>
</indexterm>Point Time-Locked Contracts
</term>
<listitem>
<simpara>
A different approach to HTLCs, PTLCs can increase privacy, reduce information leaked to intermediary nodes, and operate more efficiently than HTLC-based channels.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Large channels
</term>
<listitem>
<simpara>
Large or <emphasis>Wumbo</emphasis> channels were introduced in a dynamic way to the network without requiring coordination. Channels that support large payments are advertized as part of the channel announcement messages and can be used in an opt-in manner.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Multipart payments (MPP)
</term>
<listitem>
<simpara>
MPP was also introduced in an opt-in manner, but even better only requires the sender and recipient of a payment to be able to do MPP. The rest of the network simply routes HTLCs as if they are single-part payments.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
JIT routing
</term>
<listitem>
<simpara>
An optional method that can be used by routing nodes to increase their reliability and to protect themselves from being spammed.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Keysend
</term>
<listitem>
<simpara>
An upgrade introduced independently by Lightning client implementations, it allows the sender to send money in an "unsolicited" and asynchronous way without requiring an invoice first.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
HODL invoices<footnote><simpara>The word <emphasis>HODL</emphasis> comes from an excited misspelling of the word "HOLD" shouted in a forum to encourage people not to sell bitcoin in a panic.</simpara></footnote>
</term>
<listitem>
<simpara>
Payments where the final HTLC is not collected, committing the sender to the payment, but allowing the recipient to delay collection until some other condition is satisfied, or cancel the invoice without collection. This was also implemented independently by different Lightning clients and can be used in an opt-in manner.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Onion routed message services
</term>
<listitem>
<simpara>
The onion routing mechanism and the underlying public key database of nodes can be used to send data that is unrelated to payments, such as text messages or forum posts. The use of Lightning to enable paid messaging as a solution to spam posts and Sybil attacks (spam) is another innovation that was implemented independently of the core protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Offers
</term>
<listitem>
<simpara>
Currently proposed as BOLT #12 but already implemented by some nodes, this is a communication protocol to request (recurring) invoices from remote nodes via Onion messages.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="lapps">
<title>Lightning Applications (LApps)</title>
<simpara><indexterm>
  <primary>innovations in Lightning</primary><secondary>Lightning Applications</secondary>
</indexterm>
<indexterm>
  <primary>Lightning Applications</primary>
</indexterm><indexterm>
  <primary>Lightning Applications (LApps)</primary>
</indexterm>While still in their infancy, we are already seeing the emergence of interesting Lightning Applications. Broadly defined as an application that uses the Lightning Protocol or a Lightning client as a component, LApps are the application layer of Lightning.
A prominent example is LNURL, which provides a similar functionality as BOLT #12 offers, but just over HTTP and Lightning addresses. It works on top of offers to provide users with an email-style address to which others can send funds while the software in the background requests an invoice against the LNURL endpoint of the node.
Further LApps are being built for simple games, messaging applications, microservices, payable APIs, paid dispensers (e.g., fuel pumps), derivative trading systems, and much more.</simpara>
</section>
<section id="_ready_set_go">
<title>Ready, Set, Go!</title>
<simpara>The future is looking bright. The Lightning Network is taking Bitcoin to new unexplored markets and applications. Equipped with the knowledge in this book, you can explore this new frontier or maybe even join as a pioneer and forge a new path.<indexterm>
</indexterm></simpara>
<simpara>#include::appendix-bitcoin-fundamentals-review.asciidoc[]</simpara>
<simpara>#include::appendix_docker_basics.asciidoc[]</simpara>
<simpara>#include::appendix_license_notices.asciidoc[]</simpara>
<simpara>#include::appendix_protocol_messages.asciidoc[]</simpara>
<simpara>#include::failure_types_table.asciidoc[]</simpara>
<simpara>#include::glossary.asciidoc[]</simpara>
<simpara>#include::part_1_divider.asciidoc[]</simpara>
<simpara>#include::part_2_divider.asciidoc[]</simpara>
</section>
</chapter>
</book>
